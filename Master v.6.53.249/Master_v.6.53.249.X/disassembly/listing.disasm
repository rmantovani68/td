Disassembly Listing for Split v.8.4.22
Generated From:
D:/WORK3/Lavori/TERMODINAMICA/Work/FW/1 - Generico/Split/Split v.8.4.22 - Working/Split v.8.4.22.X/dist/default/debug/Split_v.8.4.22.X.debug.elf
4-ago-2015 2.05.11

---  D:/WORK3/Lavori/TERMODINAMICA/Work/FW/1 - Generico/Split/Split v.8.4.22 - Working/usart.c  ---------
1:                 //----------------------------------------------------------------------------------
2:                 //	Include
3:                 //----------------------------------------------------------------------------------
4:                 #include "MicroModelSelection.h"
5:                 #ifdef GB210
6:                 	#include <p24FJ256GB210.h>
7:                 #else
8:                 	#include <p24FJ256GB110.h>
9:                 #endif
10:                #include <stdio.h>
11:                #include "DefinePeriferiche.h"
12:                #include "usart.h"
13:                
14:                //----------------------------------------------------------------------------------
15:                //	Funzioni
16:                //----------------------------------------------------------------------------------
17:                
18:                //----------------------------------------
19:                // USART 1 - RS485 Master
20:                //----------------------------------------
21:                void putch1 (char byte)
22:                {
008B98  FA0002     LNK #0x2
008B9A  784F00     MOV.B W0, [W14]
23:                	while(U1STAbits.UTXBF)		// attendo che il buffer di scrittura sia libero
008B9C  000000     NOP
008B9E  370001     BRA 0x8BA2
008BA2  801115     MOV U1STA, W5
008BA4  202004     MOV #0x200, W4
008BA6  628204     AND W5, W4, W4
008BA8  520FE0     SUB W4, #0x0, [W15]
008BAA  3AFFFA     BRA NZ, 0x8BA0
24:                		continue;
008BA0  000000     NOP
25:                	oRTS_Master = 1;			// alzo il pin dell'rts x la 485
008BAC  A8A2EC     BSET LATF, #5
26:                	U1TXREG = byte;				// pongo il carattere nel buffer di trasmissione
008BAE  FB021E     SE [W14], W4
008BB0  881124     MOV W4, U1TXREG
27:                	__builtin_nop();
008BB2  000000     NOP
28:                	while(!U1STAbits.TRMT)		// attendo la fine della trasmissione
008BB4  000000     NOP
008BB6  370001     BRA 0x8BBA
008BBA  801115     MOV U1STA, W5
008BBC  201004     MOV #0x100, W4
008BBE  628204     AND W5, W4, W4
008BC0  520FE0     SUB W4, #0x0, [W15]
008BC2  32FFFA     BRA Z, 0x8BB8
29:                		continue;
008BB8  000000     NOP
30:                	oRTS_Master = 0;			// abbasso il pin dell'rts x la 485
008BC4  A9A2EC     BCLR LATF, #5
31:                }
008BC6  FA8000     ULNK
008BC8  060000     RETURN
32:                
33:                char getch1(void)
34:                {
008BCA  FA0000     LNK #0x0
35:                	while(!U1STAbits.URXDA)		// attendo che ci sia un dato disponibile
008BCC  000000     NOP
008BCE  370001     BRA 0x8BD2
008BD2  801114     MOV U1STA, W4
008BD4  620261     AND W4, #0x1, W4
008BD6  520FE0     SUB W4, #0x0, [W15]
008BD8  32FFFB     BRA Z, 0x8BD0
36:                		continue;	
008BD0  000000     NOP
37:                	return U1RXREG;				// lo leggo, riportandolo come output della funzione
008BDA  801134     MOV U1RXREG, W4
008BDC  784204     MOV.B W4, W4
38:                }
008BDE  784004     MOV.B W4, W0
008BE0  FA8000     ULNK
008BE2  060000     RETURN
39:                
40:                //----------------------------------------
41:                // USART 2 - RS485 Slave
42:                //----------------------------------------
43:                void putch2 (char byte)
44:                {
008BE4  FA0002     LNK #0x2
008BE6  784F00     MOV.B W0, [W14]
45:                	while(U2STAbits.UTXBF)		// attendo che il buffer di scrittura sia libero
008BE8  000000     NOP
008BEA  370001     BRA 0x8BEE
008BEE  801195     MOV U2STA, W5
008BF0  202004     MOV #0x200, W4
008BF2  628204     AND W5, W4, W4
008BF4  520FE0     SUB W4, #0x0, [W15]
008BF6  3AFFFA     BRA NZ, 0x8BEC
46:                		continue;
008BEC  000000     NOP
47:                	oRTS_Slave = 1;				// alzo il pin dell'rts x la 485
008BF8  A862EC     BSET LATF, #3
48:                	U2TXREG = byte;				// pongo il carattere nel buffer di trasmissione
008BFA  FB021E     SE [W14], W4
008BFC  8811A4     MOV W4, U2TXREG
49:                	__builtin_nop();
008BFE  000000     NOP
50:                	while(!U2STAbits.TRMT)		// attendo la fine della trasmissione
008C00  000000     NOP
008C02  370001     BRA 0x8C06
008C06  801195     MOV U2STA, W5
008C08  201004     MOV #0x100, W4
008C0A  628204     AND W5, W4, W4
008C0C  520FE0     SUB W4, #0x0, [W15]
008C0E  32FFFA     BRA Z, 0x8C04
51:                		continue;
008C04  000000     NOP
52:                	oRTS_Slave = 0;				// abbasso il pin dell'rts x la 485
008C10  A962EC     BCLR LATF, #3
53:                }
008C12  FA8000     ULNK
008C14  060000     RETURN
54:                
55:                char getch2(void)
56:                {
008C16  FA0000     LNK #0x0
57:                	while(!U2STAbits.URXDA)		// attendo che ci sia un dato disponibile
008C18  000000     NOP
008C1A  370001     BRA 0x8C1E
008C1E  801194     MOV U2STA, W4
008C20  620261     AND W4, #0x1, W4
008C22  520FE0     SUB W4, #0x0, [W15]
008C24  32FFFB     BRA Z, 0x8C1C
58:                		continue;	
008C1C  000000     NOP
59:                	return U2RXREG;				// lo leggo, riportandolo come output della funzione
008C26  8011B4     MOV U2RXREG, W4
008C28  784204     MOV.B W4, W4
60:                }
008C2A  784004     MOV.B W4, W0
008C2C  FA8000     ULNK
008C2E  060000     RETURN
61:                
62:                //----------------------------------------
63:                // USART 4 x debug rtx RS232TTL
64:                //----------------------------------------
65:                void putch (char byte)
66:                {
008C30  FA0002     LNK #0x2
008C32  784F00     MOV.B W0, [W14]
67:                	while(U4STAbits.UTXBF)		// attendo che il buffer di scrittura sia libero
008C34  000000     NOP
008C36  370001     BRA 0x8C3A
008C3A  801595     MOV U4STA, W5
008C3C  202004     MOV #0x200, W4
008C3E  628204     AND W5, W4, W4
008C40  520FE0     SUB W4, #0x0, [W15]
008C42  3AFFFA     BRA NZ, 0x8C38
68:                		continue;
008C38  000000     NOP
69:                	U4RXREG = byte;				// pongo il carattere nel buffer di trasmissione
008C44  FB021E     SE [W14], W4
008C46  8815B4     MOV W4, U4RXREG
70:                	while(!U4STAbits.TRMT)		// attendo la fine della trasmissione
008C48  000000     NOP
008C4A  370001     BRA 0x8C4E
008C4E  801595     MOV U4STA, W5
008C50  201004     MOV #0x100, W4
008C52  628204     AND W5, W4, W4
008C54  520FE0     SUB W4, #0x0, [W15]
008C56  32FFFA     BRA Z, 0x8C4C
71:                		continue;
008C4C  000000     NOP
72:                }
008C58  FA8000     ULNK
008C5A  060000     RETURN
73:                
74:                char getch(void)
75:                {
008C5C  FA0000     LNK #0x0
76:                	while(!U4STAbits.URXDA)		// attendo che ci sia un dato disponibile
008C5E  000000     NOP
008C60  370001     BRA 0x8C64
008C64  801594     MOV U4STA, W4
008C66  620261     AND W4, #0x1, W4
008C68  520FE0     SUB W4, #0x0, [W15]
008C6A  32FFFB     BRA Z, 0x8C62
77:                		continue;	
008C62  000000     NOP
78:                	return U4RXREG;				// lo leggo, riportandolo come output della funzione
008C6C  8015B4     MOV U4RXREG, W4
008C6E  784204     MOV.B W4, W4
79:                }
008C70  784004     MOV.B W4, W0
008C72  FA8000     ULNK
008C74  060000     RETURN
80:                
81:                char getche(void)
82:                {
008C76  FA0000     LNK #0x0
83:                	while(!U4STAbits.URXDA)		// attendo che ci sia un dato disponibile
008C78  000000     NOP
008C7A  370001     BRA 0x8C7E
008C7E  801594     MOV U4STA, W4
008C80  620261     AND W4, #0x1, W4
008C82  520FE0     SUB W4, #0x0, [W15]
008C84  32FFFB     BRA Z, 0x8C7C
84:                		continue;	
008C7C  000000     NOP
85:                	return U4RXREG;				// lo leggo, riportandolo come output della funzione
008C86  8015B4     MOV U4RXREG, W4
008C88  784204     MOV.B W4, W4
86:                }
008C8A  784004     MOV.B W4, W0
008C8C  FA8000     ULNK
008C8E  060000     RETURN
87:                
88:                void ClearUart1Err()
89:                {
008C90  FA0000     LNK #0x0
90:                	if(U1STAbits.OERR)
008C92  801114     MOV U1STA, W4
008C94  620262     AND W4, #0x2, W4
008C96  520FE0     SUB W4, #0x0, [W15]
008C98  320002     BRA Z, 0x8C9E
91:                	{
92:                		U1STAbits.OERR = 0;
008C9A  A92222     BCLR U1STA, #1
93:                		IFS0bits.U1RXIF = 0;
008C9C  A96085     BCLR 0x85, #3
94:                	}
95:                }
008C9E  FA8000     ULNK
008CA0  060000     RETURN
96:                
97:                void ClearUart2Err()
98:                {
008CA2  FA0000     LNK #0x0
99:                	if(U2STAbits.OERR)
008CA4  801194     MOV U2STA, W4
008CA6  620262     AND W4, #0x2, W4
008CA8  520FE0     SUB W4, #0x0, [W15]
008CAA  320002     BRA Z, 0x8CB0
100:               	{
101:               		U2STAbits.OERR = 0;
008CAC  A92232     BCLR U2STA, #1
102:               		IFS1bits.U2RXIF = 0;
008CAE  A9C087     BCLR 0x87, #6
103:               	}
104:               }
008CB0  FA8000     ULNK
008CB2  060000     RETURN
---  D:/WORK3/Lavori/TERMODINAMICA/Work/FW/1 - Generico/Split/Split v.8.4.22 - Working/Valvola_PassoPasso.c
1:                 //----------------------------------------------------------------------------------
2:                 //	Progect name:	ValvolaPassoPasso.c
3:                 //	Device:			PIC18F4550 @ 20Mhz (PLL 96 Mhz)
4:                 //	Autor:			Emanuele
5:                 //	Date:			22/05/2011
6:                 //	Description:	Corpo delle funzioni che gestiscono la valvola passo passo
7:                 //----------------------------------------------------------------------------------
8:                 
9:                 //----------------------------------------------------------------------------------
10:                //	Include
11:                //----------------------------------------------------------------------------------
12:                #include "MicroModelSelection.h"
13:                #ifdef GB210
14:                	#include <p24FJ256GB210.h>
15:                #else
16:                	#include <p24FJ256GB110.h>
17:                #endif
18:                #include <stdio.h>
19:                #include "Delay.h"
20:                #include "DefinePeriferiche.h"
21:                #include "Valvola_PassoPasso.h"
22:                #include "Core.h"
23:                
24:                //----------------------------------------------------------------------------------
25:                //	Funzioni
26:                //----------------------------------------------------------------------------------
27:                void ResetStepDriver(void)
28:                {
00892A  FA0000     LNK #0x0
29:                	oRst = 0;							// set reset to reset index
00892C  A962DC     BCLR LATD, #3
30:                	DelayuSec(20);
00892E  202800     MOV #0x280, W0
008930  200001     MOV #0x0, W1
008932  07021E     RCALL ___delay32
31:                	oRst = 1;							// normal run
008934  A862DC     BSET LATD, #3
32:                	DelayuSec(20);	
008936  202800     MOV #0x280, W0
008938  200001     MOV #0x0, W1
00893A  07021A     RCALL ___delay32
33:                }
00893C  FA8000     ULNK
00893E  060000     RETURN
34:                
35:                
36:                void Refresh_MotSt()		// aggiorno lo stato del motore
37:                {
008940  FA0002     LNK #0x2
38:                	//DEBUG
39:                	int	vFault;
40:                	
41:                	vFault = !iFault;
008942  8016D4     MOV PORTD, W4
008944  620261     AND W4, #0x1, W4
008946  A7F004     BTSC W4, #15
008948  EA0204     NEG W4, W4
00894A  E90F04     DEC W4, [W14]
00894C  78021E     MOV [W14], W4
00894E  DE224F     LSR W4, #15, W4
008950  780F04     MOV W4, [W14]
42:                	if(vFault==1)
008952  78021E     MOV [W14], W4
008954  520FE1     SUB W4, #0x1, [W15]
008956  3A0004     BRA NZ, 0x8960
43:                	{
44:                		Me.CntValveFault++;
008958  805CD4     MOV 0xB9A, W4
00895A  E80204     INC W4, W4
00895C  885CD4     MOV W4, 0xB9A
45:                		ResetStepDriver();
00895E  07FFE5     RCALL ResetStepDriver
46:                	}
47:                	//DEBUG
48:                	
49:                	oStep = 1;
008960  A8E2DC     BSET LATD, #7
50:                	DelayuSec(5);
008962  200A00     MOV #0xA0, W0
008964  200001     MOV #0x0, W1
008966  070204     RCALL ___delay32
51:                	oStep = 0;
008968  A9E2DC     BCLR LATD, #7
52:                	DelayuSec(5);
00896A  200A00     MOV #0xA0, W0
00896C  200001     MOV #0x0, W1
00896E  070200     RCALL ___delay32
53:                
54:                	if(oDir)	//OpenValve
008970  8016E5     MOV LATD, W5
008972  200404     MOV #0x40, W4
008974  628204     AND W5, W4, W4
008976  520FE0     SUB W4, #0x0, [W15]
008978  320004     BRA Z, 0x8982
55:                		Me.ExpValve_Act +=1;	//CurPosition +=1;
00897A  805CC4     MOV 0xB98, W4
00897C  E80204     INC W4, W4
00897E  885CC4     MOV W4, 0xB98
008980  370003     BRA 0x8988
56:                	else
57:                		Me.ExpValve_Act -=1;	//CurPosition -=1;
008982  805CC4     MOV 0xB98, W4
008984  E90204     DEC W4, W4
008986  885CC4     MOV W4, 0xB98
58:                	
59:                
60:                /*
61:                	oStep = !oStep;
62:                	
63:                	if(!iHome)
64:                	{	if(oDir)	//OpenValve
65:                			Me.ExpValve_Act +=1;	//CurPosition +=1;
66:                		else
67:                			Me.ExpValve_Act -=1;	//CurPosition -=1;
68:                	}	
69:                */	
70:                	
71:                }
008988  FA8000     ULNK
00898A  060000     RETURN
72:                
73:                void Free_Run(void)		// sblocco la valvola
74:                {	oEnable = 1;		// Disabilito il controller della valvola
00898C  FA0000     LNK #0x0
00898E  A8A2DC     BSET LATD, #5
75:                	oLedEEV = 1;		// Segnalo la disattivazione della valvola con il led
008990  A822EC     BSET LATF, #1
76:                }
008992  FA8000     ULNK
008994  060000     RETURN
77:                
78:                void Enable_Run(void)	// abilito la volvala al movimento
79:                {	oEnable = 0;		// Abilito il controller della valvola
008996  FA0000     LNK #0x0
008998  A9A2DC     BCLR LATD, #5
80:                	oLedEEV = 0;		// Segnalo l'attivazione della valvola con il led
00899A  A922EC     BCLR LATF, #1
81:                }
00899C  FA8000     ULNK
00899E  060000     RETURN
82:                
83:                void InitValvola()						// inizializzo la valvola
84:                {
0089A0  FA0000     LNK #0x0
85:                	StepRefreshTime = K_ValveWorkStepTime;   	
0089A2  B3C144     MOV.B #0x14, W4
0089A4  784304     MOV.B W4, W6
0089A6  20AF25     MOV #0xAF2, W5
0089A8  784A86     MOV.B W6, [W5]
86:                	ValvolaMaxStepNum = K_ValveWorkStepNumber;	
0089AA  203C04     MOV #0x3C0, W4
0089AC  8857A4     MOV W4, ValvolaMaxStepNum
87:                	
88:                	oSleep = 1;							// low power - sleep mode
0089AE  A842DC     BSET LATD, #2
89:                	DelayuSec(1);
0089B0  200200     MOV #0x20, W0
0089B2  200001     MOV #0x0, W1
0089B4  0701DD     RCALL ___delay32
90:                	Enable_Run();
0089B6  07FFEF     RCALL Enable_Run
91:                	DelayuSec(1);
0089B8  200200     MOV #0x20, W0
0089BA  200001     MOV #0x0, W1
0089BC  0701D9     RCALL ___delay32
92:                #ifdef HalfStep	
93:                	oMode0 = 1;		// 1/2 step			// 000=full step2ph; 001=1/2step; 010=1/4step
0089BE  A822D4     BSET LATC, #1
94:                #else
95:                	oMode0 = 0;		// Full step		// 000=full step2ph; 001=1/2step; 010=1/4step
96:                #endif	
97:                	oMode1 = 0;							// 011=8microstep; 100=16microstep;
0089C0  A942D4     BCLR LATC, #2
98:                	oMode2 = 0;							// 101=110=111=32microstep
0089C2  A962D4     BCLR LATC, #3
99:                	oDecay = 1;							// low=slow; high=fast; open=mixed
0089C4  A882DC     BSET LATD, #4
100:               	DelayuSec(10);
0089C6  201400     MOV #0x140, W0
0089C8  200001     MOV #0x0, W1
0089CA  0701D2     RCALL ___delay32
101:               	oRst = 0;							// set reset to reset index
0089CC  A962DC     BCLR LATD, #3
102:               	DelayuSec(20);
0089CE  202800     MOV #0x280, W0
0089D0  200001     MOV #0x0, W1
0089D2  0701CE     RCALL ___delay32
103:               	oRst = 1;							// normal run
0089D4  A862DC     BSET LATD, #3
104:               	DelayuSec(20);	
0089D6  202800     MOV #0x280, W0
0089D8  200001     MOV #0x0, W1
0089DA  0701CA     RCALL ___delay32
105:               
106:               	oDir = CloseValve;					// 1 apre; 0 chiude
0089DC  A9C2DC     BCLR LATD, #6
107:               	TimerValvola.TimeOut = 0;
0089DE  A92AF0     BCLR 0xAF0, #1
108:               	TimerValvola.Time = K_ValveResetStepTime;	//2; // inc/dec STEP valvola ogni 2mS
0089E0  2000A4     MOV #0xA, W4
0089E2  885774     MOV W4, 0xAEE
109:               	TimerValvola.Enable = 1;
0089E4  A80AF0     BSET 0xAF0, #0
110:               
111:               	Me.ExpValve_Act = K_ValveResetStepNumber; //DEBUG 240; // passi da effettuare in chiusura
0089E6  2044C4     MOV #0x44C, W4
0089E8  885CC4     MOV W4, 0xB98
112:               	while(Me.ExpValve_Act > 0)			// loop fino al termine dei cicli
0089EA  370006     BRA 0x89F8
0089F8  805CC4     MOV 0xB98, W4
0089FA  520FE0     SUB W4, #0x0, [W15]
0089FC  3CFFF7     BRA GT, 0x89EC
113:               	{
114:               		if(TimerValvola.TimeOut)		// se è scaduto il timer
0089EC  805784     MOV 0xAF0, W4
0089EE  620262     AND W4, #0x2, W4
0089F0  520FE0     SUB W4, #0x0, [W15]
0089F2  320002     BRA Z, 0x89F8
115:               		{
116:               			TimerValvola.TimeOut = 0;	// resetto il time out
0089F4  A92AF0     BCLR 0xAF0, #1
117:               			Refresh_MotSt();
0089F6  07FFA4     RCALL Refresh_MotSt
118:               		}
119:               	}
120:               	TimerValvola.Enable = 0;			// disattivo il timer
0089FE  A90AF0     BCLR 0xAF0, #0
121:               	oStep = 0;
008A00  A9E2DC     BCLR LATD, #7
122:               	Me.ExpValve_Act = 0;				//CurPosition	= 0;
008A02  EB0200     CLR W4
008A04  885CC4     MOV W4, 0xB98
123:               	Me.ExpValve_Req = 0;				//SetValue = 0;
008A06  EB0200     CLR W4
008A08  885CB4     MOV W4, 0xB96
124:               	Free_Run();
008A0A  07FFC0     RCALL Free_Run
125:               }
008A0C  FA8000     ULNK
008A0E  060000     RETURN
126:               
127:               void RefreshValue()						// aggiorna la valvola
128:               {	int Delta = 0;						// variabile con la differenza tra la posizione attuale e quella desiderata
008A10  FA0002     LNK #0x2
008A12  EB0200     CLR W4
008A14  780F04     MOV W4, [W14]
129:               
130:               	if(Me.ExpValve_Req > ValvolaMaxStepNum)		// verifico che il numero di passo richiesto sia inferiore al massimo
008A16  805CB4     MOV 0xB96, W4
008A18  780284     MOV W4, W5
008A1A  8057A4     MOV ValvolaMaxStepNum, W4
008A1C  528F84     SUB W5, W4, [W15]
008A1E  360002     BRA LEU, 0x8A24
131:               		Me.ExpValve_Req = ValvolaMaxStepNum;	// nel caso imposto il valore al massimo consentito
008A20  8057A4     MOV ValvolaMaxStepNum, W4
008A22  885CB4     MOV W4, 0xB96
132:               
133:               	if(Me.ExpValve_Req > Me.ExpValve_Act)			// se devo aprire la valvola
008A24  805CB5     MOV 0xB96, W5
008A26  805CC4     MOV 0xB98, W4
008A28  528F84     SUB W5, W4, [W15]
008A2A  340005     BRA LE, 0x8A36
134:               	{	Delta = Me.ExpValve_Req - Me.ExpValve_Act;	// mi calcolo il delta
008A2C  805CB5     MOV 0xB96, W5
008A2E  805CC4     MOV 0xB98, W4
008A30  528F04     SUB W5, W4, [W14]
135:               		oDir = OpenValve;							// setto la direzione della valvola in apertura
008A32  A8C2DC     BSET LATD, #6
008A34  370004     BRA 0x8A3E
136:               	}
137:               	else											// altrimenti se devo chiudere
138:               	{	Delta = Me.ExpValve_Act - Me.ExpValve_Req;	// mi calcolo il delta invertendo i valori
008A36  805CC5     MOV 0xB98, W5
008A38  805CB4     MOV 0xB96, W4
008A3A  528F04     SUB W5, W4, [W14]
139:               		oDir = CloseValve;							// setto la direzione della valvola in chiusura
008A3C  A9C2DC     BCLR LATD, #6
140:               	}
141:               	if(Delta > 0)
008A3E  78021E     MOV [W14], W4
008A40  520FE0     SUB W4, #0x0, [W15]
008A42  340012     BRA LE, 0x8A68
142:               	{
143:               		TimerValvola.Time = StepRefreshTime;		// imposto il timer per il movimento della valvola ogni 10 ms
008A44  20AF24     MOV #0xAF2, W4
008A46  784214     MOV.B [W4], W4
008A48  FB8204     ZE W4, W4
008A4A  885774     MOV W4, 0xAEE
144:               		TimerValvola.Enable = 1;					// attivo il timer per il movimento della valvola se serve
008A4C  A80AF0     BSET 0xAF0, #0
145:               		Enable_Run();
008A4E  07FFA3     RCALL Enable_Run
146:               		while(Me.ExpValve_Req != Me.ExpValve_Act)	// luppo fino al raggiungimento della posizione corretta
008A50  370006     BRA 0x8A5E
008A5E  805CB5     MOV 0xB96, W5
008A60  805CC4     MOV 0xB98, W4
008A62  528F84     SUB W5, W4, [W15]
008A64  3AFFF6     BRA NZ, 0x8A52
147:               		{
148:               			if(TimerValvola.TimeOut)				// attendo il time out del timer per aggirnare la posizione
008A52  805784     MOV 0xAF0, W4
008A54  620262     AND W4, #0x2, W4
008A56  520FE0     SUB W4, #0x0, [W15]
008A58  320002     BRA Z, 0x8A5E
149:               			{	TimerValvola.TimeOut = 0;			// resetto lo stato di time out
008A5A  A92AF0     BCLR 0xAF0, #1
150:               				Refresh_MotSt();					// genero l'impulso per i passi e aggiorno il ctrl
008A5C  07FF71     RCALL Refresh_MotSt
151:               			}
152:               		}
153:               		Free_Run();
008A66  07FF92     RCALL Free_Run
154:               	}
155:               	TimerValvola.Enable = 0;						// fermo il timer al termine dell'operazione
008A68  A90AF0     BCLR 0xAF0, #0
156:               }
008A6A  FA8000     ULNK
008A6C  060000     RETURN
---  D:/WORK3/Lavori/TERMODINAMICA/Work/FW/1 - Generico/Split/Split v.8.4.22 - Working/Timer.c  ---------
1:                 //----------------------------------------------------------------------------------
2:                 //	Progect name:	Timer.c
3:                 //	Device:			PIC24FJ256GB110 @ 32Mhz (FRCPLL)
4:                 //	Autor:			Emanuele
5:                 //	Date:			04/01/2014
6:                 //	Description:	Corpo delle funzioni Timer
7:                 //----------------------------------------------------------------------------------
8:                 
9:                 //----------------------------------------------------------------------------------
10:                //	Include
11:                //----------------------------------------------------------------------------------
12:                #include "MicroModelSelection.h"
13:                #ifdef GB210
14:                	#include <p24FJ256GB210.h>
15:                #else
16:                	#include <p24FJ256GB110.h>
17:                #endif
18:                #include "Timer.h"
19:                
20:                //----------------------------------------------------------------------------------
21:                //	Funzioni
22:                //----------------------------------------------------------------------------------
23:                void Config_TMR1 (unsigned char PreScaler, int TickValue)
24:                /*
25:                	(FOsc/4)	=> PreScal	=> TickValue
26:                	96Mhz		=> 16		=> 150
27:                	24Mhz		=> 1.5Mhz	=> 10Khz
28:                */
29:                {
008CB4  FA0004     LNK #0x4
008CB6  784F00     MOV.B W0, [W14]
008CB8  980711     MOV W1, [W14+2]
30:                	T1CON = 0;		// ripulisco la word di cfg
008CBA  EB0200     CLR W4
008CBC  880824     MOV W4, T1CON
31:                	switch (PreScaler)
008CBE  78429E     MOV.B [W14], W5
008CC0  FB8205     ZE W5, W4
008CC2  520FE8     SUB W4, #0x8, [W15]
008CC4  32000F     BRA Z, 0x8CE4
008CC6  520FE8     SUB W4, #0x8, [W15]
008CC8  3C0003     BRA GT, 0x8CD0
008CCA  520FE1     SUB W4, #0x1, [W15]
008CCC  320008     BRA Z, 0x8CDE
008CCE  370013     BRA 0x8CF6
008CD0  200405     MOV #0x40, W5
008CD2  520F85     SUB W4, W5, [W15]
008CD4  32000A     BRA Z, 0x8CEA
008CD6  200FF5     MOV #0xFF, W5
008CD8  520F85     SUB W4, W5, [W15]
008CDA  32000A     BRA Z, 0x8CF0
008CDC  37000C     BRA 0x8CF6
32:                	{
33:                		case 1:				// Setto la configurazione del PostScaler
34:                			T1CONbits.TCKPS0 = 0;
008CDE  A98104     BCLR T1CON, #4
35:                			T1CONbits.TCKPS1 = 0;
008CE0  A9A104     BCLR T1CON, #5
36:                			break;
008CE2  370009     BRA 0x8CF6
37:                
38:                		case 8:
39:                			T1CONbits.TCKPS0 = 1;
008CE4  A88104     BSET T1CON, #4
40:                			T1CONbits.TCKPS1 = 0;
008CE6  A9A104     BCLR T1CON, #5
41:                			break;
008CE8  370006     BRA 0x8CF6
42:                
43:                		case 64:
44:                			T1CONbits.TCKPS0 = 0;
008CEA  A98104     BCLR T1CON, #4
45:                			T1CONbits.TCKPS1 = 1;
008CEC  A8A104     BSET T1CON, #5
46:                			break;
008CEE  370003     BRA 0x8CF6
47:                
48:                		case 255:
49:                			T1CONbits.TCKPS0 = 1;
008CF0  A88104     BSET T1CON, #4
50:                			T1CONbits.TCKPS1 = 1;
008CF2  A8A104     BSET T1CON, #5
51:                			break;
008CF4  000000     NOP
52:                	}
53:                	TMR1 = 0;				// resetto il contatore
008CF6  EB0200     CLR W4
008CF8  880804     MOV W4, TMR1
54:                	PR1 = TickValue;
008CFA  90021E     MOV [W14+2], W4
008CFC  880814     MOV W4, PR1
55:                	IFS0bits.T1IF = 0;		// resetto il flag di interrupt
008CFE  A96084     BCLR IFS0, #3
56:                	IPC0bits.T1IP = 5;		// imposto la priorità dell'interrupt bassa	
008D00  800524     MOV IPC0, W4
008D02  A0C004     BSET W4, #12
008D04  A1D004     BCLR W4, #13
008D06  A0E004     BSET W4, #14
008D08  880524     MOV W4, IPC0
57:                	IEC0bits.T1IE = 1;		// abilito l'interrupt di TMR1
008D0A  A86094     BSET IEC0, #3
58:                }
008D0C  FA8000     ULNK
008D0E  060000     RETURN
59:                
60:                void Start_TMR1(void)
61:                {
008D10  FA0000     LNK #0x0
62:                	T1CONbits.TON = 1;		// attivo il timer
008D12  A8E105     BSET 0x105, #7
63:                }
008D14  FA8000     ULNK
008D16  060000     RETURN
64:                
65:                void Stop_TMR1(void)
66:                {
008D18  FA0000     LNK #0x0
67:                	T1CONbits.TON = 0;		// disattivo il timer
008D1A  A9E105     BCLR 0x105, #7
68:                	TMR1 = 0;		// resetto il conttore
008D1C  EB0200     CLR W4
008D1E  880804     MOV W4, TMR1
69:                }
008D20  FA8000     ULNK
008D22  060000     RETURN
70:                
71:                void Pasue_TMR1(void)
72:                {
008D24  FA0000     LNK #0x0
73:                	T1CONbits.TON = 0;		// disattivo il timer
008D26  A9E105     BCLR 0x105, #7
74:                }
008D28  FA8000     ULNK
008D2A  060000     RETURN
75:                
76:                void ChkTimer(TypTimer * Timer)
77:                {
008D2C  FA0002     LNK #0x2
008D2E  780F00     MOV W0, [W14]
78:                	if(Timer->Enable == 1)
008D30  78021E     MOV [W14], W4
008D32  900224     MOV [W4+4], W4
008D34  620261     AND W4, #0x1, W4
008D36  520FE0     SUB W4, #0x0, [W15]
008D38  320012     BRA Z, 0x8D5E
79:                	{
80:                		Timer->Value += 1;
008D3A  78021E     MOV [W14], W4
008D3C  780214     MOV [W4], W4
008D3E  E80284     INC W4, W5
008D40  78021E     MOV [W14], W4
008D42  780A05     MOV W5, [W4]
81:                		if ((Timer->Value) >= (Timer->Time))
008D44  78021E     MOV [W14], W4
008D46  780294     MOV [W4], W5
008D48  78021E     MOV [W14], W4
008D4A  900214     MOV [W4+2], W4
008D4C  528F84     SUB W5, W4, [W15]
008D4E  390007     BRA NC, 0x8D5E
82:                		{
83:                			Timer->TimeOut = 1;
008D50  78029E     MOV [W14], W5
008D52  900225     MOV [W5+4], W4
008D54  A01004     BSET W4, #1
008D56  9802A4     MOV W4, [W5+4]
84:                			Timer->Value = 0;
008D58  78021E     MOV [W14], W4
008D5A  EB0280     CLR W5
008D5C  780A05     MOV W5, [W4]
85:                		}
86:                	}
87:                }
008D5E  FA8000     ULNK
008D60  060000     RETURN
88:                
89:                void Init_Timer(void)
90:                {
008D62  FA0000     LNK #0x0
91:                	Config_TMR1(64, 250);	//genero una base tempo di 1ms
008D64  200FA1     MOV #0xFA, W1
008D66  B3C400     MOV.B #0x40, W0
008D68  07FFA5     RCALL Config_TMR1
92:                	Start_TMR1();
008D6A  07FFD2     RCALL Start_TMR1
93:                }
008D6C  FA8000     ULNK
008D6E  060000     RETURN
94:                
95:                /*
96:                void RefreshRTC(TypRTC * RTC)
97:                {
98:                	RTC->Secondi +=1;
99:                	if(RTC->Secondi >59)
100:               	{	RTC->Secondi  = 0;
101:               		RTC->Minuti +=1;
102:               		if(RTC->Minuti >59)
103:               		{	RTC->Minuti = 0;
104:               			RTC->Ore +=1;
105:               			if(RTC->Ore > 23)
106:               			{	RTC->Ore = 0;
107:               				RTC->GiornoSettimana +=1;
108:               				if(RTC->GiornoSettimana >6)
109:               				{	RTC->GiornoSettimana = 0;
110:               					RTC->Settimana +=1;
111:               				}
112:               				RTC->Giorno +=1;
113:               				if(RTC->Giorno >29)
114:               				{	RTC->Giorno = 0;
115:               					RTC->Mese +=1;
116:               					if(RTC->Mese >12)
117:               					{	RTC->Mese = 0;
118:               						RTC->Anno +=1;
119:               					}
120:               				}
121:               			}
122:               		}
123:               	}
124:               }
125:               */
126:               
127:               
---  D:/WORK3/Lavori/TERMODINAMICA/Work/FW/1 - Generico/Split/Split v.8.4.22 - Working/ProtocolloModBus.c
1:                 //----------------------------------------------------------------------------------
2:                 //	Progect name:	ProtocolloModBus.c
3:                 //	Device:			PIC18F4550 @ 20Mhz (PLL 96 Mhz)
4:                 //	Autor:			Emanuele
5:                 //	Date:			18/06/2011
6:                 //	Description:	Corpo delle funzioni che gestiscono la comunicazione ModBus con il sistema
7:                 //----------------------------------------------------------------------------------
8:                 
9:                 //----------------------------------------------------------------------------------
10:                //	Include
11:                //----------------------------------------------------------------------------------
12:                #include "MicroModelSelection.h"
13:                #ifdef GB210
14:                	#include <p24FJ256GB210.h>
15:                #else
16:                	#include <p24FJ256GB110.h>
17:                #endif
18:                #include <stdio.h>
19:                #include "DefinePeriferiche.h"
20:                #include "Timer.h"
21:                #include "usart.h"
22:                #include "ADC.h"
23:                #include "PWM.h"
24:                #include "EEPROM.h"
25:                #include "Valvola_PassoPasso.h"
26:                #include "Driver_Comunicazione.h"
27:                #include "Driver_ComunicazioneSec.h"
28:                #include "Driver_ModBus.h"
29:                #include "ProtocolloComunicazione.h"
30:                #include "ProtocolloComunicazioneSec.h"
31:                #include "ProtocolloModBus.h"
32:                #include "Core.h"
33:                #include "PID.h"
34:                
35:                //----------------------------------------------------------------------------------
36:                //	Funzioni
37:                //----------------------------------------------------------------------------------
38:                
39:                unsigned char WaitModRx(int TimeOut_ms)
40:                {
0012A4  FA0002     LNK #0x2
0012A6  780F00     MOV W0, [W14]
41:                	TimeOutModPktRx.Value = 0;				// resetto il timer per il time out della risposta
0012A8  EB0200     CLR W4
0012AA  8854C4     MOV W4, TimeOutModPktRx
42:                	TimeOutModPktRx.TimeOut = 0;			//
0012AC  A92A9C     BCLR 0xA9C, #1
43:                	TimeOutModPktRx.Time = TimeOut_ms;		// lo configuro come richiesto
0012AE  78021E     MOV [W14], W4
0012B0  8854D4     MOV W4, 0xA9A
44:                	TimeOutModPktRx.Enable = 1;				// lo faccio partire
0012B2  A80A9C     BSET 0xA9C, #0
45:                	while((TimeOutModPktRx.TimeOut == 0) & (Mod_LastRx.Valid_Data == 0))	// attendo un evento
0012B4  000000     NOP
0012B6  370001     BRA 0x12BA
0012BA  8054E4     MOV 0xA9C, W4
0012BC  620262     AND W4, #0x2, W4
0012BE  A7F004     BTSC W4, #15
0012C0  EA0204     NEG W4, W4
0012C2  E90204     DEC W4, W4
0012C4  DE224F     LSR W4, #15, W4
0012C6  784284     MOV.B W4, W5
0012C8  20A8E4     MOV #0xA8E, W4
0012CA  784214     MOV.B [W4], W4
0012CC  FB8204     ZE W4, W4
0012CE  E90204     DEC W4, W4
0012D0  DE224F     LSR W4, #15, W4
0012D2  784204     MOV.B W4, W4
0012D4  62C204     AND.B W5, W4, W4
0012D6  524FE0     SUB.B W4, #0x0, [W15]
0012D8  3AFFEF     BRA NZ, 0x12B8
46:                		continue;
0012B8  000000     NOP
47:                
48:                	if(Mod_LastRx.Valid_Data != 0)		// se ho ricevuto un dato valido 
0012DA  20A8E4     MOV #0xA8E, W4
0012DC  784214     MOV.B [W4], W4
0012DE  524FE0     SUB.B W4, #0x0, [W15]
0012E0  320019     BRA Z, 0x1314
49:                	{
50:                		TimeOutModPktRx.Enable = 0;			// fermo il timer
0012E2  A90A9C     BCLR 0xA9C, #0
51:                		TimeOutModPktRx.TimeOut = 0;		// resetto il time out
0012E4  A92A9C     BCLR 0xA9C, #1
52:                		if( (Mod_LastRx.Buffer[0] == Mod_BufferTx.Buffer[0]) &	// verifico il pacchetto
0012E6  20A3A5     MOV #0xA3A, W5
0012E8  784295     MOV.B [W5], W5
0012EA  209E44     MOV #0x9E4, W4
0012EC  784214     MOV.B [W4], W4
0012EE  6AC284     XOR.B W5, W4, W5
0012F0  FB8205     ZE W5, W4
0012F2  E90204     DEC W4, W4
0012F4  DE224F     LSR W4, #15, W4
0012F6  784284     MOV.B W4, W5
00130A  62C204     AND.B W5, W4, W4
00130C  524FE0     SUB.B W4, #0x0, [W15]
00130E  320002     BRA Z, 0x1314
53:                			(Mod_LastRx.Buffer[1] == Mod_BufferTx.Buffer[1]))
0012F8  20A3B6     MOV #0xA3B, W6
0012FA  784316     MOV.B [W6], W6
0012FC  209E54     MOV #0x9E5, W4
0012FE  784214     MOV.B [W4], W4
001300  6B4204     XOR.B W6, W4, W4
001302  FB8204     ZE W4, W4
001304  E90204     DEC W4, W4
001306  DE224F     LSR W4, #15, W4
001308  784204     MOV.B W4, W4
54:                			return 0;											// ritorno 0 se è ok
001310  EB4200     CLR.B W4
001312  370003     BRA 0x131A
55:                	}									// in caso contrario
56:                	TimeOutModPktRx.Enable = 0;			// fermo il timer
001314  A90A9C     BCLR 0xA9C, #0
57:                	TimeOutModPktRx.TimeOut = 0;		// resetto il time out
001316  A92A9C     BCLR 0xA9C, #1
58:                	return 1;							// ritorno 1
001318  B3C014     MOV.B #0x1, W4
59:                }
00131A  784004     MOV.B W4, W0
00131C  FA8000     ULNK
00131E  060000     RETURN
60:                
61:                unsigned char Send_WaitModRx(char Address, char Comando, int Registro, int Data, int TimeOut_ms, char Retry)
62:                {
001320  FA000A     LNK #0xA
001322  784F00     MOV.B W0, [W14]
001324  984711     MOV.B W1, [W14+1]
001326  980712     MOV W2, [W14+2]
001328  980723     MOV W3, [W14+4]
00132A  980734     MOV W4, [W14+6]
00132C  984F05     MOV.B W5, [W14+8]
63:                	Result = 0;
00132E  EB4200     CLR.B W4
001330  784304     MOV.B W4, W6
001332  20A9E5     MOV #0xA9E, W5
001334  784A86     MOV.B W6, [W5]
64:                	RetryCnt = 0;
001336  EB4200     CLR.B W4
001338  784304     MOV.B W4, W6
00133A  20A9F5     MOV #0xA9F, W5
00133C  784A86     MOV.B W6, [W5]
65:                	while (RetryCnt < Retry)
00133E  370019     BRA 0x1372
001372  20A9F5     MOV #0xA9F, W5
001374  784295     MOV.B [W5], W5
001376  904A0E     MOV.B [W14+8], W4
001378  52CF84     SUB.B W5, W4, [W15]
00137A  35FFE2     BRA LT, 0x1340
66:                	{	
67:                		RetryCnt +=1;
001340  20A9F4     MOV #0xA9F, W4
001342  784214     MOV.B [W4], W4
001344  E84204     INC.B W4, W4
001346  784304     MOV.B W4, W6
001348  20A9F5     MOV #0xA9F, W5
00134A  784A86     MOV.B W6, [W5]
68:                		Mod_Write_Cmd(Address, Comando, Registro -1, Data);
00134C  90021E     MOV [W14+2], W4
00134E  E90204     DEC W4, W4
001350  9001AE     MOV [W14+4], W3
001352  780104     MOV W4, W2
001354  90409E     MOV.B [W14+1], W1
001356  78401E     MOV.B [W14], W0
001358  072FB4     RCALL Mod_Write_Cmd
69:                		Result = WaitModRx(TimeOut_ms);
00135A  90003E     MOV [W14+6], W0
00135C  07FFA3     RCALL WaitModRx
00135E  784200     MOV.B W0, W4
001360  784304     MOV.B W4, W6
001362  20A9E5     MOV #0xA9E, W5
001364  784A86     MOV.B W6, [W5]
70:                		if (Result == 0)
001366  20A9E4     MOV #0xA9E, W4
001368  784214     MOV.B [W4], W4
00136A  524FE0     SUB.B W4, #0x0, [W15]
00136C  3A0002     BRA NZ, 0x1372
71:                			return 0;		// se ricevo un pacchetto valido 
00136E  EB4200     CLR.B W4
001370  370006     BRA 0x137E
72:                	}
73:                	return 1;				// se non ho nessuna risposta valida per dopo il numero di tentativi richiesti
00137C  B3C014     MOV.B #0x1, W4
74:                }
00137E  784004     MOV.B W4, W0
001380  FA8000     ULNK
001382  060000     RETURN
75:                
76:                unsigned char Send_WriteModReg(char Address, int Registro, int Data, int TimeOut_ms, char Retry, char Cmd)
77:                {
001384  FA000A     LNK #0xA
001386  784F00     MOV.B W0, [W14]
001388  980711     MOV W1, [W14+2]
00138A  980722     MOV W2, [W14+4]
00138C  980733     MOV W3, [W14+6]
00138E  984F04     MOV.B W4, [W14+8]
001390  984F15     MOV.B W5, [W14+9]
78:                	Result = 1;
001392  B3C014     MOV.B #0x1, W4
001394  784304     MOV.B W4, W6
001396  20A9E5     MOV #0xA9E, W5
001398  784A86     MOV.B W6, [W5]
79:                	RetryCnt = 0;
00139A  EB4200     CLR.B W4
00139C  784304     MOV.B W4, W6
00139E  20A9F5     MOV #0xA9F, W5
0013A0  784A86     MOV.B W6, [W5]
80:                	while (RetryCnt < Retry)
0013A2  370047     BRA 0x1432
001432  20A9F5     MOV #0xA9F, W5
001434  784295     MOV.B [W5], W5
001436  904A0E     MOV.B [W14+8], W4
001438  52CF84     SUB.B W5, W4, [W15]
00143A  35FFB4     BRA LT, 0x13A4
81:                	{
82:                		RetryCnt +=1;
0013A4  20A9F4     MOV #0xA9F, W4
0013A6  784214     MOV.B [W4], W4
0013A8  E84204     INC.B W4, W4
0013AA  784304     MOV.B W4, W6
0013AC  20A9F5     MOV #0xA9F, W5
0013AE  784A86     MOV.B W6, [W5]
83:                		Mod_Write_Cmd(Address, Cmd, Registro -1, Data);
0013B0  90021E     MOV [W14+2], W4
0013B2  E90204     DEC W4, W4
0013B4  9001AE     MOV [W14+4], W3
0013B6  780104     MOV W4, W2
0013B8  90489E     MOV.B [W14+9], W1
0013BA  78401E     MOV.B [W14], W0
0013BC  072F82     RCALL Mod_Write_Cmd
84:                		Result = WaitModRx(TimeOut_ms);
0013BE  90003E     MOV [W14+6], W0
0013C0  07FF71     RCALL WaitModRx
0013C2  784200     MOV.B W0, W4
0013C4  784304     MOV.B W4, W6
0013C6  20A9E5     MOV #0xA9E, W5
0013C8  784A86     MOV.B W6, [W5]
85:                		if ((Result == 0) &
0013CA  20A9E4     MOV #0xA9E, W4
0013CC  784214     MOV.B [W4], W4
0013CE  FB8204     ZE W4, W4
0013D0  E90204     DEC W4, W4
0013D2  DE224F     LSR W4, #15, W4
0013D4  784284     MOV.B W4, W5
0013E8  62C204     AND.B W5, W4, W4
0013EA  FB8284     ZE W4, W5
001422  520FE0     SUB W4, #0x0, [W15]
001424  320006     BRA Z, 0x1432
86:                			(Mod_LastRx.Buffer[2] == Mod_BufferTx.Buffer[2]) &
0013D6  20A3C6     MOV #0xA3C, W6
0013D8  784316     MOV.B [W6], W6
0013DA  209E64     MOV #0x9E6, W4
0013DC  784214     MOV.B [W4], W4
0013DE  6B4204     XOR.B W6, W4, W4
0013E0  FB8204     ZE W4, W4
0013E2  E90204     DEC W4, W4
0013E4  DE224F     LSR W4, #15, W4
0013E6  784204     MOV.B W4, W4
0013FC  628284     AND W5, W4, W5
87:                			(Mod_LastRx.Buffer[3] == Mod_BufferTx.Buffer[3]) &
0013EC  20A3D6     MOV #0xA3D, W6
0013EE  784316     MOV.B [W6], W6
0013F0  209E74     MOV #0x9E7, W4
0013F2  784214     MOV.B [W4], W4
0013F4  6B4204     XOR.B W6, W4, W4
0013F6  FB8204     ZE W4, W4
0013F8  E90204     DEC W4, W4
0013FA  DE224F     LSR W4, #15, W4
00140E  628284     AND W5, W4, W5
88:                			(Mod_LastRx.Buffer[4] == Mod_BufferTx.Buffer[4]) &
0013FE  20A3E6     MOV #0xA3E, W6
001400  784316     MOV.B [W6], W6
001402  209E84     MOV #0x9E8, W4
001404  784214     MOV.B [W4], W4
001406  6B4204     XOR.B W6, W4, W4
001408  FB8204     ZE W4, W4
00140A  E90204     DEC W4, W4
00140C  DE224F     LSR W4, #15, W4
001420  628204     AND W5, W4, W4
89:                			(Mod_LastRx.Buffer[5] == Mod_BufferTx.Buffer[5])  )
001410  20A3F6     MOV #0xA3F, W6
001412  784316     MOV.B [W6], W6
001414  209E94     MOV #0x9E9, W4
001416  784214     MOV.B [W4], W4
001418  6B4204     XOR.B W6, W4, W4
00141A  FB8204     ZE W4, W4
00141C  E90204     DEC W4, W4
00141E  DE224F     LSR W4, #15, W4
90:                		{
91:                			Mod_LastRx.Valid_Data = 0;
001426  EB4200     CLR.B W4
001428  784304     MOV.B W4, W6
00142A  20A8E5     MOV #0xA8E, W5
00142C  784A86     MOV.B W6, [W5]
92:                			return 0;
00142E  EB4200     CLR.B W4
001430  37000A     BRA 0x1446
93:                		}
94:                	}
95:                	Mod_LastRx.Valid_Data = 0;
00143C  EB4200     CLR.B W4
00143E  784304     MOV.B W4, W6
001440  20A8E5     MOV #0xA8E, W5
001442  784A86     MOV.B W6, [W5]
96:                	return 1;
001444  B3C014     MOV.B #0x1, W4
97:                }
001446  784004     MOV.B W4, W0
001448  FA8000     ULNK
00144A  060000     RETURN
98:                
99:                
100:               //-----------------------------------------------------------------
101:               // Funzioni solo per Touch
102:               //-----------------------------------------------------------------
103:               void ReadModReg (char Address, int REG, int * StoreReg)
104:               {
00144C  FA0008     LNK #0x8
00144E  984720     MOV.B W0, [W14+2]
001450  980721     MOV W1, [W14+4]
001452  980732     MOV W2, [W14+6]
105:               	char Result;
106:               	if(!Touch[Address-Add_TouchRoom].OffLine)
001454  90422E     MOV.B [W14+2], W4
001456  FB0204     SE W4, W4
001458  E90204     DEC W4, W4
00145A  B92278     MUL.SU W4, #24, W4
00145C  780204     MOV W4, W4
00145E  4202F6     ADD W4, #0x16, W5
001460  20BAE4     MOV #0xBAE, W4
001462  428204     ADD W5, W4, W4
001464  780214     MOV [W4], W4
001466  D10204     LSR W4, W4
001468  624261     AND.B W4, #0x1, W4
00146A  524FE0     SUB.B W4, #0x0, [W15]
00146C  3A001E     BRA NZ, 0x14AA
107:               	{
108:               		Result = Send_WaitModRx(Address, ReadModCmd, REG, 1, MaxModReadWait, MaxModReadRetries);
00146E  B3C025     MOV.B #0x2, W5
001470  200324     MOV #0x32, W4
001472  200013     MOV #0x1, W3
001474  90012E     MOV [W14+4], W2
001476  B3C031     MOV.B #0x3, W1
001478  90402E     MOV.B [W14+2], W0
00147A  07FF52     RCALL Send_WaitModRx
00147C  784200     MOV.B W0, W4
00147E  784F04     MOV.B W4, [W14]
109:               		if(Result == 0)	// Il registro dei touch hanno un offset di 1
001480  78421E     MOV.B [W14], W4
001482  524FE0     SUB.B W4, #0x0, [W15]
001484  3A0008     BRA NZ, 0x1496
110:               		{
111:               			(*StoreReg) = Mod_LastRx.Data;
001486  805465     MOV 0xA8C, W5
001488  90023E     MOV [W14+6], W4
00148A  780A05     MOV W5, [W4]
112:               			Mod_LastRx.Valid_Data = 0;
00148C  EB4200     CLR.B W4
00148E  784304     MOV.B W4, W6
001490  20A8E5     MOV #0xA8E, W5
001492  784A86     MOV.B W6, [W5]
001494  37000A     BRA 0x14AA
113:               		}
114:               		else
115:               		{
116:               			Touch[Address-Add_TouchRoom].OffLine = 1;
001496  90422E     MOV.B [W14+2], W4
001498  FB0204     SE W4, W4
00149A  E90204     DEC W4, W4
00149C  B92278     MUL.SU W4, #24, W4
00149E  780284     MOV W4, W5
0014A0  20BC44     MOV #0xBC4, W4
0014A2  428284     ADD W5, W4, W5
0014A4  780215     MOV [W5], W4
0014A6  A01004     BSET W4, #1
0014A8  780A84     MOV W4, [W5]
117:               		}
118:               	}
119:               }
0014AA  FA8000     ULNK
0014AC  060000     RETURN
120:               
121:               unsigned char ReadModListReg (char DataIndex, int REG, int RegNum)
122:               {
0014AE  FA0008     LNK #0x8
0014B0  984720     MOV.B W0, [W14+2]
0014B2  980721     MOV W1, [W14+4]
0014B4  980732     MOV W2, [W14+6]
123:               	char TouchAddres;
124:               	TouchAddres = DataIndex+Add_TouchRoom;
0014B6  90422E     MOV.B [W14+2], W4
0014B8  E84204     INC.B W4, W4
0014BA  784F04     MOV.B W4, [W14]
125:               	if(!Touch[DataIndex].OffLine)
0014BC  90422E     MOV.B [W14+2], W4
0014BE  FB0204     SE W4, W4
0014C0  B92278     MUL.SU W4, #24, W4
0014C2  780204     MOV W4, W4
0014C4  4202F6     ADD W4, #0x16, W5
0014C6  20BAE4     MOV #0xBAE, W4
0014C8  428204     ADD W5, W4, W4
0014CA  780214     MOV [W4], W4
0014CC  D10204     LSR W4, W4
0014CE  624261     AND.B W4, #0x1, W4
0014D0  524FE0     SUB.B W4, #0x0, [W15]
0014D2  3A001F     BRA NZ, 0x1512
126:               	{
127:               		if(Send_WaitModRx(TouchAddres, ReadModCmd, REG, RegNum, MaxModReadWait, MaxModReadRetries))	// Il registro dei touch hanno un offset di 1
0014D4  B3C025     MOV.B #0x2, W5
0014D6  200324     MOV #0x32, W4
0014D8  9001BE     MOV [W14+6], W3
0014DA  90012E     MOV [W14+4], W2
0014DC  B3C031     MOV.B #0x3, W1
0014DE  78401E     MOV.B [W14], W0
0014E0  07FF1F     RCALL Send_WaitModRx
0014E2  784200     MOV.B W0, W4
0014E4  524FE0     SUB.B W4, #0x0, [W15]
0014E6  32000F     BRA Z, 0x1506
128:               		{
129:               			Touch[DataIndex].OffLine = 1;
0014E8  90422E     MOV.B [W14+2], W4
0014EA  FB0204     SE W4, W4
0014EC  B92278     MUL.SU W4, #24, W4
0014EE  780284     MOV W4, W5
0014F0  20BC44     MOV #0xBC4, W4
0014F2  428284     ADD W5, W4, W5
0014F4  780215     MOV [W5], W4
0014F6  A01004     BSET W4, #1
0014F8  780A84     MOV W4, [W5]
130:               			Mod_LastRx.Valid_Data = 0;
0014FA  EB4200     CLR.B W4
0014FC  784304     MOV.B W4, W6
0014FE  20A8E5     MOV #0xA8E, W5
001500  784A86     MOV.B W6, [W5]
131:               			return 1;
001502  B3C014     MOV.B #0x1, W4
001504  370007     BRA 0x1514
132:               		}
133:               		else
134:               		{
135:               			Mod_LastRx.Valid_Data = 0;
001506  EB4200     CLR.B W4
001508  784304     MOV.B W4, W6
00150A  20A8E5     MOV #0xA8E, W5
00150C  784A86     MOV.B W6, [W5]
136:               			return 0;
00150E  EB4200     CLR.B W4
001510  370001     BRA 0x1514
137:               		}
138:               	}
139:               	return 1;
001512  B3C014     MOV.B #0x1, W4
140:               }
001514  784004     MOV.B W4, W0
001516  FA8000     ULNK
001518  060000     RETURN
141:               
142:               void WriteModReg (char Address, int REG, int SendData)
143:               {
00151A  FA0006     LNK #0x6
00151C  781F88     MOV W8, [W15++]
00151E  784F00     MOV.B W0, [W14]
001520  980711     MOV W1, [W14+2]
001522  980722     MOV W2, [W14+4]
144:               	if(!Touch[Address-Add_TouchRoom].OffLine)
001524  FB021E     SE [W14], W4
001526  E90204     DEC W4, W4
001528  B92278     MUL.SU W4, #24, W4
00152A  780204     MOV W4, W4
00152C  4202F6     ADD W4, #0x16, W5
00152E  20BAE4     MOV #0xBAE, W4
001530  428204     ADD W5, W4, W4
001532  780214     MOV [W4], W4
001534  D10204     LSR W4, W4
001536  624261     AND.B W4, #0x1, W4
001538  524FE0     SUB.B W4, #0x0, [W15]
00153A  3A0017     BRA NZ, 0x156A
145:               	{
146:               		Touch[Address-Add_TouchRoom].OffLine = Send_WriteModReg(Address, REG, SendData, MaxModWriteWait, MaxModWriteRetries, WriteModCmd);	// Il registro dei touch hanno un offset di 1
00153C  FB021E     SE [W14], W4
00153E  E90404     DEC W4, W8
001540  B3C065     MOV.B #0x6, W5
001542  B3C024     MOV.B #0x2, W4
001544  200323     MOV #0x32, W3
001546  90012E     MOV [W14+4], W2
001548  90009E     MOV [W14+2], W1
00154A  78401E     MOV.B [W14], W0
00154C  07FF1B     RCALL Send_WriteModReg
00154E  784200     MOV.B W0, W4
001550  624361     AND.B W4, #0x1, W6
001552  B94278     MUL.SU W8, #24, W4
001554  780284     MOV W4, W5
001556  20BC44     MOV #0xBC4, W4
001558  428204     ADD W5, W4, W4
00155A  FB8286     ZE W6, W5
00155C  6282E1     AND W5, #0x1, W5
00155E  428285     ADD W5, W5, W5
001560  780394     MOV [W4], W7
001562  2FFFD6     MOV #0xFFFD, W6
001564  638306     AND W7, W6, W6
001566  728286     IOR W5, W6, W5
001568  780A05     MOV W5, [W4]
147:               	}
148:               }
00156A  78044F     MOV [--W15], W8
00156C  FA8000     ULNK
00156E  060000     RETURN
149:               
150:               void WriteModListReg (char Address, int REG, int SendData)
151:               {
001570  FA0006     LNK #0x6
001572  781F88     MOV W8, [W15++]
001574  784F00     MOV.B W0, [W14]
001576  980711     MOV W1, [W14+2]
001578  980722     MOV W2, [W14+4]
152:               	if(!Touch[Address-Add_TouchRoom].OffLine)
00157A  FB021E     SE [W14], W4
00157C  E90204     DEC W4, W4
00157E  B92278     MUL.SU W4, #24, W4
001580  780204     MOV W4, W4
001582  4202F6     ADD W4, #0x16, W5
001584  20BAE4     MOV #0xBAE, W4
001586  428204     ADD W5, W4, W4
001588  780214     MOV [W4], W4
00158A  D10204     LSR W4, W4
00158C  624261     AND.B W4, #0x1, W4
00158E  524FE0     SUB.B W4, #0x0, [W15]
001590  3A0017     BRA NZ, 0x15C0
153:               	{
154:               		Touch[Address-Add_TouchRoom].OffLine = Send_WriteModReg(Address, REG, SendData, MaxModWriteWait, MaxModWriteRetries, WriteModListCmd);	// Il registro dei touch hanno un offset di 1
001592  FB021E     SE [W14], W4
001594  E90404     DEC W4, W8
001596  B3C105     MOV.B #0x10, W5
001598  B3C024     MOV.B #0x2, W4
00159A  200323     MOV #0x32, W3
00159C  90012E     MOV [W14+4], W2
00159E  90009E     MOV [W14+2], W1
0015A0  78401E     MOV.B [W14], W0
0015A2  07FEF0     RCALL Send_WriteModReg
0015A4  784200     MOV.B W0, W4
0015A6  624361     AND.B W4, #0x1, W6
0015A8  B94278     MUL.SU W8, #24, W4
0015AA  780284     MOV W4, W5
0015AC  20BC44     MOV #0xBC4, W4
0015AE  428204     ADD W5, W4, W4
0015B0  FB8286     ZE W6, W5
0015B2  6282E1     AND W5, #0x1, W5
0015B4  428285     ADD W5, W5, W5
0015B6  780394     MOV [W4], W7
0015B8  2FFFD6     MOV #0xFFFD, W6
0015BA  638306     AND W7, W6, W6
0015BC  728286     IOR W5, W6, W5
0015BE  780A05     MOV W5, [W4]
155:               	}
156:               }
0015C0  78044F     MOV [--W15], W8
0015C2  FA8000     ULNK
0015C4  060000     RETURN
157:               
158:               
159:               
160:               //-----------------------------------------------------------------
161:               // Funzioni solo per Panel
162:               //-----------------------------------------------------------------
163:               void ReadModRegPanel (char Address, int REG, int * StoreReg)
164:               {
0015C6  FA0008     LNK #0x8
0015C8  984720     MOV.B W0, [W14+2]
0015CA  980721     MOV W1, [W14+4]
0015CC  980732     MOV W2, [W14+6]
165:               	char Result;
166:               	if(!Panel[Address-Add_PanelRoom].OffLine)
0015CE  90422E     MOV.B [W14+2], W4
0015D0  FB0204     SE W4, W4
0015D2  52027E     SUB W4, #0x1E, W4
0015D4  B9226C     MUL.SU W4, #12, W4
0015D6  780204     MOV W4, W4
0015D8  4202EA     ADD W4, #0xA, W5
0015DA  20C0E4     MOV #0xC0E, W4
0015DC  428204     ADD W5, W4, W4
0015DE  780214     MOV [W4], W4
0015E0  D10204     LSR W4, W4
0015E2  624261     AND.B W4, #0x1, W4
0015E4  524FE0     SUB.B W4, #0x0, [W15]
0015E6  3A001E     BRA NZ, 0x1624
167:               	{
168:               		Result = Send_WaitModRx(Address, ReadModCmd, REG, 1, MaxModReadWait, MaxModReadRetries);
0015E8  B3C025     MOV.B #0x2, W5
0015EA  200324     MOV #0x32, W4
0015EC  200013     MOV #0x1, W3
0015EE  90012E     MOV [W14+4], W2
0015F0  B3C031     MOV.B #0x3, W1
0015F2  90402E     MOV.B [W14+2], W0
0015F4  07FE95     RCALL Send_WaitModRx
0015F6  784200     MOV.B W0, W4
0015F8  784F04     MOV.B W4, [W14]
169:               		if(Result == 0)	// Il registro dei touch hanno un offset di 1
0015FA  78421E     MOV.B [W14], W4
0015FC  524FE0     SUB.B W4, #0x0, [W15]
0015FE  3A0008     BRA NZ, 0x1610
170:               		{
171:               			(*StoreReg) = Mod_LastRx.Data;
001600  805465     MOV 0xA8C, W5
001602  90023E     MOV [W14+6], W4
001604  780A05     MOV W5, [W4]
172:               			Mod_LastRx.Valid_Data = 0;
001606  EB4200     CLR.B W4
001608  784304     MOV.B W4, W6
00160A  20A8E5     MOV #0xA8E, W5
00160C  784A86     MOV.B W6, [W5]
00160E  37000A     BRA 0x1624
173:               		}
174:               		else
175:               		{
176:               			Panel[Address-Add_PanelRoom].OffLine = 1;
001610  90422E     MOV.B [W14+2], W4
001612  FB0204     SE W4, W4
001614  52027E     SUB W4, #0x1E, W4
001616  B9226C     MUL.SU W4, #12, W4
001618  780284     MOV W4, W5
00161A  20C184     MOV #0xC18, W4
00161C  428284     ADD W5, W4, W5
00161E  780215     MOV [W5], W4
001620  A01004     BSET W4, #1
001622  780A84     MOV W4, [W5]
177:               		}
178:               	}
179:               }
001624  FA8000     ULNK
001626  060000     RETURN
180:               
181:               unsigned char ReadModListRegPanel (char DataIndex, int REG, int RegNum)
182:               {
001628  FA0008     LNK #0x8
00162A  984720     MOV.B W0, [W14+2]
00162C  980721     MOV W1, [W14+4]
00162E  980732     MOV W2, [W14+6]
183:               	char PanelAddres;
184:               	PanelAddres = DataIndex+Add_PanelRoom;
001630  90422E     MOV.B [W14+2], W4
001632  42427E     ADD.B W4, #0x1E, W4
001634  784F04     MOV.B W4, [W14]
185:               	if(!Panel[DataIndex].OffLine)
001636  90422E     MOV.B [W14+2], W4
001638  FB0204     SE W4, W4
00163A  B9226C     MUL.SU W4, #12, W4
00163C  780204     MOV W4, W4
00163E  4202EA     ADD W4, #0xA, W5
001640  20C0E4     MOV #0xC0E, W4
001642  428204     ADD W5, W4, W4
001644  780214     MOV [W4], W4
001646  D10204     LSR W4, W4
001648  624261     AND.B W4, #0x1, W4
00164A  524FE0     SUB.B W4, #0x0, [W15]
00164C  3A001F     BRA NZ, 0x168C
186:               	{
187:               		if(Send_WaitModRx(PanelAddres, ReadModCmd, REG, RegNum, MaxModReadWait, MaxModReadRetries))	// Il registro dei touch hanno un offset di 1
00164E  B3C025     MOV.B #0x2, W5
001650  200324     MOV #0x32, W4
001652  9001BE     MOV [W14+6], W3
001654  90012E     MOV [W14+4], W2
001656  B3C031     MOV.B #0x3, W1
001658  78401E     MOV.B [W14], W0
00165A  07FE62     RCALL Send_WaitModRx
00165C  784200     MOV.B W0, W4
00165E  524FE0     SUB.B W4, #0x0, [W15]
001660  32000F     BRA Z, 0x1680
188:               		{
189:               			Panel[DataIndex].OffLine = 1;
001662  90422E     MOV.B [W14+2], W4
001664  FB0204     SE W4, W4
001666  B9226C     MUL.SU W4, #12, W4
001668  780284     MOV W4, W5
00166A  20C184     MOV #0xC18, W4
00166C  428284     ADD W5, W4, W5
00166E  780215     MOV [W5], W4
001670  A01004     BSET W4, #1
001672  780A84     MOV W4, [W5]
190:               			Mod_LastRx.Valid_Data = 0;
001674  EB4200     CLR.B W4
001676  784304     MOV.B W4, W6
001678  20A8E5     MOV #0xA8E, W5
00167A  784A86     MOV.B W6, [W5]
191:               			return 1;
00167C  B3C014     MOV.B #0x1, W4
00167E  370007     BRA 0x168E
192:               		}
193:               		else
194:               		{
195:               			Mod_LastRx.Valid_Data = 0;
001680  EB4200     CLR.B W4
001682  784304     MOV.B W4, W6
001684  20A8E5     MOV #0xA8E, W5
001686  784A86     MOV.B W6, [W5]
196:               			return 0;
001688  EB4200     CLR.B W4
00168A  370001     BRA 0x168E
197:               		}
198:               	}
199:               	return 1;
00168C  B3C014     MOV.B #0x1, W4
200:               }
00168E  784004     MOV.B W4, W0
001690  FA8000     ULNK
001692  060000     RETURN
201:               
202:               void WriteModRegPanel (char Address, int REG, int SendData)
203:               {
001694  FA0006     LNK #0x6
001696  781F88     MOV W8, [W15++]
001698  784F00     MOV.B W0, [W14]
00169A  980711     MOV W1, [W14+2]
00169C  980722     MOV W2, [W14+4]
204:               	if(!Panel[Address-Add_PanelRoom].OffLine)
00169E  FB021E     SE [W14], W4
0016A0  52027E     SUB W4, #0x1E, W4
0016A2  B9226C     MUL.SU W4, #12, W4
0016A4  780204     MOV W4, W4
0016A6  4202EA     ADD W4, #0xA, W5
0016A8  20C0E4     MOV #0xC0E, W4
0016AA  428204     ADD W5, W4, W4
0016AC  780214     MOV [W4], W4
0016AE  D10204     LSR W4, W4
0016B0  624261     AND.B W4, #0x1, W4
0016B2  524FE0     SUB.B W4, #0x0, [W15]
0016B4  3A0017     BRA NZ, 0x16E4
205:               	{
206:               		Panel[Address-Add_PanelRoom].OffLine = Send_WriteModReg(Address, REG, SendData, MaxModWriteWait, MaxModWriteRetries, WriteModCmd);	// Il registro dei touch hanno un offset di 1
0016B6  FB021E     SE [W14], W4
0016B8  52047E     SUB W4, #0x1E, W8
0016BA  B3C065     MOV.B #0x6, W5
0016BC  B3C024     MOV.B #0x2, W4
0016BE  200323     MOV #0x32, W3
0016C0  90012E     MOV [W14+4], W2
0016C2  90009E     MOV [W14+2], W1
0016C4  78401E     MOV.B [W14], W0
0016C6  07FE5E     RCALL Send_WriteModReg
0016C8  784200     MOV.B W0, W4
0016CA  624361     AND.B W4, #0x1, W6
0016CC  B9426C     MUL.SU W8, #12, W4
0016CE  780284     MOV W4, W5
0016D0  20C184     MOV #0xC18, W4
0016D2  428204     ADD W5, W4, W4
0016D4  FB8286     ZE W6, W5
0016D6  6282E1     AND W5, #0x1, W5
0016D8  428285     ADD W5, W5, W5
0016DA  780394     MOV [W4], W7
0016DC  2FFFD6     MOV #0xFFFD, W6
0016DE  638306     AND W7, W6, W6
0016E0  728286     IOR W5, W6, W5
0016E2  780A05     MOV W5, [W4]
207:               	}
208:               }
0016E4  78044F     MOV [--W15], W8
0016E6  FA8000     ULNK
0016E8  060000     RETURN
209:               
210:               void WriteModListRegPanel (char Address, int REG, int SendData)
211:               {
0016EA  FA0006     LNK #0x6
0016EC  781F88     MOV W8, [W15++]
0016EE  784F00     MOV.B W0, [W14]
0016F0  980711     MOV W1, [W14+2]
0016F2  980722     MOV W2, [W14+4]
212:               	if(!Panel[Address-Add_PanelRoom].OffLine)
0016F4  FB021E     SE [W14], W4
0016F6  52027E     SUB W4, #0x1E, W4
0016F8  B9226C     MUL.SU W4, #12, W4
0016FA  780204     MOV W4, W4
0016FC  4202EA     ADD W4, #0xA, W5
0016FE  20C0E4     MOV #0xC0E, W4
001700  428204     ADD W5, W4, W4
001702  780214     MOV [W4], W4
001704  D10204     LSR W4, W4
001706  624261     AND.B W4, #0x1, W4
001708  524FE0     SUB.B W4, #0x0, [W15]
00170A  3A0017     BRA NZ, 0x173A
213:               	{
214:               		Panel[Address-Add_PanelRoom].OffLine = Send_WriteModReg(Address, REG, SendData, MaxModWriteWait, MaxModWriteRetries, WriteModListCmd);	// Il registro dei touch hanno un offset di 1
00170C  FB021E     SE [W14], W4
00170E  52047E     SUB W4, #0x1E, W8
001710  B3C105     MOV.B #0x10, W5
001712  B3C024     MOV.B #0x2, W4
001714  200323     MOV #0x32, W3
001716  90012E     MOV [W14+4], W2
001718  90009E     MOV [W14+2], W1
00171A  78401E     MOV.B [W14], W0
00171C  07FE33     RCALL Send_WriteModReg
00171E  784200     MOV.B W0, W4
001720  624361     AND.B W4, #0x1, W6
001722  B9426C     MUL.SU W8, #12, W4
001724  780284     MOV W4, W5
001726  20C184     MOV #0xC18, W4
001728  428204     ADD W5, W4, W4
00172A  FB8286     ZE W6, W5
00172C  6282E1     AND W5, #0x1, W5
00172E  428285     ADD W5, W5, W5
001730  780394     MOV [W4], W7
001732  2FFFD6     MOV #0xFFFD, W6
001734  638306     AND W7, W6, W6
001736  728286     IOR W5, W6, W5
001738  780A05     MOV W5, [W4]
215:               	}
216:               }
00173A  78044F     MOV [--W15], W8
00173C  FA8000     ULNK
00173E  060000     RETURN
217:               
218:               
219:               
220:               
221:               
222:               
223:               int ExtracReg(char NumReg)
224:               {
001740  FA0002     LNK #0x2
001742  784F00     MOV.B W0, [W14]
225:               	// recupero un valore int dalla coda del buffer l'indice dei registri va da 1 al limite della richiesta
226:               	Indice = 0;
001744  EB4200     CLR.B W4
001746  784304     MOV.B W4, W6
001748  20AA05     MOV #0xAA0, W5
00174A  784A86     MOV.B W6, [W5]
227:               	Data = 0;
00174C  EB0200     CLR W4
00174E  885514     MOV W4, Data
228:               
229:               	Indice = 1+(NumReg*2);
001750  78421E     MOV.B [W14], W4
001752  424204     ADD.B W4, W4, W4
001754  E84204     INC.B W4, W4
001756  784304     MOV.B W4, W6
001758  20AA05     MOV #0xAA0, W5
00175A  784A86     MOV.B W6, [W5]
230:               	/////Data = Mod_LastRx.Buffer[Indice]<<8;
231:               	Data = ((Mod_LastRx.Buffer[Indice]<<8)&0xFF00);	// Modifica 05/01/2015 Aggiunta mascheratura byte shift
00175C  20AA04     MOV #0xAA0, W4
00175E  784214     MOV.B [W4], W4
001760  FB0284     SE W4, W5
001762  20A3A4     MOV #0xA3A, W4
001764  428204     ADD W5, W4, W4
001766  784214     MOV.B [W4], W4
001768  FB0204     SE W4, W4
00176A  DD2248     SL W4, #8, W4
00176C  885514     MOV W4, Data
232:               	Data |= (Mod_LastRx.Buffer[Indice+1]&0x00FF);
00176E  20AA04     MOV #0xAA0, W4
001770  784214     MOV.B [W4], W4
001772  FB0204     SE W4, W4
001774  E80284     INC W4, W5
001776  20A3A4     MOV #0xA3A, W4
001778  428204     ADD W5, W4, W4
00177A  784214     MOV.B [W4], W4
00177C  FB0284     SE W4, W5
00177E  200FF4     MOV #0xFF, W4
001780  628284     AND W5, W4, W5
001782  805514     MOV Data, W4
001784  720205     IOR W4, W5, W4
001786  885514     MOV W4, Data
233:               	return Data;
001788  805514     MOV Data, W4
234:               }
00178A  780004     MOV W4, W0
00178C  FA8000     ULNK
00178E  060000     RETURN
235:               
236:               void InsertReg(char NumReg, int Data)
237:               {
001790  FA0004     LNK #0x4
001792  784F00     MOV.B W0, [W14]
001794  980711     MOV W1, [W14+2]
238:               	Indice = 0;
001796  EB4200     CLR.B W4
001798  784304     MOV.B W4, W6
00179A  20AA05     MOV #0xAA0, W5
00179C  784A86     MOV.B W6, [W5]
239:               	
240:               	Indice = 5+(NumReg*2);
00179E  78421E     MOV.B [W14], W4
0017A0  424204     ADD.B W4, W4, W4
0017A2  424265     ADD.B W4, #0x5, W4
0017A4  784304     MOV.B W4, W6
0017A6  20AA05     MOV #0xAA0, W5
0017A8  784A86     MOV.B W6, [W5]
241:               	/////Mod_BufferTx.Buffer[Indice] = (char)((Data&0xFF00)>>8);
242:               	Mod_BufferTx.Buffer[Indice] = (char)(((Data&0xFF00)>>8)&0x00FF);	// Modifica 05/01/2015 Aggiunta mascheratura byte shift
0017AA  20AA04     MOV #0xAA0, W4
0017AC  784214     MOV.B [W4], W4
0017AE  FB0304     SE W4, W6
0017B0  90021E     MOV [W14+2], W4
0017B2  DE2248     LSR W4, #8, W4
0017B4  784284     MOV.B W4, W5
0017B6  209E44     MOV #0x9E4, W4
0017B8  430204     ADD W6, W4, W4
0017BA  784A05     MOV.B W5, [W4]
243:               	Mod_BufferTx.Buffer[Indice+1] = (char)((Data&0x00FF));
0017BC  20AA04     MOV #0xAA0, W4
0017BE  784214     MOV.B [W4], W4
0017C0  FB0204     SE W4, W4
0017C2  E80304     INC W4, W6
0017C4  90021E     MOV [W14+2], W4
0017C6  784284     MOV.B W4, W5
0017C8  209E44     MOV #0x9E4, W4
0017CA  430204     ADD W6, W4, W4
0017CC  784A05     MOV.B W5, [W4]
244:               }
0017CE  FA8000     ULNK
0017D0  060000     RETURN
245:               
246:               
247:               //--------------------------------------------
248:               // Routines di gestione dei Touch
249:               //--------------------------------------------
250:               void Search_Touch(void)
251:               {
0017D2  FA0000     LNK #0x0
252:               	Result = 0;
0017D4  EB4200     CLR.B W4
0017D6  784304     MOV.B W4, W6
0017D8  20A9E5     MOV #0xA9E, W5
0017DA  784A86     MOV.B W6, [W5]
253:               
254:               	// Scansiono la rete alla ricerca dei touch
255:               	for(i=0; i<MaxTouch; i++)
0017DC  EB4200     CLR.B W4
0017DE  784304     MOV.B W4, W6
0017E0  20AA45     MOV #0xAA4, W5
0017E2  784A86     MOV.B W6, [W5]
0017E4  370042     BRA 0x186A
00185E  20AA44     MOV #0xAA4, W4
001860  784214     MOV.B [W4], W4
001862  E84204     INC.B W4, W4
001864  784304     MOV.B W4, W6
001866  20AA45     MOV #0xAA4, W5
001868  784A86     MOV.B W6, [W5]
00186A  20AA44     MOV #0xAA4, W4
00186C  784214     MOV.B [W4], W4
00186E  524FE3     SUB.B W4, #0x3, [W15]
001870  34FFBA     BRA LE, 0x17E6
256:               	{
257:               		Result = Send_WaitModRx(Add_TouchRoom+i, ReadModCmd, REG_TOUCH_PAGE, 1, MaxModChkWait, MaxModChkRetries);
0017E6  20AA44     MOV #0xAA4, W4
0017E8  784214     MOV.B [W4], W4
0017EA  E84204     INC.B W4, W4
0017EC  784304     MOV.B W4, W6
0017EE  B3C035     MOV.B #0x3, W5
0017F0  201904     MOV #0x190, W4
0017F2  200013     MOV #0x1, W3
0017F4  200012     MOV #0x1, W2
0017F6  B3C031     MOV.B #0x3, W1
0017F8  784006     MOV.B W6, W0
0017FA  07FD92     RCALL Send_WaitModRx
0017FC  784200     MOV.B W0, W4
0017FE  784304     MOV.B W4, W6
001800  20A9E5     MOV #0xA9E, W5
001802  784A86     MOV.B W6, [W5]
258:               		Touch[i].Enable = (Result == 0) ;
001804  20AA44     MOV #0xAA4, W4
001806  784214     MOV.B [W4], W4
001808  FB0204     SE W4, W4
00180A  20A9E5     MOV #0xA9E, W5
00180C  784295     MOV.B [W5], W5
00180E  FB8285     ZE W5, W5
001810  E90285     DEC W5, W5
001812  DE2ACF     LSR W5, #15, W5
001814  784305     MOV.B W5, W6
001816  B92278     MUL.SU W4, #24, W4
001818  780284     MOV W4, W5
00181A  20BC44     MOV #0xBC4, W4
00181C  428204     ADD W5, W4, W4
00181E  FB8286     ZE W6, W5
001820  6282E1     AND W5, #0x1, W5
001822  780394     MOV [W4], W7
001824  2FFFE6     MOV #0xFFFE, W6
001826  638306     AND W7, W6, W6
001828  728286     IOR W5, W6, W5
00182A  780A05     MOV W5, [W4]
259:               		Touch[i].OffLine = (Result != 0);
00182C  20AA44     MOV #0xAA4, W4
00182E  784214     MOV.B [W4], W4
001830  FB0204     SE W4, W4
001832  20A9E5     MOV #0xA9E, W5
001834  784295     MOV.B [W5], W5
001836  FB8285     ZE W5, W5
001838  EA0285     NEG W5, W5
00183A  DE2ACF     LSR W5, #15, W5
00183C  784305     MOV.B W5, W6
00183E  B92278     MUL.SU W4, #24, W4
001840  780284     MOV W4, W5
001842  20BC44     MOV #0xBC4, W4
001844  428204     ADD W5, W4, W4
001846  FB8286     ZE W6, W5
001848  6282E1     AND W5, #0x1, W5
00184A  428285     ADD W5, W5, W5
00184C  780394     MOV [W4], W7
00184E  2FFFD6     MOV #0xFFFD, W6
001850  638306     AND W7, W6, W6
001852  728286     IOR W5, W6, W5
001854  780A05     MOV W5, [W4]
260:               		Mod_LastRx.Valid_Data = 0;
001856  EB4200     CLR.B W4
001858  784304     MOV.B W4, W6
00185A  20A8E5     MOV #0xA8E, W5
00185C  784A86     MOV.B W6, [W5]
261:               	}
262:               }
001872  FA8000     ULNK
001874  060000     RETURN
263:               
264:               void Resume_TouchOffLine(char * Cnt)
265:               {
001876  FA0002     LNK #0x2
001878  780F00     MOV W0, [W14]
266:               	Result = 0;
00187A  EB4200     CLR.B W4
00187C  784304     MOV.B W4, W6
00187E  20A9E5     MOV #0xA9E, W5
001880  784A86     MOV.B W6, [W5]
267:               	
268:               	// Provo a recuperare i moduli Touch
269:               	if((Touch[(*Cnt)].Enable == 1) && (Touch[(*Cnt)].OffLine == 1))
001882  78021E     MOV [W14], W4
001884  784214     MOV.B [W4], W4
001886  FB0204     SE W4, W4
001888  B92278     MUL.SU W4, #24, W4
00188A  780204     MOV W4, W4
00188C  4202F6     ADD W4, #0x16, W5
00188E  20BAE4     MOV #0xBAE, W4
001890  428204     ADD W5, W4, W4
001892  780214     MOV [W4], W4
001894  784204     MOV.B W4, W4
001896  624261     AND.B W4, #0x1, W4
001898  524FE1     SUB.B W4, #0x1, [W15]
00189A  3A0035     BRA NZ, 0x1906
00189C  78021E     MOV [W14], W4
00189E  784214     MOV.B [W4], W4
0018A0  FB0204     SE W4, W4
0018A2  B92278     MUL.SU W4, #24, W4
0018A4  780204     MOV W4, W4
0018A6  4202F6     ADD W4, #0x16, W5
0018A8  20BAE4     MOV #0xBAE, W4
0018AA  428204     ADD W5, W4, W4
0018AC  780214     MOV [W4], W4
0018AE  D10204     LSR W4, W4
0018B0  624261     AND.B W4, #0x1, W4
0018B2  524FE1     SUB.B W4, #0x1, [W15]
0018B4  3A0028     BRA NZ, 0x1906
270:               	{
271:               		Result = Send_WaitModRx(Add_TouchRoom +(*Cnt), ReadModCmd, REG_TOUCH_PAGE, 1, MaxModChkWait, MaxModChkRetries);
0018B6  78021E     MOV [W14], W4
0018B8  784214     MOV.B [W4], W4
0018BA  E84204     INC.B W4, W4
0018BC  784304     MOV.B W4, W6
0018BE  B3C035     MOV.B #0x3, W5
0018C0  201904     MOV #0x190, W4
0018C2  200013     MOV #0x1, W3
0018C4  200012     MOV #0x1, W2
0018C6  B3C031     MOV.B #0x3, W1
0018C8  784006     MOV.B W6, W0
0018CA  07FD2A     RCALL Send_WaitModRx
0018CC  784200     MOV.B W0, W4
0018CE  784304     MOV.B W4, W6
0018D0  20A9E5     MOV #0xA9E, W5
0018D2  784A86     MOV.B W6, [W5]
272:               		Touch[(*Cnt)].OffLine = (Result != 0);
0018D4  78021E     MOV [W14], W4
0018D6  784214     MOV.B [W4], W4
0018D8  FB0204     SE W4, W4
0018DA  20A9E5     MOV #0xA9E, W5
0018DC  784295     MOV.B [W5], W5
0018DE  FB8285     ZE W5, W5
0018E0  EA0285     NEG W5, W5
0018E2  DE2ACF     LSR W5, #15, W5
0018E4  784305     MOV.B W5, W6
0018E6  B92278     MUL.SU W4, #24, W4
0018E8  780284     MOV W4, W5
0018EA  20BC44     MOV #0xBC4, W4
0018EC  428204     ADD W5, W4, W4
0018EE  FB8286     ZE W6, W5
0018F0  6282E1     AND W5, #0x1, W5
0018F2  428285     ADD W5, W5, W5
0018F4  780394     MOV [W4], W7
0018F6  2FFFD6     MOV #0xFFFD, W6
0018F8  638306     AND W7, W6, W6
0018FA  728286     IOR W5, W6, W5
0018FC  780A05     MOV W5, [W4]
273:               		Mod_LastRx.Valid_Data = 0;
0018FE  EB4200     CLR.B W4
001900  784304     MOV.B W4, W6
001902  20A8E5     MOV #0xA8E, W5
001904  784A86     MOV.B W6, [W5]
274:               	}
275:               	(*Cnt) += 1;
001906  78021E     MOV [W14], W4
001908  784214     MOV.B [W4], W4
00190A  E84204     INC.B W4, W4
00190C  784284     MOV.B W4, W5
00190E  78021E     MOV [W14], W4
001910  784A05     MOV.B W5, [W4]
276:               	if((*Cnt) >= MaxTouch)
001912  78021E     MOV [W14], W4
001914  784214     MOV.B [W4], W4
001916  524FE3     SUB.B W4, #0x3, [W15]
001918  340003     BRA LE, 0x1920
277:               		(*Cnt) = 0;
00191A  78021E     MOV [W14], W4
00191C  EB4280     CLR.B W5
00191E  784A05     MOV.B W5, [W4]
278:               }
001920  FA8000     ULNK
001922  060000     RETURN
279:               
280:               
281:               // Legge da Touch
282:               void RefreshTouchInPut(char TouchAddres)
283:               {
001924  FA0008     LNK #0x8
001926  781F88     MOV W8, [W15++]
001928  984760     MOV.B W0, [W14+6]
284:               	DataIndex = TouchAddres-Add_TouchRoom;
00192A  90426E     MOV.B [W14+6], W4
00192C  E94204     DEC.B W4, W4
00192E  784304     MOV.B W4, W6
001930  20AA55     MOV #0xAA5, W5
001932  784A86     MOV.B W6, [W5]
285:               	if(Touch[DataIndex].Enable & !Touch[DataIndex].OffLine)
001934  20AA54     MOV #0xAA5, W4
001936  784214     MOV.B [W4], W4
001938  FB0204     SE W4, W4
00193A  B92278     MUL.SU W4, #24, W4
00193C  780204     MOV W4, W4
00193E  4202F6     ADD W4, #0x16, W5
001940  20BAE4     MOV #0xBAE, W4
001942  428204     ADD W5, W4, W4
001944  780214     MOV [W4], W4
001946  784204     MOV.B W4, W4
001948  624261     AND.B W4, #0x1, W4
00194A  FB8304     ZE W4, W6
00194C  20AA54     MOV #0xAA5, W4
00194E  784214     MOV.B [W4], W4
001950  FB0204     SE W4, W4
001952  B92278     MUL.SU W4, #24, W4
001954  780204     MOV W4, W4
001956  4202F6     ADD W4, #0x16, W5
001958  20BAE4     MOV #0xBAE, W4
00195A  428204     ADD W5, W4, W4
00195C  780214     MOV [W4], W4
00195E  D10204     LSR W4, W4
001960  624261     AND.B W4, #0x1, W4
001962  FB8204     ZE W4, W4
001964  E90204     DEC W4, W4
001966  DE224F     LSR W4, #15, W4
001968  630204     AND W6, W4, W4
00196A  520FE0     SUB W4, #0x0, [W15]
00196C  3201D5     BRA Z, 0x1D18
286:               	{	
287:               		ReadModReg (TouchAddres, REG_TOUCH_PAGE, &(Touch[DataIndex].Current_Page));
00196E  20AA54     MOV #0xAA5, W4
001970  784214     MOV.B [W4], W4
001972  FB0204     SE W4, W4
001974  B92278     MUL.SU W4, #24, W4
001976  780204     MOV W4, W4
001978  4202EC     ADD W4, #0xC, W5
00197A  20BAE4     MOV #0xBAE, W4
00197C  428204     ADD W5, W4, W4
00197E  780104     MOV W4, W2
001980  200011     MOV #0x1, W1
001982  90406E     MOV.B [W14+6], W0
001984  07FD63     RCALL ReadModReg
288:               		switch((char)Touch[DataIndex].Current_Page)
001986  20AA54     MOV #0xAA5, W4
001988  784214     MOV.B [W4], W4
00198A  FB0204     SE W4, W4
00198C  B92278     MUL.SU W4, #24, W4
00198E  780204     MOV W4, W4
001990  4202EC     ADD W4, #0xC, W5
001992  20BAE4     MOV #0xBAE, W4
001994  428204     ADD W5, W4, W4
001996  780214     MOV [W4], W4
001998  784204     MOV.B W4, W4
00199A  FB0204     SE W4, W4
00199C  DEA2CF     ASR W4, #15, W5
00199E  200106     MOV #0x10, W6
0019A0  200007     MOV #0x0, W7
0019A2  520F86     SUB W4, W6, [W15]
0019A4  5A8F87     SUBB W5, W7, [W15]
0019A6  3E01B8     BRA GTU, 0x1D18
0019A8  016004     BRA W4
0019AA  370010     BRA 0x19CC
0019AC  3701B5     BRA 0x1D18
0019AE  370010     BRA 0x19D0
0019B0  370086     BRA 0x1ABE
0019B2  3701B2     BRA 0x1D18
0019B4  3701B1     BRA 0x1D18
0019B6  3700BF     BRA 0x1B36
0019B8  3700EF     BRA 0x1B98
0019BA  370126     BRA 0x1C08
0019BC  3701AD     BRA 0x1D18
0019BE  3701AC     BRA 0x1D18
0019C0  370173     BRA 0x1CA8
0019C2  3701AA     BRA 0x1D18
0019C4  3701A9     BRA 0x1D18
0019C6  3701A8     BRA 0x1D18
0019C8  3701A7     BRA 0x1D18
0019CA  3701A6     BRA 0x1D18
289:               		{
290:               			case 0:
291:               				InitTouch();
0019CC  07052D     RCALL InitTouch
292:               				break;
0019CE  3701A4     BRA 0x1D18
293:               			case 2:		// pagina 2 -> Home
294:               				if(!Touch[DataIndex].OffLine)
0019D0  20AA54     MOV #0xAA5, W4
0019D2  784214     MOV.B [W4], W4
0019D4  FB0204     SE W4, W4
0019D6  B92278     MUL.SU W4, #24, W4
0019D8  780204     MOV W4, W4
0019DA  4202F6     ADD W4, #0x16, W5
0019DC  20BAE4     MOV #0xBAE, W4
0019DE  428204     ADD W5, W4, W4
0019E0  780214     MOV [W4], W4
0019E2  D10204     LSR W4, W4
0019E4  624261     AND.B W4, #0x1, W4
0019E6  524FE0     SUB.B W4, #0x0, [W15]
0019E8  3A018C     BRA NZ, 0x1D02
295:               				{
296:               					if(Send_WaitModRx(TouchAddres, ReadModCmd, REG_TOUCH_PWR, 2, MaxModReadWait, MaxModReadRetries))	// Il registro dei touch hanno un offset di 1
0019EA  B3C025     MOV.B #0x2, W5
0019EC  200324     MOV #0x32, W4
0019EE  200023     MOV #0x2, W3
0019F0  200022     MOV #0x2, W2
0019F2  B3C031     MOV.B #0x3, W1
0019F4  90406E     MOV.B [W14+6], W0
0019F6  07FC94     RCALL Send_WaitModRx
0019F8  784200     MOV.B W0, W4
0019FA  524FE0     SUB.B W4, #0x0, [W15]
0019FC  32000B     BRA Z, 0x1A14
297:               						Touch[DataIndex].OffLine = 1;
0019FE  20AA54     MOV #0xAA5, W4
001A00  784214     MOV.B [W4], W4
001A02  FB0204     SE W4, W4
001A04  B92278     MUL.SU W4, #24, W4
001A06  780284     MOV W4, W5
001A08  20BC44     MOV #0xBC4, W4
001A0A  428284     ADD W5, W4, W5
001A0C  780215     MOV [W5], W4
001A0E  A01004     BSET W4, #1
001A10  780A84     MOV W4, [W5]
001A12  370016     BRA 0x1A40
298:               					else
299:               					{
300:               						Touch[DataIndex].Script_Split_Pwr = ExtracReg(1);	// REG_TOUCH_PWR
001A14  20AA54     MOV #0xAA5, W4
001A16  784214     MOV.B [W4], W4
001A18  FB0404     SE W4, W8
001A1A  B3C010     MOV.B #0x1, W0
001A1C  07FE91     RCALL ExtracReg
001A1E  780300     MOV W0, W6
001A20  B94278     MUL.SU W8, #24, W4
001A22  780284     MOV W4, W5
001A24  20BC04     MOV #0xBC0, W4
001A26  428204     ADD W5, W4, W4
001A28  780A06     MOV W6, [W4]
301:               						Touch[DataIndex].DefMode = ExtracReg(2);			// REG_TOUCH_MODE
001A2A  20AA54     MOV #0xAA5, W4
001A2C  784214     MOV.B [W4], W4
001A2E  FB0404     SE W4, W8
001A30  B3C020     MOV.B #0x2, W0
001A32  07FE86     RCALL ExtracReg
001A34  780300     MOV W0, W6
001A36  B94278     MUL.SU W8, #24, W4
001A38  780284     MOV W4, W5
001A3A  20BBE4     MOV #0xBBE, W4
001A3C  428204     ADD W5, W4, W4
001A3E  780A06     MOV W6, [W4]
302:               					}
303:               					Mod_LastRx.Valid_Data = 0;
001A40  EB4200     CLR.B W4
001A42  784304     MOV.B W4, W6
001A44  20A8E5     MOV #0xA8E, W5
001A46  784A86     MOV.B W6, [W5]
304:               					
305:               					if(Send_WaitModRx(TouchAddres, ReadModCmd, REG_TOUCH_SP_ROOM, 3, MaxModReadWait, MaxModReadRetries))	// Il registro dei touch hanno un offset di 1
001A48  B3C025     MOV.B #0x2, W5
001A4A  200324     MOV #0x32, W4
001A4C  200033     MOV #0x3, W3
001A4E  200132     MOV #0x13, W2
001A50  B3C031     MOV.B #0x3, W1
001A52  90406E     MOV.B [W14+6], W0
001A54  07FC65     RCALL Send_WaitModRx
001A56  784200     MOV.B W0, W4
001A58  524FE0     SUB.B W4, #0x0, [W15]
001A5A  32000B     BRA Z, 0x1A72
306:               						Touch[DataIndex].OffLine = 1;
001A5C  20AA54     MOV #0xAA5, W4
001A5E  784214     MOV.B [W4], W4
001A60  FB0204     SE W4, W4
001A62  B92278     MUL.SU W4, #24, W4
001A64  780284     MOV W4, W5
001A66  20BC44     MOV #0xBC4, W4
001A68  428284     ADD W5, W4, W5
001A6A  780215     MOV [W5], W4
001A6C  A01004     BSET W4, #1
001A6E  780A84     MOV W4, [W5]
001A70  370021     BRA 0x1AB4
307:               					else
308:               					{
309:               						Touch[DataIndex].SetPoint = ExtracReg(1);
001A72  20AA54     MOV #0xAA5, W4
001A74  784214     MOV.B [W4], W4
001A76  FB0404     SE W4, W8
001A78  B3C010     MOV.B #0x1, W0
001A7A  07FE62     RCALL ExtracReg
001A7C  780300     MOV W0, W6
001A7E  B94278     MUL.SU W8, #24, W4
001A80  780284     MOV W4, W5
001A82  20BAE4     MOV #0xBAE, W4
001A84  428204     ADD W5, W4, W4
001A86  780A06     MOV W6, [W4]
310:               						Touch[DataIndex].FanMode = ExtracReg(2);
001A88  20AA54     MOV #0xAA5, W4
001A8A  784214     MOV.B [W4], W4
001A8C  FB0404     SE W4, W8
001A8E  B3C020     MOV.B #0x2, W0
001A90  07FE57     RCALL ExtracReg
001A92  780300     MOV W0, W6
001A94  B94278     MUL.SU W8, #24, W4
001A96  780284     MOV W4, W5
001A98  20BB24     MOV #0xBB2, W4
001A9A  428204     ADD W5, W4, W4
001A9C  780A06     MOV W6, [W4]
311:               						Touch[DataIndex].FunctionMode = ExtracReg(3);
001A9E  20AA54     MOV #0xAA5, W4
001AA0  784214     MOV.B [W4], W4
001AA2  FB0404     SE W4, W8
001AA4  B3C030     MOV.B #0x3, W0
001AA6  07FE4C     RCALL ExtracReg
001AA8  780300     MOV W0, W6
001AAA  B94278     MUL.SU W8, #24, W4
001AAC  780284     MOV W4, W5
001AAE  20BB04     MOV #0xBB0, W4
001AB0  428204     ADD W5, W4, W4
001AB2  780A06     MOV W6, [W4]
312:               					}
313:               					Mod_LastRx.Valid_Data = 0;
001AB4  EB4200     CLR.B W4
001AB6  784304     MOV.B W4, W6
001AB8  20A8E5     MOV #0xA8E, W5
001ABA  784A86     MOV.B W6, [W5]
314:               				}
315:               				break;
001ABC  37012D     BRA 0x1D18
001D02  000000     NOP
001D04  370009     BRA 0x1D18
316:               
317:               			case 3:		// pagina 3 -> Power Manager
318:               				/*
319:               				if(!Touch[DataIndex].OffLine & (Me.PowerLimit == Me.OldPowerLimit) & (EngineBox.PowerLimit == EngineBox.OldPowerLimit))
320:               				{
321:               					if(Send_WaitModRx(TouchAddres, ReadModCmd, REG_TOUCH_MAX_PWR_LIMIT, 3, MaxModReadWait, MaxModReadRetries))	// Il registro dei touch hanno un offset di 1
322:               						Touch[DataIndex].OffLine = 1;
323:               					else
324:               					{
325:               						Touch[DataIndex].PowerLimit = ExtracReg(1);
326:               						if(Touch[DataIndex].PowerLimit != Touch[DataIndex].OldPowerLimit)	// se è variato
327:               						{	for(i=0; i< MaxTouch; i++)										// aggiorno gli altri touch
328:               							{	if(Touch[i].Enable)
329:               								{	/////WriteModReg (i+1, REG_TOUCH_MAX_PWR_LIMIT, Touch[DataIndex].PowerLimit);
330:               									WriteModReg (Add_TouchRoom+i, REG_TOUCH_MAX_PWR_LIMIT, Touch[DataIndex].PowerLimit);
331:               									Touch[DataIndex].OldPowerLimit = Touch[DataIndex].PowerLimit;
332:               								}
333:               							}
334:               							Me.PowerLimit = Touch[DataIndex].PowerLimit;			// setto il registro con i valori da aggiornare
335:               						}
336:               					}
337:               					Mod_LastRx.Valid_Data = 0;
338:               				}
339:               				*/
340:               				if(!Touch[DataIndex].OffLine)
001ABE  20AA54     MOV #0xAA5, W4
001AC0  784214     MOV.B [W4], W4
001AC2  FB0204     SE W4, W4
001AC4  B92278     MUL.SU W4, #24, W4
001AC6  780204     MOV W4, W4
001AC8  4202F6     ADD W4, #0x16, W5
001ACA  20BAE4     MOV #0xBAE, W4
001ACC  428204     ADD W5, W4, W4
001ACE  780214     MOV [W4], W4
001AD0  D10204     LSR W4, W4
001AD2  624261     AND.B W4, #0x1, W4
001AD4  524FE0     SUB.B W4, #0x0, [W15]
001AD6  3A0117     BRA NZ, 0x1D06
341:               				{
342:               					if(Send_WaitModRx(TouchAddres, ReadModCmd, REG_TOUCH_MAX_PWR_LIMIT, 3, MaxModReadWait, MaxModReadRetries))	// Il registro dei touch hanno un offset di 1
001AD8  B3C025     MOV.B #0x2, W5
001ADA  200324     MOV #0x32, W4
001ADC  200033     MOV #0x3, W3
001ADE  200202     MOV #0x20, W2
001AE0  B3C031     MOV.B #0x3, W1
001AE2  90406E     MOV.B [W14+6], W0
001AE4  07FC1D     RCALL Send_WaitModRx
001AE6  784200     MOV.B W0, W4
001AE8  524FE0     SUB.B W4, #0x0, [W15]
001AEA  32000B     BRA Z, 0x1B02
343:               						Touch[DataIndex].OffLine = 1;
001AEC  20AA54     MOV #0xAA5, W4
001AEE  784214     MOV.B [W4], W4
001AF0  FB0204     SE W4, W4
001AF2  B92278     MUL.SU W4, #24, W4
001AF4  780284     MOV W4, W5
001AF6  20BC44     MOV #0xBC4, W4
001AF8  428284     ADD W5, W4, W5
001AFA  780215     MOV [W5], W4
001AFC  A01004     BSET W4, #1
001AFE  780A84     MOV W4, [W5]
001B00  370015     BRA 0x1B2C
344:               					else
345:               					{
346:               						Touch[DataIndex].PowerLimit = ExtracReg(1);
001B02  20AA54     MOV #0xAA5, W4
001B04  784214     MOV.B [W4], W4
001B06  FB0404     SE W4, W8
001B08  B3C010     MOV.B #0x1, W0
001B0A  07FE1A     RCALL ExtracReg
001B0C  780300     MOV W0, W6
001B0E  B94278     MUL.SU W8, #24, W4
001B10  780284     MOV W4, W5
001B12  20BB44     MOV #0xBB4, W4
001B14  428204     ADD W5, W4, W4
001B16  780A06     MOV W6, [W4]
347:               						Me.PowerLimit = Touch[DataIndex].PowerLimit;			// setto il registro con i valori da aggiornare
001B18  20AA54     MOV #0xAA5, W4
001B1A  784214     MOV.B [W4], W4
001B1C  FB0204     SE W4, W4
001B1E  B92278     MUL.SU W4, #24, W4
001B20  780204     MOV W4, W4
001B22  4202E6     ADD W4, #0x6, W5
001B24  20BAE4     MOV #0xBAE, W4
001B26  428204     ADD W5, W4, W4
001B28  780214     MOV [W4], W4
001B2A  885BD4     MOV W4, 0xB7A
348:               					
349:               					}
350:               					Mod_LastRx.Valid_Data = 0;
001B2C  EB4200     CLR.B W4
001B2E  784304     MOV.B W4, W6
001B30  20A8E5     MOV #0xA8E, W5
001B32  784A86     MOV.B W6, [W5]
351:               				}
352:               				break;
001B34  3700F1     BRA 0x1D18
001D06  000000     NOP
001D08  370007     BRA 0x1D18
353:               
354:               			case 4:		// pagina 4 -> Service Login
355:               				break;	
356:               				
357:               			case 5:		// pagina 5 -> Faults1
358:               				break;
359:               				
360:               			case 6:		// pagina 6 -> Faults2
361:               				if(!Touch[DataIndex].OffLine)
001B36  20AA54     MOV #0xAA5, W4
001B38  784214     MOV.B [W4], W4
001B3A  FB0204     SE W4, W4
001B3C  B92278     MUL.SU W4, #24, W4
001B3E  780204     MOV W4, W4
001B40  4202F6     ADD W4, #0x16, W5
001B42  20BAE4     MOV #0xBAE, W4
001B44  428204     ADD W5, W4, W4
001B46  780214     MOV [W4], W4
001B48  D10204     LSR W4, W4
001B4A  624261     AND.B W4, #0x1, W4
001B4C  524FE0     SUB.B W4, #0x0, [W15]
001B4E  3A00DD     BRA NZ, 0x1D0A
362:               				{	if(Send_WaitModRx(TouchAddres, ReadModCmd, REG_TOUCH_CLEAR_ERROR, 3, MaxModReadWait, MaxModReadRetries))	// Il registro dei touch hanno un offset di 1
001B50  B3C025     MOV.B #0x2, W5
001B52  200324     MOV #0x32, W4
001B54  200033     MOV #0x3, W3
001B56  2005C2     MOV #0x5C, W2
001B58  B3C031     MOV.B #0x3, W1
001B5A  90406E     MOV.B [W14+6], W0
001B5C  07FBE1     RCALL Send_WaitModRx
001B5E  784200     MOV.B W0, W4
001B60  524FE0     SUB.B W4, #0x0, [W15]
001B62  32000B     BRA Z, 0x1B7A
363:               						Touch[DataIndex].OffLine = 1;
001B64  20AA54     MOV #0xAA5, W4
001B66  784214     MOV.B [W4], W4
001B68  FB0204     SE W4, W4
001B6A  B92278     MUL.SU W4, #24, W4
001B6C  780284     MOV W4, W5
001B6E  20BC44     MOV #0xBC4, W4
001B70  428284     ADD W5, W4, W5
001B72  780215     MOV [W5], W4
001B74  A01004     BSET W4, #1
001B76  780A84     MOV W4, [W5]
001B78  37000A     BRA 0x1B8E
364:               					else
365:               					{	int Temp = 0;
001B7A  EB0200     CLR W4
001B7C  780F04     MOV W4, [W14]
366:               						Temp = ExtracReg(1);
001B7E  B3C010     MOV.B #0x1, W0
001B80  07FDDF     RCALL ExtracReg
001B82  780200     MOV W0, W4
001B84  780F04     MOV W4, [W14]
367:               
368:               						if(Temp == 1)
001B86  78021E     MOV [W14], W4
001B88  520FE1     SUB W4, #0x1, [W15]
001B8A  3A0001     BRA NZ, 0x1B8E
369:               						{	
370:               							Me.Error.ClearErrReq = 1;
001B8C  A80BAC     BSET 0xBAC, #0
371:               						}
372:               					}
373:               
374:               					Mod_LastRx.Valid_Data = 0;
001B8E  EB4200     CLR.B W4
001B90  784304     MOV.B W4, W6
001B92  20A8E5     MOV #0xA8E, W5
001B94  784A86     MOV.B W6, [W5]
375:               				}				
376:               				break;
001B96  3700C0     BRA 0x1D18
001D0A  000000     NOP
001D0C  370005     BRA 0x1D18
377:               				
378:               			case 7:		// pagina 7 -> Faults3		
379:               				if(!Touch[DataIndex].OffLine)
001B98  20AA54     MOV #0xAA5, W4
001B9A  784214     MOV.B [W4], W4
001B9C  FB0204     SE W4, W4
001B9E  B92278     MUL.SU W4, #24, W4
001BA0  780204     MOV W4, W4
001BA2  4202F6     ADD W4, #0x16, W5
001BA4  20BAE4     MOV #0xBAE, W4
001BA6  428204     ADD W5, W4, W4
001BA8  780214     MOV [W4], W4
001BAA  D10204     LSR W4, W4
001BAC  624261     AND.B W4, #0x1, W4
001BAE  524FE0     SUB.B W4, #0x0, [W15]
001BB0  3A00AE     BRA NZ, 0x1D0E
380:               				{						
381:               					if(Send_WaitModRx(TouchAddres, ReadModCmd, REG_TOUCH_SPLIT_CLEAR_ERROR, 3, MaxModReadWait, MaxModReadRetries))	// Il registro dei touch hanno un offset di 1
001BB2  B3C025     MOV.B #0x2, W5
001BB4  200324     MOV #0x32, W4
001BB6  200033     MOV #0x3, W3
001BB8  200902     MOV #0x90, W2
001BBA  B3C031     MOV.B #0x3, W1
001BBC  90406E     MOV.B [W14+6], W0
001BBE  07FBB0     RCALL Send_WaitModRx
001BC0  784200     MOV.B W0, W4
001BC2  524FE0     SUB.B W4, #0x0, [W15]
001BC4  32000B     BRA Z, 0x1BDC
382:               						Touch[DataIndex].OffLine = 1;
001BC6  20AA54     MOV #0xAA5, W4
001BC8  784214     MOV.B [W4], W4
001BCA  FB0204     SE W4, W4
001BCC  B92278     MUL.SU W4, #24, W4
001BCE  780284     MOV W4, W5
001BD0  20BC44     MOV #0xBC4, W4
001BD2  428284     ADD W5, W4, W5
001BD4  780215     MOV [W5], W4
001BD6  A01004     BSET W4, #1
001BD8  780A84     MOV W4, [W5]
001BDA  370011     BRA 0x1BFE
383:               					else
384:               					{	int Temp = 0;
001BDC  EB0200     CLR W4
001BDE  980714     MOV W4, [W14+2]
385:               						Temp = ExtracReg(1);
001BE0  B3C010     MOV.B #0x1, W0
001BE2  07FDAE     RCALL ExtracReg
001BE4  780200     MOV W0, W4
001BE6  980714     MOV W4, [W14+2]
386:               						if(Temp == 1)
001BE8  90021E     MOV [W14+2], W4
001BEA  520FE1     SUB W4, #0x1, [W15]
001BEC  3A0008     BRA NZ, 0x1BFE
387:               						{	
388:               							Me.Error.Battery_Defrost = 0;
001BEE  A92BAC     BCLR 0xBAC, #1
389:               							Me.Error.EEV_Open = 0;
001BF0  A94BAC     BCLR 0xBAC, #2
390:               							Me.Error.EEV_Close = 0;
001BF2  A96BAC     BCLR 0xBAC, #3
391:               							Me.Error.BatteriaGhiacciata = 0;
001BF4  A98BAC     BCLR 0xBAC, #4
392:               							Me.Error.Fan_Fault = 0;
001BF6  A9ABAC     BCLR 0xBAC, #5
393:               							Me.Error.Fan_OverLoad = 0;
001BF8  A9CBAC     BCLR 0xBAC, #6
394:               							Me.Error.EEV_Test_End = 0;
001BFA  A9EBAC     BCLR 0xBAC, #7
395:               							Me.Error.ClearSplitErrReq = 1;
001BFC  A80BAD     BSET 0xBAD, #0
396:               						}
397:               					}
398:               					Mod_LastRx.Valid_Data = 0;
001BFE  EB4200     CLR.B W4
001C00  784304     MOV.B W4, W6
001C02  20A8E5     MOV #0xA8E, W5
001C04  784A86     MOV.B W6, [W5]
399:               				}
400:               				break;
001C06  370088     BRA 0x1D18
001D0E  000000     NOP
001D10  370003     BRA 0x1D18
401:               				
402:               			case 8:		// pagina 8 -> Faults4			//Ex.Pag.8
403:               				if(!Touch[DataIndex].OffLine)
001C08  20AA54     MOV #0xAA5, W4
001C0A  784214     MOV.B [W4], W4
001C0C  FB0204     SE W4, W4
001C0E  B92278     MUL.SU W4, #24, W4
001C10  780204     MOV W4, W4
001C12  4202F6     ADD W4, #0x16, W5
001C14  20BAE4     MOV #0xBAE, W4
001C16  428204     ADD W5, W4, W4
001C18  780214     MOV [W4], W4
001C1A  D10204     LSR W4, W4
001C1C  624261     AND.B W4, #0x1, W4
001C1E  524FE0     SUB.B W4, #0x0, [W15]
001C20  3A0078     BRA NZ, 0x1D12
404:               				{						
405:               					if(Send_WaitModRx(TouchAddres, ReadModCmd, REG_TOUCH_CLEAR_ERROR, 3, MaxModReadWait, MaxModReadRetries))	// Il registro dei touch hanno un offset di 1
001C22  B3C025     MOV.B #0x2, W5
001C24  200324     MOV #0x32, W4
001C26  200033     MOV #0x3, W3
001C28  2005C2     MOV #0x5C, W2
001C2A  B3C031     MOV.B #0x3, W1
001C2C  90406E     MOV.B [W14+6], W0
001C2E  07FB78     RCALL Send_WaitModRx
001C30  784200     MOV.B W0, W4
001C32  524FE0     SUB.B W4, #0x0, [W15]
001C34  32000B     BRA Z, 0x1C4C
406:               						Touch[DataIndex].OffLine = 1;
001C36  20AA54     MOV #0xAA5, W4
001C38  784214     MOV.B [W4], W4
001C3A  FB0204     SE W4, W4
001C3C  B92278     MUL.SU W4, #24, W4
001C3E  780284     MOV W4, W5
001C40  20BC44     MOV #0xBC4, W4
001C42  428284     ADD W5, W4, W5
001C44  780215     MOV [W5], W4
001C46  A01004     BSET W4, #1
001C48  780A84     MOV W4, [W5]
001C4A  37000A     BRA 0x1C60
407:               					else
408:               					{	int Temp = 0;
001C4C  EB0200     CLR W4
001C4E  980724     MOV W4, [W14+4]
409:               						Temp = ExtracReg(1);
001C50  B3C010     MOV.B #0x1, W0
001C52  07FD76     RCALL ExtracReg
001C54  780200     MOV W0, W4
001C56  980724     MOV W4, [W14+4]
410:               	
411:               						if(Temp == 2)
001C58  90022E     MOV [W14+4], W4
001C5A  520FE2     SUB W4, #0x2, [W15]
001C5C  3A0001     BRA NZ, 0x1C60
412:               						{	
413:               							Me.Error.ClearDiagnosticSplitErrReq = 1;
001C5E  A82BAD     BSET 0xBAD, #1
414:               						}					
415:               					}
416:               					Mod_LastRx.Valid_Data = 0;
001C60  EB4200     CLR.B W4
001C62  784304     MOV.B W4, W6
001C64  20A8E5     MOV #0xA8E, W5
001C66  784A86     MOV.B W6, [W5]
417:               					
418:               					
419:               					if(Send_WaitModRx(TouchAddres, ReadModCmd, REG_TOUCH_SPLIT_TEST_ADDRESS, 3, MaxModReadWait, MaxModReadRetries))	// Il registro dei touch hanno un offset di 1
001C68  B3C025     MOV.B #0x2, W5
001C6A  200324     MOV #0x32, W4
001C6C  200033     MOV #0x3, W3
001C6E  2007D2     MOV #0x7D, W2
001C70  B3C031     MOV.B #0x3, W1
001C72  90406E     MOV.B [W14+6], W0
001C74  07FB55     RCALL Send_WaitModRx
001C76  784200     MOV.B W0, W4
001C78  524FE0     SUB.B W4, #0x0, [W15]
001C7A  32000D     BRA Z, 0x1C96
420:               					{
421:               						Touch[DataIndex].OffLine = 1;
001C7C  20AA54     MOV #0xAA5, W4
001C7E  784214     MOV.B [W4], W4
001C80  FB0204     SE W4, W4
001C82  B92278     MUL.SU W4, #24, W4
001C84  780284     MOV W4, W5
001C86  20BC44     MOV #0xBC4, W4
001C88  428284     ADD W5, W4, W5
001C8A  780215     MOV [W5], W4
001C8C  A01004     BSET W4, #1
001C8E  780A84     MOV W4, [W5]
422:               						DiagnosticSplit.Address = 0;
001C90  EB0200     CLR W4
001C92  887144     MOV W4, DiagnosticSplit
001C94  370004     BRA 0x1C9E
423:               					}
424:               					else
425:               						DiagnosticSplit.Address = ExtracReg(1);
001C96  B3C010     MOV.B #0x1, W0
001C98  07FD53     RCALL ExtracReg
001C9A  780200     MOV W0, W4
001C9C  887144     MOV W4, DiagnosticSplit
426:               
427:               					Mod_LastRx.Valid_Data = 0;	
001C9E  EB4200     CLR.B W4
001CA0  784304     MOV.B W4, W6
001CA2  20A8E5     MOV #0xA8E, W5
001CA4  784A86     MOV.B W6, [W5]
428:               				}
429:               						
430:               				break;
001CA6  370038     BRA 0x1D18
001D12  000000     NOP
001D14  370001     BRA 0x1D18
431:               
432:               			case 9:		// pagina 9 -> Diagnostica Box motore			//Ex.Pag.9
433:               				break;
434:               
435:               			case 10:		// pagina 10 -> Diagnostica Split				//Ex.Pag.10
436:               				break;
437:               
438:               			case 11:		// pagina 11 -> Diagnostica Other Split			//Ex.Pag.11 #v16
439:               				if(!Touch[DataIndex].OffLine)
001CA8  20AA54     MOV #0xAA5, W4
001CAA  784214     MOV.B [W4], W4
001CAC  FB0204     SE W4, W4
001CAE  B92278     MUL.SU W4, #24, W4
001CB0  780204     MOV W4, W4
001CB2  4202F6     ADD W4, #0x16, W5
001CB4  20BAE4     MOV #0xBAE, W4
001CB6  428204     ADD W5, W4, W4
001CB8  780214     MOV [W4], W4
001CBA  D10204     LSR W4, W4
001CBC  624261     AND.B W4, #0x1, W4
001CBE  524FE0     SUB.B W4, #0x0, [W15]
001CC0  3A002A     BRA NZ, 0x1D16
440:               				{	
441:               					if(Send_WaitModRx(TouchAddres, ReadModCmd, REG_TOUCH_SPLIT_TEST_ADDRESS, 3, MaxModReadWait, MaxModReadRetries))	// Il registro dei touch hanno un offset di 1
001CC2  B3C025     MOV.B #0x2, W5
001CC4  200324     MOV #0x32, W4
001CC6  200033     MOV #0x3, W3
001CC8  2007D2     MOV #0x7D, W2
001CCA  B3C031     MOV.B #0x3, W1
001CCC  90406E     MOV.B [W14+6], W0
001CCE  07FB28     RCALL Send_WaitModRx
001CD0  784200     MOV.B W0, W4
001CD2  524FE0     SUB.B W4, #0x0, [W15]
001CD4  32000D     BRA Z, 0x1CF0
442:               					{
443:               						Touch[DataIndex].OffLine = 1;
001CD6  20AA54     MOV #0xAA5, W4
001CD8  784214     MOV.B [W4], W4
001CDA  FB0204     SE W4, W4
001CDC  B92278     MUL.SU W4, #24, W4
001CDE  780284     MOV W4, W5
001CE0  20BC44     MOV #0xBC4, W4
001CE2  428284     ADD W5, W4, W5
001CE4  780215     MOV [W5], W4
001CE6  A01004     BSET W4, #1
001CE8  780A84     MOV W4, [W5]
444:               						DiagnosticSplit.Address = 0;
001CEA  EB0200     CLR W4
001CEC  887144     MOV W4, DiagnosticSplit
001CEE  370004     BRA 0x1CF8
445:               					}
446:               					else
447:               						DiagnosticSplit.Address = ExtracReg(1);
001CF0  B3C010     MOV.B #0x1, W0
001CF2  07FD26     RCALL ExtracReg
001CF4  780200     MOV W0, W4
001CF6  887144     MOV W4, DiagnosticSplit
448:               
449:               					Mod_LastRx.Valid_Data = 0;
001CF8  EB4200     CLR.B W4
001CFA  784304     MOV.B W4, W6
001CFC  20A8E5     MOV #0xA8E, W5
001CFE  784A86     MOV.B W6, [W5]
450:               				}
451:               				break;
001D00  37000B     BRA 0x1D18
001D16  000000     NOP
452:               
453:               			case 12:		// pagina 12 -> Diagnostica Inverter			//Ex.Pag.12
454:               				break;
455:               
456:               			case 13:		// pagina 13 -> VNC			
457:               				break;				
458:               				
459:               			case 14:		// pagina 14-> Power Monitor
460:               				break;
461:               			case 15:		// pagina 15-> Engine Detail
462:               				break;
463:               			case 16:		// pagina 16-> Air Handler Detail				
464:               				break;				
465:               				
466:               		}
467:               	}
468:               }
001D18  78044F     MOV [--W15], W8
001D1A  FA8000     ULNK
001D1C  060000     RETURN
469:               
470:               void RefreshAllTouchInPut(void)
471:               {
001D1E  FA0000     LNK #0x0
472:               	/////for(i=1; i<=MaxTouch; i++)
473:               	for(i=Add_TouchRoom; i< (Add_TouchRoom+MaxTouch); i++)
001D20  B3C014     MOV.B #0x1, W4
001D22  784304     MOV.B W4, W6
001D24  20AA45     MOV #0xAA4, W5
001D26  784A86     MOV.B W6, [W5]
001D28  37000A     BRA 0x1D3E
001D32  20AA44     MOV #0xAA4, W4
001D34  784214     MOV.B [W4], W4
001D36  E84204     INC.B W4, W4
001D38  784304     MOV.B W4, W6
001D3A  20AA45     MOV #0xAA4, W5
001D3C  784A86     MOV.B W6, [W5]
001D3E  20AA44     MOV #0xAA4, W4
001D40  784214     MOV.B [W4], W4
001D42  524FE4     SUB.B W4, #0x4, [W15]
001D44  34FFF2     BRA LE, 0x1D2A
474:               		RefreshTouchInPut(i);
001D2A  20AA44     MOV #0xAA4, W4
001D2C  784214     MOV.B [W4], W4
001D2E  784004     MOV.B W4, W0
001D30  07FDF9     RCALL RefreshTouchInPut
475:               
476:               	//if(!Me.NetPanelActive)	//Se sono un touch...
477:               	if(Me.My_Address == k_Split_Master_Add)		//Se sono uno slave Master..
001D46  20BA44     MOV #0xBA4, W4
001D48  784214     MOV.B [W4], W4
001D4A  524FE1     SUB.B W4, #0x1, [W15]
001D4C  3A0002     BRA NZ, 0x1D52
478:               		Me.DefMode = Touch[0].DefMode;
001D4E  805DF4     MOV 0xBBE, W4
001D50  885C34     MOV W4, 0xB86
479:               }
001D52  FA8000     ULNK
001D54  060000     RETURN
480:               
481:               
482:               // Scrive su Touch
483:               void RefreshTouchOutPut(char TouchAddres)
484:               {
001D56  FA0014     LNK #0x14
001D58  BE9F88     MOV.D W8, [W15++]
001D5A  985720     MOV.B W0, [W14+18]
485:               	unsigned int Inverter_InCurr;
486:               	unsigned int Inverter_OutCurr;
487:               	unsigned int Inverter_MaxCurr;
488:               	unsigned int Inverter_InVolt;
489:               	unsigned int Inverter_OutVolt;
490:               	unsigned int Inverter_Max_Power_Reduce;
491:               	unsigned int Split_Exp_Valve_Perc;
492:               	unsigned int temp;
493:               	
494:               	
495:               	DataIndex = TouchAddres-Add_TouchRoom;
001D5C  90522E     MOV.B [W14+18], W4
001D5E  E94204     DEC.B W4, W4
001D60  784084     MOV.B W4, W1
001D62  20AA50     MOV #0xAA5, W0
001D64  784801     MOV.B W1, [W0]
496:               	if(Touch[DataIndex].Enable & !Touch[DataIndex].OffLine)
001D66  20AA54     MOV #0xAA5, W4
001D68  784214     MOV.B [W4], W4
001D6A  FB0204     SE W4, W4
001D6C  B92278     MUL.SU W4, #24, W4
001D6E  780204     MOV W4, W4
001D70  4202F6     ADD W4, #0x16, W5
001D72  20BAE4     MOV #0xBAE, W4
001D74  428204     ADD W5, W4, W4
001D76  780214     MOV [W4], W4
001D78  784204     MOV.B W4, W4
001D7A  624261     AND.B W4, #0x1, W4
001D7C  FB8304     ZE W4, W6
001D7E  20AA54     MOV #0xAA5, W4
001D80  784214     MOV.B [W4], W4
001D82  FB0204     SE W4, W4
001D84  B92278     MUL.SU W4, #24, W4
001D86  780204     MOV W4, W4
001D88  4202F6     ADD W4, #0x16, W5
001D8A  20BAE4     MOV #0xBAE, W4
001D8C  428204     ADD W5, W4, W4
001D8E  780214     MOV [W4], W4
001D90  D10204     LSR W4, W4
001D92  624261     AND.B W4, #0x1, W4
001D94  FB8204     ZE W4, W4
001D96  E90204     DEC W4, W4
001D98  DE224F     LSR W4, #15, W4
001D9A  630204     AND W6, W4, W4
001D9C  520FE0     SUB W4, #0x0, [W15]
001D9E  32032B     BRA Z, 0x23F6
497:               	{	
498:               		int SysError = 0;
001DA0  EB0200     CLR W4
001DA2  780F04     MOV W4, [W14]
499:               
500:               		if(EngineBox.PowerLimit != EngineBox.OldPowerLimit)				// controllo sempre l'aggionamento del limite
001DA4  805A35     MOV 0xB46, W5
001DA6  805A44     MOV 0xB48, W4
001DA8  528F84     SUB W5, W4, [W15]
001DAA  32003B     BRA Z, 0x1E22
501:               		{
502:               			Me.PowerLimit = EngineBox.PowerLimit;
001DAC  805A34     MOV 0xB46, W4
001DAE  885BD4     MOV W4, 0xB7A
503:               			Me.OldPowerLimit = EngineBox.PowerLimit;
001DB0  805A34     MOV 0xB46, W4
001DB2  885BE4     MOV W4, 0xB7C
504:               			for(i=0; i< MaxTouch; i++)										// aggiorno gli altri touch
001DB4  EB4200     CLR.B W4
001DB6  784304     MOV.B W4, W6
001DB8  20AA45     MOV #0xAA4, W5
001DBA  784A86     MOV.B W6, [W5]
001DBC  37002C     BRA 0x1E16
001E0A  20AA44     MOV #0xAA4, W4
001E0C  784214     MOV.B [W4], W4
001E0E  E84204     INC.B W4, W4
001E10  784084     MOV.B W4, W1
001E12  20AA40     MOV #0xAA4, W0
001E14  784801     MOV.B W1, [W0]
001E16  20AA44     MOV #0xAA4, W4
001E18  784214     MOV.B [W4], W4
001E1A  524FE3     SUB.B W4, #0x3, [W15]
001E1C  34FFD0     BRA LE, 0x1DBE
505:               			{	if(Touch[i].Enable)
001DBE  20AA44     MOV #0xAA4, W4
001DC0  784214     MOV.B [W4], W4
001DC2  FB0204     SE W4, W4
001DC4  B92278     MUL.SU W4, #24, W4
001DC6  780204     MOV W4, W4
001DC8  4202F6     ADD W4, #0x16, W5
001DCA  20BAE4     MOV #0xBAE, W4
001DCC  428204     ADD W5, W4, W4
001DCE  780214     MOV [W4], W4
001DD0  784204     MOV.B W4, W4
001DD2  624261     AND.B W4, #0x1, W4
001DD4  524FE0     SUB.B W4, #0x0, [W15]
001DD6  320019     BRA Z, 0x1E0A
506:               				{	/////WriteModReg (i+1, REG_TOUCH_MAX_PWR_LIMIT, EngineBox.PowerLimit);
507:               					WriteModReg (Add_TouchRoom+i, REG_TOUCH_MAX_PWR_LIMIT, EngineBox.PowerLimit);
001DD8  805A35     MOV 0xB46, W5
001DDA  20AA44     MOV #0xAA4, W4
001DDC  784214     MOV.B [W4], W4
001DDE  E84204     INC.B W4, W4
001DE0  780105     MOV W5, W2
001DE2  200201     MOV #0x20, W1
001DE4  784004     MOV.B W4, W0
001DE6  07FB99     RCALL WriteModReg
508:               					Touch[DataIndex].OldPowerLimit = Touch[DataIndex].PowerLimit;
001DE8  20AA54     MOV #0xAA5, W4
001DEA  784214     MOV.B [W4], W4
001DEC  FB0384     SE W4, W7
001DEE  20AA54     MOV #0xAA5, W4
001DF0  784214     MOV.B [W4], W4
001DF2  FB0204     SE W4, W4
001DF4  B92278     MUL.SU W4, #24, W4
001DF6  780204     MOV W4, W4
001DF8  4202E6     ADD W4, #0x6, W5
001DFA  20BAE4     MOV #0xBAE, W4
001DFC  428204     ADD W5, W4, W4
001DFE  780314     MOV [W4], W6
001E00  B93A78     MUL.SU W7, #24, W4
001E02  780284     MOV W4, W5
001E04  20BB64     MOV #0xBB6, W4
001E06  428204     ADD W5, W4, W4
001E08  780A06     MOV W6, [W4]
509:               				}
510:               			}
511:               			EngineBox.OldPowerLimit = EngineBox.PowerLimit;
001E1E  805A34     MOV 0xB46, W4
001E20  885A44     MOV W4, 0xB48
512:               		}
513:               
514:               		if(Me.Error.ClearErrReq || Me.Error.ClearDiagnosticSplitErrReq)
001E22  805D64     MOV 0xBAC, W4
001E24  620261     AND W4, #0x1, W4
001E26  520FE0     SUB W4, #0x0, [W15]
001E28  3A0005     BRA NZ, 0x1E34
001E2A  805D65     MOV 0xBAC, W5
001E2C  202004     MOV #0x200, W4
001E2E  628204     AND W5, W4, W4
001E30  520FE0     SUB W4, #0x0, [W15]
001E32  320004     BRA Z, 0x1E3C
515:               			WriteModReg (TouchAddres, REG_TOUCH_CLEAR_ERROR, 0);
001E34  EB0100     CLR W2
001E36  2005C1     MOV #0x5C, W1
001E38  90502E     MOV.B [W14+18], W0
001E3A  07FB6F     RCALL WriteModReg
516:               		
517:               		if(Me.Error.ClearSplitErrReq)
001E3C  805D65     MOV 0xBAC, W5
001E3E  201004     MOV #0x100, W4
001E40  628204     AND W5, W4, W4
001E42  520FE0     SUB W4, #0x0, [W15]
001E44  320004     BRA Z, 0x1E4E
518:               			WriteModReg (TouchAddres, REG_TOUCH_SPLIT_CLEAR_ERROR, 0);
001E46  EB0100     CLR W2
001E48  200901     MOV #0x90, W1
001E4A  90502E     MOV.B [W14+18], W0
001E4C  07FB66     RCALL WriteModReg
519:               		
520:               		// NEW v8.4.22
521:               		if(Me.My_Address == k_Split_Master_Add)								// Se sono uno slave Master...
001E4E  20BA44     MOV #0xBA4, W4
001E50  784214     MOV.B [W4], W4
001E52  524FE1     SUB.B W4, #0x1, [W15]
001E54  3A0005     BRA NZ, 0x1E60
522:               			WriteModReg (TouchAddres, REG_TOUCH_I_AM_MASTER_SPLIT, 1);		// Attivo flag su Touch per gestione Hide/View pagine riservate a MasterSlave
001E56  200012     MOV #0x1, W2
001E58  2008C1     MOV #0x8C, W1
001E5A  90502E     MOV.B [W14+18], W0
001E5C  07FB5E     RCALL WriteModReg
001E5E  370004     BRA 0x1E68
523:               		else
524:               			WriteModReg (TouchAddres, REG_TOUCH_I_AM_MASTER_SPLIT, 0);		// Dsattivo flag su Touch
001E60  EB0100     CLR W2
001E62  2008C1     MOV #0x8C, W1
001E64  90502E     MOV.B [W14+18], W0
001E66  07FB59     RCALL WriteModReg
525:               		
526:               		ReadModReg (TouchAddres, REG_TOUCH_PAGE, &(Touch[DataIndex].Current_Page));
001E68  20AA54     MOV #0xAA5, W4
001E6A  784214     MOV.B [W4], W4
001E6C  FB0204     SE W4, W4
001E6E  B92278     MUL.SU W4, #24, W4
001E70  780204     MOV W4, W4
001E72  4202EC     ADD W4, #0xC, W5
001E74  20BAE4     MOV #0xBAE, W4
001E76  428204     ADD W5, W4, W4
001E78  780104     MOV W4, W2
001E7A  200011     MOV #0x1, W1
001E7C  90502E     MOV.B [W14+18], W0
001E7E  07FAE6     RCALL ReadModReg
527:               		switch((char)Touch[DataIndex].Current_Page)
001E80  20AA54     MOV #0xAA5, W4
001E82  784214     MOV.B [W4], W4
001E84  FB0204     SE W4, W4
001E86  B92278     MUL.SU W4, #24, W4
001E88  780204     MOV W4, W4
001E8A  4202EC     ADD W4, #0xC, W5
001E8C  20BAE4     MOV #0xBAE, W4
001E8E  428204     ADD W5, W4, W4
001E90  780214     MOV [W4], W4
001E92  784204     MOV.B W4, W4
001E94  FB0204     SE W4, W4
001E96  DEA2CF     ASR W4, #15, W5
001E98  200106     MOV #0x10, W6
001E9A  200007     MOV #0x0, W7
001E9C  520F86     SUB W4, W6, [W15]
001E9E  5A8F87     SUBB W5, W7, [W15]
001EA0  3E02AA     BRA GTU, 0x23F6
001EA2  016004     BRA W4
001EA4  3702A8     BRA 0x23F6
001EA6  3702A7     BRA 0x23F6
001EA8  37000E     BRA 0x1EC6
001EAA  37001E     BRA 0x1EE8
001EAC  3702A4     BRA 0x23F6
001EAE  37003A     BRA 0x1F24
001EB0  370039     BRA 0x1F24
001EB2  370038     BRA 0x1F24
001EB4  370037     BRA 0x1F24
001EB6  370082     BRA 0x1FBC
001EB8  3700C6     BRA 0x2046
001EBA  370127     BRA 0x210A
001EBC  37022A     BRA 0x2312
001EBE  37029B     BRA 0x23F6
001EC0  370176     BRA 0x21AE
001EC2  3701E0     BRA 0x2284
001EC4  370226     BRA 0x2312
528:               		{
529:               			case 0:		// pagina 0 -> Wait system initializing
530:               				break;
531:               
532:               			case 2:		// pagina 2 -> Home
533:               				InsertReg(1, Me.Temp_Amb);						// REG_TOUCH_ROOM_TEMP
001EC6  805B64     MOV Me, W4
001EC8  780084     MOV W4, W1
001ECA  B3C010     MOV.B #0x1, W0
001ECC  07FC61     RCALL InsertReg
534:               				InsertReg(2, EngineBox.Compressor_Speed);		// REG_TOUCH_POWER_MOT
001ECE  805A04     MOV 0xB40, W4
001ED0  780084     MOV W4, W1
001ED2  B3C020     MOV.B #0x2, W0
001ED4  07FC5D     RCALL InsertReg
535:               				InsertReg(3, EngineBox.Errori2);				// REG_TOUCH_CUMULATIVE_ALARM
001ED6  805B04     MOV 0xB60, W4
001ED8  780084     MOV W4, W1
001EDA  B3C030     MOV.B #0x3, W0
001EDC  07FC59     RCALL InsertReg
536:               				WriteModListReg (TouchAddres, REG_TOUCH_ROOM_TEMP, 3);
001EDE  200032     MOV #0x3, W2
001EE0  200101     MOV #0x10, W1
001EE2  90502E     MOV.B [W14+18], W0
001EE4  07FB45     RCALL WriteModListReg
537:               				break;
001EE6  370287     BRA 0x23F6
538:               
539:               			case 3:		// pagina 3 -> Power Manager
540:               				// Calcolo potenza limitata in centesimi di Kw partendo da % slider (Touch[0].PowerLimit) ceh è in scala 0...255
541:               				// solo per visualizzazione su Touch
542:               				//							0..255					Watt
543:               				Inverter_Max_Power_Reduce = (unsigned int)((float)Touch[0].PowerLimit/2.55 * (float)K_Power_Inverter/1000.0) ;
001EE8  805DA4     MOV 0xBB4, W4
001EEA  DEA2CF     ASR W4, #15, W5
001EEC  BE0004     MOV.D W4, W0
001EEE  07F2E7     RCALL ___floatsisf
001EF0  BE0200     MOV.D W0, W4
001EF2  233332     MOV #0x3333, W2
001EF4  240233     MOV #0x4023, W3
001EF6  BE0004     MOV.D W4, W0
001EF8  07F260     RCALL ___divsf3
001EFA  BE0200     MOV.D W0, W4
001EFC  200002     MOV #0x0, W2
001EFE  2457A3     MOV #0x457A, W3
001F00  BE0004     MOV.D W4, W0
001F02  07F38C     RCALL ___mulsf3
001F04  BE0200     MOV.D W0, W4
001F06  200002     MOV #0x0, W2
001F08  2447A3     MOV #0x447A, W3
001F0A  BE0004     MOV.D W4, W0
001F0C  07F256     RCALL ___divsf3
001F0E  BE0200     MOV.D W0, W4
001F10  BE0004     MOV.D W4, W0
001F12  07F2BA     RCALL ___fixunssfsi
001F14  BE0200     MOV.D W0, W4
001F16  980714     MOV W4, [W14+2]
544:               				WriteModReg (TouchAddres, REG_TOUCH_MAX_POWER_REDUCE, Inverter_Max_Power_Reduce);		
001F18  90021E     MOV [W14+2], W4
001F1A  780104     MOV W4, W2
001F1C  2008D1     MOV #0x8D, W1
001F1E  90502E     MOV.B [W14+18], W0
001F20  07FAFC     RCALL WriteModReg
545:               
546:               				break;			
001F22  370269     BRA 0x23F6
547:               
548:               			case 4:			// pagina 4 -> Service Login	// Ex. Pag.4
549:               				break;
550:               			case 5:			// pagina 5 -> Faults1
551:               			case 6:			// pagina 6 -> Faults2
552:               			case 7:			// pagina 7 -> Faults3				
553:               			case 8:			// pagina 8 -> Faults4			// Ex. Pag. 8
554:               				
555:               				EngineBox.Errori3 = (EngineBox.Errori3 & 0x00FF);
001F24  805B15     MOV 0xB62, W5
001F26  200FF4     MOV #0xFF, W4
001F28  628204     AND W5, W4, W4
001F2A  885B14     MOV W4, 0xB62
556:               				if(Me.Error.Battery_Defrost)		// aggiungo gli errori dello split
001F2C  805D64     MOV 0xBAC, W4
001F2E  620262     AND W4, #0x2, W4
001F30  520FE0     SUB W4, #0x0, [W15]
001F32  320004     BRA Z, 0x1F3C
557:               					EngineBox.Errori3 = (EngineBox.Errori3 | 0x0400);
001F34  805B15     MOV 0xB62, W5
001F36  204004     MOV #0x400, W4
001F38  720205     IOR W4, W5, W4
001F3A  885B14     MOV W4, 0xB62
558:               				if(Me.Error.EEV_Open)
001F3C  805D64     MOV 0xBAC, W4
001F3E  620264     AND W4, #0x4, W4
001F40  520FE0     SUB W4, #0x0, [W15]
001F42  320004     BRA Z, 0x1F4C
559:               					EngineBox.Errori3 = (EngineBox.Errori3 | 0x0800);
001F44  805B15     MOV 0xB62, W5
001F46  208004     MOV #0x800, W4
001F48  720205     IOR W4, W5, W4
001F4A  885B14     MOV W4, 0xB62
560:               				if(Me.Error.EEV_Close)
001F4C  805D64     MOV 0xBAC, W4
001F4E  620268     AND W4, #0x8, W4
001F50  520FE0     SUB W4, #0x0, [W15]
001F52  320004     BRA Z, 0x1F5C
561:               					EngineBox.Errori3 = (EngineBox.Errori3 | 0x1000);
001F54  805B15     MOV 0xB62, W5
001F56  210004     MOV #0x1000, W4
001F58  720205     IOR W4, W5, W4
001F5A  885B14     MOV W4, 0xB62
562:               				if(Me.Error.BatteriaGhiacciata)
001F5C  805D64     MOV 0xBAC, W4
001F5E  620270     AND W4, #0x10, W4
001F60  520FE0     SUB W4, #0x0, [W15]
001F62  320004     BRA Z, 0x1F6C
563:               					EngineBox.Errori3 = (EngineBox.Errori3 | 0x2000);
001F64  805B15     MOV 0xB62, W5
001F66  220004     MOV #0x2000, W4
001F68  720205     IOR W4, W5, W4
001F6A  885B14     MOV W4, 0xB62
564:               				if(Me.Error.Fan_Fault)
001F6C  805D65     MOV 0xBAC, W5
001F6E  200204     MOV #0x20, W4
001F70  628204     AND W5, W4, W4
001F72  520FE0     SUB W4, #0x0, [W15]
001F74  320004     BRA Z, 0x1F7E
565:               					EngineBox.Errori3 = (EngineBox.Errori3 | 0x4000);
001F76  805B15     MOV 0xB62, W5
001F78  240004     MOV #0x4000, W4
001F7A  720205     IOR W4, W5, W4
001F7C  885B14     MOV W4, 0xB62
566:               				if(Me.Error.Fan_OverLoad)
001F7E  805D65     MOV 0xBAC, W5
001F80  200404     MOV #0x40, W4
001F82  628204     AND W5, W4, W4
001F84  520FE0     SUB W4, #0x0, [W15]
001F86  320004     BRA Z, 0x1F90
567:               					EngineBox.Errori3 = (EngineBox.Errori3 | 0x8000);
001F88  805B15     MOV 0xB62, W5
001F8A  280004     MOV #0x8000, W4
001F8C  720205     IOR W4, W5, W4
001F8E  885B14     MOV W4, 0xB62
568:               
569:               				InsertReg(1, EngineBox.Errori1);					// REG_TOUCH_SYS_ERROR_1
001F90  805AF4     MOV 0xB5E, W4
001F92  780084     MOV W4, W1
001F94  B3C010     MOV.B #0x1, W0
001F96  07FBFC     RCALL InsertReg
570:               				InsertReg(2, EngineBox.Errori2);					// REG_TOUCH_SYS_ERROR_2
001F98  805B04     MOV 0xB60, W4
001F9A  780084     MOV W4, W1
001F9C  B3C020     MOV.B #0x2, W0
001F9E  07FBF8     RCALL InsertReg
571:               				InsertReg(3, EngineBox.Errori3);					// REG_TOUCH_SYS_ERROR_3
001FA0  805B14     MOV 0xB62, W4
001FA2  780084     MOV W4, W1
001FA4  B3C030     MOV.B #0x3, W0
001FA6  07FBF4     RCALL InsertReg
572:               				WriteModListReg (TouchAddres, REG_TOUCH_SYS_ERROR_1, 3);
001FA8  200032     MOV #0x3, W2
001FAA  200431     MOV #0x43, W1
001FAC  90502E     MOV.B [W14+18], W0
001FAE  07FAE0     RCALL WriteModListReg
573:               				
574:               				WriteModReg (TouchAddres, REG_TOUCH_SPLIT_STATUS, DiagnosticSplit.SplitStatus);
001FB0  807154     MOV 0xE2A, W4
001FB2  780104     MOV W4, W2
001FB4  2007B1     MOV #0x7B, W1
001FB6  90502E     MOV.B [W14+18], W0
001FB8  07FAB0     RCALL WriteModReg
575:               				break;
001FBA  37021D     BRA 0x23F6
576:               
577:               			case 9:			// pagina 9 -> Diagnostica Box motore	// Ex. Pag.9
578:               
579:               				InsertReg(1, EngineBox.HoursOfLife);				// REG_TOUCH_HOURS_OF_LIFE v8.4.16 -> invio ore di vita unita master x diagnostica
001FBC  805B54     MOV 0xB6A, W4
001FBE  780084     MOV W4, W1
001FC0  B3C010     MOV.B #0x1, W0
001FC2  07FBE6     RCALL InsertReg
580:               				InsertReg(2, EngineBox.Temp_Mandata);				// REG_TOUCH_MANDATA_COMPRESSORE
001FC4  805944     MOV EngineBox, W4
001FC6  780084     MOV W4, W1
001FC8  B3C020     MOV.B #0x2, W0
001FCA  07FBE2     RCALL InsertReg
581:               				InsertReg(3, EngineBox.Temp_Ritorno);				// REG_TOUCH_RITORNO_COMPRESSORE
001FCC  805954     MOV 0xB2A, W4
001FCE  780084     MOV W4, W1
001FD0  B3C030     MOV.B #0x3, W0
001FD2  07FBDE     RCALL InsertReg
582:               				InsertReg(4, EngineBox.Temp_Condensatore);			// REG_TOUCH_TEMP_CONDENSATORE
001FD4  805964     MOV 0xB2C, W4
001FD6  780084     MOV W4, W1
001FD8  B3C040     MOV.B #0x4, W0
001FDA  07FBDA     RCALL InsertReg
583:               				InsertReg(5, EngineBox.Temp_Acqua_Mare);			// REG_TOUCH_SEA_WATER_IN_TEMP
001FDC  805974     MOV 0xB2E, W4
001FDE  780084     MOV W4, W1
001FE0  B3C050     MOV.B #0x5, W0
001FE2  07FBD6     RCALL InsertReg
584:               				InsertReg(6, EngineBox.Pressione_Liq_P);			// REG_TOUCH_PRESSIONE_P
001FE4  8059B4     MOV 0xB36, W4
001FE6  780084     MOV W4, W1
001FE8  B3C060     MOV.B #0x6, W0
001FEA  07FBD2     RCALL InsertReg
585:               				InsertReg(7, EngineBox.Pressione_Gas_G);			// REG_TOUCH_PRESSIONE_G
001FEC  8059A4     MOV 0xB34, W4
001FEE  780084     MOV W4, W1
001FF0  B3C070     MOV.B #0x7, W0
001FF2  07FBCE     RCALL InsertReg
586:               				InsertReg(8, EngineBox.Compressor_Speed);			// REG_TOUCH_COMPRESSOR_SPEED
001FF4  805A04     MOV 0xB40, W4
001FF6  780084     MOV W4, W1
001FF8  B3C080     MOV.B #0x8, W0
001FFA  07FBCA     RCALL InsertReg
587:               				//InsertReg(9, EngineBox.Pressure_Req);			// REG_TOUCH_TEMP_RICHIESTA
588:               				InsertReg(10, EngineBox.Ric_Pressione);				// REG_TOUCH_PRESSIONE_RICHIESTA
001FFC  8059F4     MOV 0xB3E, W4
001FFE  780084     MOV W4, W1
002000  B3C0A0     MOV.B #0xA, W0
002002  07FBC6     RCALL InsertReg
589:               				InsertReg(11, EngineBox.StatoCompressore);			// REG_TOUCH_STATO_COMPRESSORE
002004  20B4C4     MOV #0xB4C, W4
002006  784214     MOV.B [W4], W4
002008  FB0204     SE W4, W4
00200A  780084     MOV W4, W1
00200C  B3C0B0     MOV.B #0xB, W0
00200E  07FBC0     RCALL InsertReg
590:               				InsertReg(12, EngineBox.FunctionMode);				// REG_TOUCH_ENGENIE_BOX_MODE
002010  805A54     MOV 0xB4A, W4
002012  780084     MOV W4, W1
002014  B3C0C0     MOV.B #0xC, W0
002016  07FBBC     RCALL InsertReg
591:               				InsertReg(13, EngineBox.IdMasterSplit);			// REG_TOUCH_MASTER_SPLIT
002018  20B4D4     MOV #0xB4D, W4
00201A  784214     MOV.B [W4], W4
00201C  FB0204     SE W4, W4
00201E  780084     MOV W4, W1
002020  B3C0D0     MOV.B #0xD, W0
002022  07FBB6     RCALL InsertReg
592:               				//Saltare locazione 14 per clear error in posizione // REG_TOUCH_CLEAR_ERROR				0x005C
593:               				InsertReg(15, EngineBox.Temp_Collettore_Piccolo);	// REG_TOUCH_TEMP_P
002024  805994     MOV 0xB32, W4
002026  780084     MOV W4, W1
002028  B3C0F0     MOV.B #0xF, W0
00202A  07FBB2     RCALL InsertReg
594:               				InsertReg(16, EngineBox.Temp_Collettore_Grande);	// REG_TOUCH_TEMP_G
00202C  805984     MOV 0xB30, W4
00202E  780084     MOV W4, W1
002030  B3C100     MOV.B #0x10, W0
002032  07FBAE     RCALL InsertReg
595:               				InsertReg(17, EngineBox.SystemCycleTime);			// REG_TOUCH_SYSTEM_CYCLE_TIME v8.4.16 -> invio tempo di ciclo unita master x diagnostica
002034  805B44     MOV 0xB68, W4
002036  780084     MOV W4, W1
002038  B3C110     MOV.B #0x11, W0
00203A  07FBAA     RCALL InsertReg
596:               				WriteModListReg (TouchAddres, REG_TOUCH_HOURS_OF_LIFE, 17);
00203C  200112     MOV #0x11, W2
00203E  2004F1     MOV #0x4F, W1
002040  90502E     MOV.B [W14+18], W0
002042  07FA96     RCALL WriteModListReg
597:               
598:               /*
599:               				InsertReg(1, EngineBox.Temp_Mandata);				// REG_TOUCH_MANDATA_COMPRESSORE
600:               				InsertReg(2, EngineBox.Temp_Ritorno);				// REG_TOUCH_RITORNO_COMPRESSORE
601:               				InsertReg(3, EngineBox.Temp_Condensatore);			// REG_TOUCH_TEMP_CONDENSATORE
602:               				InsertReg(4, EngineBox.Temp_Acqua_Mare);			// REG_TOUCH_SEA_WATER_IN_TEMP
603:               				InsertReg(5, EngineBox.Pressione_Liq_P);			// REG_TOUCH_PRESSIONE_P
604:               				InsertReg(6, EngineBox.Pressione_Gas_G);			// REG_TOUCH_PRESSIONE_G
605:               				InsertReg(7, EngineBox.Compressor_Speed);			// REG_TOUCH_COMPRESSOR_SPEED
606:               				WriteModListReg (TouchAddres, REG_TOUCH_MANDATA_COMPRESSORE, 7);
607:               				//InsertReg(8, EngineBox.Pressure_Req);			// REG_TOUCH_TEMP_RICHIESTA
608:               			
609:               				InsertReg(1, EngineBox.Ric_Pressione);				// REG_TOUCH_PRESSIONE_RICHIESTA
610:               				InsertReg(2, EngineBox.StatoCompressore);			// REG_TOUCH_STATO_COMPRESSORE
611:               				InsertReg(3, EngineBox.FunctionMode);				// REG_TOUCH_ENGENIE_BOX_MODE
612:               				InsertReg(4, EngineBox.IdMasterSplit);				// REG_TOUCH_MASTER_SPLIT
613:               				//Saltare locazione 13 per clear error in posizione // REG_TOUCH_CLEAR_ERROR				0x005C
614:               				InsertReg(6, EngineBox.Temp_Collettore_Piccolo);	// REG_TOUCH_TEMP_P
615:               				InsertReg(7, EngineBox.Temp_Collettore_Grande);	// REG_TOUCH_TEMP_G
616:               				//InsertReg(8, EngineBox.SystemCycleTime);			// REG_TOUCH_SYSTEM_CYCLE_TIME v8.4.16 -> invio tempo di ciclo unita master x diagnistica
617:               				InsertReg(8, temp++);
618:               				WriteModListReg (TouchAddres, REG_TOUCH_PRESSIONE_RICHIESTA, 8);
619:               */			
620:               				break;
002044  3701D8     BRA 0x23F6
621:               
622:               			case 10:		// pagina 10 -> Diagnostica Room 1	// Ex. Pag.10
623:               				// Calcolo percentuale apertura valvola 0..100%
624:               				temp = ValvolaAperta;
002046  203C04     MOV #0x3C0, W4
002048  980724     MOV W4, [W14+4]
625:               				Split_Exp_Valve_Perc = (unsigned int)( ((float)Me.ExpValve_Act / (float)temp) * 100.0); 
00204A  805CC4     MOV 0xB98, W4
00204C  DEA2CF     ASR W4, #15, W5
00204E  BE0004     MOV.D W4, W0
002050  07F236     RCALL ___floatsisf
002052  BE0400     MOV.D W0, W8
002054  90022E     MOV [W14+4], W4
002056  200005     MOV #0x0, W5
002058  BE0004     MOV.D W4, W0
00205A  07F234     RCALL ___floatunsisf
00205C  BE0200     MOV.D W0, W4
00205E  BE0104     MOV.D W4, W2
002060  BE0008     MOV.D W8, W0
002062  07F1AB     RCALL ___divsf3
002064  BE0200     MOV.D W0, W4
002066  200002     MOV #0x0, W2
002068  242C83     MOV #0x42C8, W3
00206A  BE0004     MOV.D W4, W0
00206C  07F2D7     RCALL ___mulsf3
00206E  BE0200     MOV.D W0, W4
002070  BE0004     MOV.D W4, W0
002072  07F20A     RCALL ___fixunssfsi
002074  BE0200     MOV.D W0, W4
002076  980734     MOV W4, [W14+6]
626:               				
627:               				InsertReg(1, Me.Temp_Small);				// REG_TOUCH_PICCOLO_SPLIT_1
002078  805B94     MOV 0xB72, W4
00207A  780084     MOV W4, W1
00207C  B3C010     MOV.B #0x1, W0
00207E  07FB88     RCALL InsertReg
628:               				InsertReg(2, Me.Temp_Big);					// REG_TOUCH_GRANDE_SPLIT_1
002080  805B84     MOV 0xB70, W4
002082  780084     MOV W4, W1
002084  B3C020     MOV.B #0x2, W0
002086  07FB84     RCALL InsertReg
629:               				InsertReg(3, Me.Temp_Amb);					// REG_TOUCH_ARIA_INGRESSO_SPLIT_1
002088  805B64     MOV Me, W4
00208A  780084     MOV W4, W1
00208C  B3C030     MOV.B #0x3, W0
00208E  07FB80     RCALL InsertReg
630:               				InsertReg(4, Me.Temp_AirOut);				// REG_TOUCH_ARIA_USCITA_SPLIT_1
002090  805B74     MOV 0xB6E, W4
002092  780084     MOV W4, W1
002094  B3C040     MOV.B #0x4, W0
002096  07FB7C     RCALL InsertReg
631:               				InsertReg(5, Me.Fan_Tacho);					// REG_TOUCH_VENTILATORE_SPLIT_1
002098  805C94     MOV 0xB92, W4
00209A  780084     MOV W4, W1
00209C  B3C050     MOV.B #0x5, W0
00209E  07FB78     RCALL InsertReg
632:               				//InsertReg(6, Me.ExpValve_Act);				// REG_TOUCH_STATO_VALVOLA_SPLIT_1
633:               				InsertReg(6, Split_Exp_Valve_Perc);				// REG_TOUCH_STATO_VALVOLA_SPLIT_1
0020A0  90023E     MOV [W14+6], W4
0020A2  780084     MOV W4, W1
0020A4  B3C060     MOV.B #0x6, W0
0020A6  07FB74     RCALL InsertReg
634:               				
635:               				InsertReg(7, Me.Pres_Big);					// REG_TOUCH_PRESSIONE_G_SPLIT_1
0020A8  805BA4     MOV 0xB74, W4
0020AA  780084     MOV W4, W1
0020AC  B3C070     MOV.B #0x7, W0
0020AE  07FB70     RCALL InsertReg
636:               				InsertReg(8, Me.Pres_Small);				// REG_TOUCH_PRESSIONE_P_SPLIT_1
0020B0  805BB4     MOV 0xB76, W4
0020B2  780084     MOV W4, W1
0020B4  B3C080     MOV.B #0x8, W0
0020B6  07FB6C     RCALL InsertReg
637:               				InsertReg(9, Me.Evap_Temp);					// REG_TOUCH_TEMP_EVAP_SPLIT_1
0020B8  805BF4     MOV 0xB7E, W4
0020BA  780084     MOV W4, W1
0020BC  B3C090     MOV.B #0x9, W0
0020BE  07FB68     RCALL InsertReg
638:               				InsertReg(10, Me.Evap_Press);				// REG_TOUCH_RICH_PRESSIONE_SPLIT_1
0020C0  805C04     MOV 0xB80, W4
0020C2  780084     MOV W4, W1
0020C4  B3C0A0     MOV.B #0xA, W0
0020C6  07FB64     RCALL InsertReg
639:               				InsertReg(11, EngineBox.FunctionMode);		// REG_TOUCH_ENGENIE_BOX_MODE_SPLIT_1
0020C8  805A54     MOV 0xB4A, W4
0020CA  780084     MOV W4, W1
0020CC  B3C0B0     MOV.B #0xB, W0
0020CE  07FB60     RCALL InsertReg
640:               				InsertReg(12, Me.CycleTime);				// REG_TOUCH_CYCLE_TIME_SPLIT_1
0020D0  805D04     MOV 0xBA0, W4
0020D2  780084     MOV W4, W1
0020D4  B3C0C0     MOV.B #0xC, W0
0020D6  07FB5C     RCALL InsertReg
641:               				WriteModListReg (TouchAddres, REG_TOUCH_PICCOLO_SPLIT_1, 12);
0020D8  2000C2     MOV #0xC, W2
0020DA  200601     MOV #0x60, W1
0020DC  90502E     MOV.B [W14+18], W0
0020DE  07FA48     RCALL WriteModListReg
642:                               
643:                               InsertReg(1, Me.T_Big_Request);                         // REG_TOUCH_SUPERHEAT
0020E0  805D54     MOV 0xBAA, W4
0020E2  780084     MOV W4, W1
0020E4  B3C010     MOV.B #0x1, W0
0020E6  07FB54     RCALL InsertReg
644:                               //InsertReg(2, (int)(ValvePID.VKiPID*1000)); //DEBUG
645:                               //InsertReg(3, (int)(ValvePID.VKdPID*100));//DEBUG
646:               				InsertReg(2, Me.Pwm_Req); //DEBUG
0020E8  805C74     MOV 0xB8E, W4
0020EA  780084     MOV W4, W1
0020EC  B3C020     MOV.B #0x2, W0
0020EE  07FB50     RCALL InsertReg
647:                               InsertReg(3, Me.Fan_MaxSpeed);//DEBUG
0020F0  805C64     MOV 0xB8C, W4
0020F2  780084     MOV W4, W1
0020F4  B3C030     MOV.B #0x3, W0
0020F6  07FB4C     RCALL InsertReg
648:               				
649:                               InsertReg(4, Me.CntValveFault);  				
0020F8  805CD4     MOV 0xB9A, W4
0020FA  780084     MOV W4, W1
0020FC  B3C040     MOV.B #0x4, W0
0020FE  07FB48     RCALL InsertReg
650:                               WriteModListReg (TouchAddres, REG_TOUCH_SUPERHEAT, 4);
002100  200042     MOV #0x4, W2
002102  200881     MOV #0x88, W1
002104  90502E     MOV.B [W14+18], W0
002106  07FA34     RCALL WriteModListReg
651:                               
652:               				
653:               				break;
002108  370176     BRA 0x23F6
654:               
655:               			case 11:		// pagina 11 -> Diagnostic  Split	//Ex.Pag.11 		#v16
656:               				// Calcolo percentuale apertura valvola 0..100%
657:               				temp = ValvolaAperta;
00210A  203C04     MOV #0x3C0, W4
00210C  980724     MOV W4, [W14+4]
658:               				Split_Exp_Valve_Perc = (unsigned int)((float)DiagnosticSplit.Exp_Valve / (float)temp * 100.0); 
00210E  8071B4     MOV 0xE36, W4
002110  DEA2CF     ASR W4, #15, W5
002112  BE0004     MOV.D W4, W0
002114  07F1D4     RCALL ___floatsisf
002116  BE0400     MOV.D W0, W8
002118  90022E     MOV [W14+4], W4
00211A  200005     MOV #0x0, W5
00211C  BE0004     MOV.D W4, W0
00211E  07F1D2     RCALL ___floatunsisf
002120  BE0200     MOV.D W0, W4
002122  BE0104     MOV.D W4, W2
002124  BE0008     MOV.D W8, W0
002126  07F149     RCALL ___divsf3
002128  BE0200     MOV.D W0, W4
00212A  200002     MOV #0x0, W2
00212C  242C83     MOV #0x42C8, W3
00212E  BE0004     MOV.D W4, W0
002130  07F275     RCALL ___mulsf3
002132  BE0200     MOV.D W0, W4
002134  BE0004     MOV.D W4, W0
002136  07F1A8     RCALL ___fixunssfsi
002138  BE0200     MOV.D W0, W4
00213A  980734     MOV W4, [W14+6]
659:               				
660:               				InsertReg(1, DiagnosticSplit.Temp_Liq);					// REG_TOUCH_SPLIT_LIQ_TEMP
00213C  807174     MOV 0xE2E, W4
00213E  780084     MOV W4, W1
002140  B3C010     MOV.B #0x1, W0
002142  07FB26     RCALL InsertReg
661:               				InsertReg(2, DiagnosticSplit.Temp_Gas);					// REG_TOUCH_SPLIT_GAS_TEMP
002144  807164     MOV 0xE2C, W4
002146  780084     MOV W4, W1
002148  B3C020     MOV.B #0x2, W0
00214A  07FB22     RCALL InsertReg
662:               				InsertReg(3, DiagnosticSplit.Temp_AirIn);				// REG_TOUCH_SPLIT_AIR_IN
00214C  807194     MOV 0xE32, W4
00214E  780084     MOV W4, W1
002150  B3C030     MOV.B #0x3, W0
002152  07FB1E     RCALL InsertReg
663:               				InsertReg(4, DiagnosticSplit.Temp_AirOut);				// REG_TOUCH_SPLIT_AIR_OUT
002154  807184     MOV 0xE30, W4
002156  780084     MOV W4, W1
002158  B3C040     MOV.B #0x4, W0
00215A  07FB1A     RCALL InsertReg
664:               				InsertReg(5, DiagnosticSplit.FanSpeed);					// REG_TOUCH_SPLIT_FAN_SPEED
00215C  8071A4     MOV 0xE34, W4
00215E  780084     MOV W4, W1
002160  B3C050     MOV.B #0x5, W0
002162  07FB16     RCALL InsertReg
665:               				//InsertReg(6, DiagnosticSplit.Exp_Valve);				// REG_TOUCH_SPLIT_EXP_VALVE
666:               				InsertReg(6, Split_Exp_Valve_Perc);				// REG_TOUCH_SPLIT_EXP_VALVE
002164  90023E     MOV [W14+6], W4
002166  780084     MOV W4, W1
002168  B3C060     MOV.B #0x6, W0
00216A  07FB12     RCALL InsertReg
667:               				InsertReg(7, DiagnosticSplit.Gas_Pressure);				// REG_TOUCH_SPLIT_GAS_PRESSURE
00216C  8071C4     MOV 0xE38, W4
00216E  780084     MOV W4, W1
002170  B3C070     MOV.B #0x7, W0
002172  07FB0E     RCALL InsertReg
668:               				InsertReg(8, DiagnosticSplit.Liq_Pressure);				// REG_TOUCH_SPLIT_LIQ_PRESSURE
002174  8071D4     MOV 0xE3A, W4
002176  780084     MOV W4, W1
002178  B3C080     MOV.B #0x8, W0
00217A  07FB0A     RCALL InsertReg
669:               				InsertReg(9, DiagnosticSplit.Req_AirTemp);				// REG_TOUCH_SPLIT_REQUEST_AIR_TEMP
00217C  8071E4     MOV 0xE3C, W4
00217E  780084     MOV W4, W1
002180  B3C090     MOV.B #0x9, W0
002182  07FB06     RCALL InsertReg
670:               				InsertReg(10, DiagnosticSplit.Req_Pressure);			// REG_TOUCH_SPLIT_REQUEST_AIR_PRES
002184  8071F4     MOV 0xE3E, W4
002186  780084     MOV W4, W1
002188  B3C0A0     MOV.B #0xA, W0
00218A  07FB02     RCALL InsertReg
671:               				InsertReg(11, DiagnosticSplit.Split_Eng_Mode);			// REG_TOUCH_SPLIT_ENG_MODE
00218C  807204     MOV 0xE40, W4
00218E  780084     MOV W4, W1
002190  B3C0B0     MOV.B #0xB, W0
002192  07FAFE     RCALL InsertReg
672:               				InsertReg(12, DiagnosticSplit.SplitStatus);				// REG_TOUCH_SPLIT_STATUS
002194  807154     MOV 0xE2A, W4
002196  780084     MOV W4, W1
002198  B3C0C0     MOV.B #0xC, W0
00219A  07FAFA     RCALL InsertReg
673:               				InsertReg(13, DiagnosticSplit.CycleTime);				// REG_TOUCH_SPLIT_TEST_CYCLE_TIME				
00219C  807224     MOV 0xE44, W4
00219E  780084     MOV W4, W1
0021A0  B3C0D0     MOV.B #0xD, W0
0021A2  07FAF6     RCALL InsertReg
674:               				WriteModListReg (TouchAddres, REG_TOUCH_SPLIT_LIQ_TEMP, 13);
0021A4  2000D2     MOV #0xD, W2
0021A6  200701     MOV #0x70, W1
0021A8  90502E     MOV.B [W14+18], W0
0021AA  07F9E2     RCALL WriteModListReg
675:               				break;	
0021AC  370124     BRA 0x23F6
676:               
677:               /*			Spostato insieme al case 16 (Nuova pagina "Power Monitor")
678:               			case 12:		// pagina 15 -> Diagnostic Inverter data			//Ex.Pag.12
679:               				InsertReg(1, DiagnosticInverter.Alarm);					// REG_TOUCH_INVERTER_ALARM
680:               				InsertReg(2, DiagnosticInverter.OutFreq);				// REG_TOUCH_INVERTER_OUT_FREQ	
681:               				InsertReg(3, DiagnosticInverter.Status);				// REG_TOUCH_INVERTER_STATUS
682:               				InsertReg(4, DiagnosticInverter.OutCurr);				// REG_TOUCH_INVERTER_OUT_CURR
683:               				InsertReg(5, DiagnosticInverter.InVolt);				// REG_TOUCH_INVERTER_IN_VOLT
684:               				InsertReg(6, DiagnosticInverter.OutVolt);				// REG_TOUCH_INVERTER_OUT_VOLT
685:               				InsertReg(7, DiagnosticInverter.InPower);				// REG_TOUCH_INVERTER_IN_POWER
686:               				InsertReg(8, DiagnosticInverter.OutPower);				// REG_TOUCH_INVERTER_OUT_POWER
687:               				InsertReg(9, DiagnosticInverter.ReqFreq);				// REG_TOUCH_INVERTER_REQ_FREQ
688:               				InsertReg(10, DiagnosticInverter.MaxReqFreq);			// REG_TOUCH_INVERTER_MAX_REQ_FREQ
689:               				WriteModListReg (TouchAddres, REG_TOUCH_INVERTER_ALARM, 10);
690:               				break;	
691:               */				
692:               			case 13:		// pagina 13-> VNC
693:               				break;				
694:               				
695:               			case 14:		// pagina 14-> Air Handler Detail					
696:               				WriteModReg (TouchAddres, REG_TOUCH_PWR, Touch[0].Script_Split_Pwr);		//	Pwr	2	
0021AE  805E04     MOV 0xBC0, W4
0021B0  780104     MOV W4, W2
0021B2  200021     MOV #0x2, W1
0021B4  90502E     MOV.B [W14+18], W0
0021B6  07F9B1     RCALL WriteModReg
697:               						
698:               				InsertReg(1, EngineBox.Temp_Mandata);					//	REG_TOUCH_MANDATA_COMPRESSORE	Mandata_compressore			80
0021B8  805944     MOV EngineBox, W4
0021BA  780084     MOV W4, W1
0021BC  B3C010     MOV.B #0x1, W0
0021BE  07FAE8     RCALL InsertReg
699:               				InsertReg(2, EngineBox.Temp_Ritorno);					//	REG_TOUCH_RITORNO_COMPRESSORE	Ritorno_compressore			81
0021C0  805954     MOV 0xB2A, W4
0021C2  780084     MOV W4, W1
0021C4  B3C020     MOV.B #0x2, W0
0021C6  07FAE4     RCALL InsertReg
700:               				InsertReg(3, EngineBox.Temp_Condensatore);				//	REG_TOUCH_TEMP_CONDENSATORE		Temp_condensatore			82
0021C8  805964     MOV 0xB2C, W4
0021CA  780084     MOV W4, W1
0021CC  B3C030     MOV.B #0x3, W0
0021CE  07FAE0     RCALL InsertReg
701:               				InsertReg(4, EngineBox.Temp_Acqua_Mare);				//	REG_TOUCH_SEA_WATER_IN_TEMP		Sea_Water_Temp				83	
0021D0  805974     MOV 0xB2E, W4
0021D2  780084     MOV W4, W1
0021D4  B3C040     MOV.B #0x4, W0
0021D6  07FADC     RCALL InsertReg
702:               				InsertReg(5, EngineBox.Pressione_Liq_P);				//	REG_TOUCH_PRESSIONE_P			Pressione_P					84
0021D8  8059B4     MOV 0xB36, W4
0021DA  780084     MOV W4, W1
0021DC  B3C050     MOV.B #0x5, W0
0021DE  07FAD8     RCALL InsertReg
703:               				InsertReg(6, EngineBox.Pressione_Gas_G);				//	REG_TOUCH_PRESSIONE_G			Pressione_G					85						
0021E0  8059A4     MOV 0xB34, W4
0021E2  780084     MOV W4, W1
0021E4  B3C060     MOV.B #0x6, W0
0021E6  07FAD4     RCALL InsertReg
704:               				InsertReg(7, EngineBox.Compressor_Speed);				//	REG_TOUCH_COMPRESSOR_SPEED		Pwr_Mot_Diagnostic			86
0021E8  805A04     MOV 0xB40, W4
0021EA  780084     MOV W4, W1
0021EC  B3C070     MOV.B #0x7, W0
0021EE  07FAD0     RCALL InsertReg
705:               				WriteModListReg (TouchAddres, REG_TOUCH_MANDATA_COMPRESSORE, 7);		
0021F0  200072     MOV #0x7, W2
0021F2  200501     MOV #0x50, W1
0021F4  90502E     MOV.B [W14+18], W0
0021F6  07F9BC     RCALL WriteModListReg
706:               						
707:               						
708:               				InsertReg(1, EngineBox.Temp_Collettore_Piccolo);		//	REG_TOUCH_TEMP_P				Temp_Tubo_Piccolo_Liquido	93
0021F8  805994     MOV 0xB32, W4
0021FA  780084     MOV W4, W1
0021FC  B3C010     MOV.B #0x1, W0
0021FE  07FAC8     RCALL InsertReg
709:               				InsertReg(2, EngineBox.Temp_Collettore_Grande);					//	REG_TOUCH_TEMP_G				Temp_Tubo_Grande_Gas		94
002200  805984     MOV 0xB30, W4
002202  780084     MOV W4, W1
002204  B3C020     MOV.B #0x2, W0
002206  07FAC4     RCALL InsertReg
710:               				WriteModListReg (TouchAddres, REG_TOUCH_TEMP_P, 2);		
002208  200022     MOV #0x2, W2
00220A  2005D1     MOV #0x5D, W1
00220C  90502E     MOV.B [W14+18], W0
00220E  07F9B0     RCALL WriteModListReg
711:               
712:               				// Estrapolazione stato rele pompa e stato Test di flusso da "Errori1"
713:               				temp = (1*(((EngineBox.ReleSt & 0x0004)!=0) && !((EngineBox.Errori1 & 0x0020)!=0))) | 
002210  805AE4     MOV 0xB5C, W4
002212  620264     AND W4, #0x4, W4
002214  520FE0     SUB W4, #0x0, [W15]
002216  320007     BRA Z, 0x2226
002218  805AF5     MOV 0xB5E, W5
00221A  200204     MOV #0x20, W4
00221C  628204     AND W5, W4, W4
00221E  520FE0     SUB W4, #0x0, [W15]
002220  3A0002     BRA NZ, 0x2226
002222  200015     MOV #0x1, W5
002224  370001     BRA 0x2228
002226  EB0280     CLR W5
002238  720205     IOR W4, W5, W4
00223A  980724     MOV W4, [W14+4]
714:               						(3*((EngineBox.Errori1 & 0x0020)!=0));		// bit.5 -> BoxMotore[0].Test.FluxReq (arriva da Master)
002228  805AF6     MOV 0xB5E, W6
00222A  200204     MOV #0x20, W4
00222C  630204     AND W6, W4, W4
00222E  520FE0     SUB W4, #0x0, [W15]
002230  320002     BRA Z, 0x2236
002232  200034     MOV #0x3, W4
002234  370001     BRA 0x2238
002236  EB0200     CLR W4
715:               				InsertReg(1, temp);					//	REG_TOUCH_SEA_WATER_PUMP	
00223C  90022E     MOV [W14+4], W4
00223E  780084     MOV W4, W1
002240  B3C010     MOV.B #0x1, W0
002242  07FAA6     RCALL InsertReg
716:               				// Estrapolazione stato Flussostato pompa e stato Guasto flussostato da "Errori2"
717:               				temp = (1*(((EngineBox.InputSt & 0x0001)!=0) && !((EngineBox.Errori2 & 0x0400)!=0))) |
002244  805AC4     MOV 0xB58, W4
002246  620261     AND W4, #0x1, W4
002248  784204     MOV.B W4, W4
00224A  524FE0     SUB.B W4, #0x0, [W15]
00224C  320007     BRA Z, 0x225C
00224E  805B05     MOV 0xB60, W5
002250  204004     MOV #0x400, W4
002252  628204     AND W5, W4, W4
002254  520FE0     SUB W4, #0x0, [W15]
002256  3A0002     BRA NZ, 0x225C
002258  200015     MOV #0x1, W5
00225A  370001     BRA 0x225E
00225C  EB0280     CLR W5
00226E  720205     IOR W4, W5, W4
002270  980724     MOV W4, [W14+4]
718:               						(2*((EngineBox.Errori2 & 0x0400)!=0));		// bit.10 -> PersErr.WaterSeaFlux (arriva da Master)
00225E  805B06     MOV 0xB60, W6
002260  204004     MOV #0x400, W4
002262  630204     AND W6, W4, W4
002264  520FE0     SUB W4, #0x0, [W15]
002266  320002     BRA Z, 0x226C
002268  200024     MOV #0x2, W4
00226A  370001     BRA 0x226E
00226C  EB0200     CLR W4
719:               				InsertReg(2, temp);					//	REG_TOUCH_FLOW_STATE
002272  90022E     MOV [W14+4], W4
002274  780084     MOV W4, W1
002276  B3C020     MOV.B #0x2, W0
002278  07FA8B     RCALL InsertReg
720:               				WriteModListReg (TouchAddres, REG_TOUCH_SEA_WATER_PUMP, 2);				
00227A  200022     MOV #0x2, W2
00227C  2008E1     MOV #0x8E, W1
00227E  90502E     MOV.B [W14+18], W0
002280  07F977     RCALL WriteModListReg
721:               				
722:               			break;
002282  3700B9     BRA 0x23F6
723:               
724:               			case 15:		// pagina 15-> Engine Detail
725:               				temp = ValvolaAperta;
002284  203C04     MOV #0x3C0, W4
002286  980724     MOV W4, [W14+4]
726:               				Split_Exp_Valve_Perc = (unsigned int)( ((float)Me.ExpValve_Act / (float)temp) * 100.0); 				
002288  805CC4     MOV 0xB98, W4
00228A  DEA2CF     ASR W4, #15, W5
00228C  BE0004     MOV.D W4, W0
00228E  07F117     RCALL ___floatsisf
002290  BE0400     MOV.D W0, W8
002292  90022E     MOV [W14+4], W4
002294  200005     MOV #0x0, W5
002296  BE0004     MOV.D W4, W0
002298  07F115     RCALL ___floatunsisf
00229A  BE0200     MOV.D W0, W4
00229C  BE0104     MOV.D W4, W2
00229E  BE0008     MOV.D W8, W0
0022A0  07F08C     RCALL ___divsf3
0022A2  BE0200     MOV.D W0, W4
0022A4  200002     MOV #0x0, W2
0022A6  242C83     MOV #0x42C8, W3
0022A8  BE0004     MOV.D W4, W0
0022AA  07F1B8     RCALL ___mulsf3
0022AC  BE0200     MOV.D W0, W4
0022AE  BE0004     MOV.D W4, W0
0022B0  07F0EB     RCALL ___fixunssfsi
0022B2  BE0200     MOV.D W0, W4
0022B4  980734     MOV W4, [W14+6]
727:               				
728:               				InsertReg(1, EngineBox.Pressione_Liq_P);				//	REG_TOUCH_PRESSIONE_P			Pressione_P					84
0022B6  8059B4     MOV 0xB36, W4
0022B8  780084     MOV W4, W1
0022BA  B3C010     MOV.B #0x1, W0
0022BC  07FA69     RCALL InsertReg
729:               				InsertReg(2, EngineBox.Pressione_Gas_G);				//	REG_TOUCH_PRESSIONE_G			Pressione_G					85	
0022BE  8059A4     MOV 0xB34, W4
0022C0  780084     MOV W4, W1
0022C2  B3C020     MOV.B #0x2, W0
0022C4  07FA65     RCALL InsertReg
730:               				WriteModListReg (TouchAddres, REG_TOUCH_PRESSIONE_P, 2);			
0022C6  200022     MOV #0x2, W2
0022C8  200541     MOV #0x54, W1
0022CA  90502E     MOV.B [W14+18], W0
0022CC  07F951     RCALL WriteModListReg
731:               						
732:               				WriteModReg (TouchAddres, REG_TOUCH_TEMP_P, EngineBox.Temp_Collettore_Piccolo);		//	REG_TOUCH_TEMP_P				Temp_Tubo_Piccolo_Liquido	93	
0022CE  805994     MOV 0xB32, W4
0022D0  780104     MOV W4, W2
0022D2  2005D1     MOV #0x5D, W1
0022D4  90502E     MOV.B [W14+18], W0
0022D6  07F921     RCALL WriteModReg
733:               						
734:               				InsertReg(1, Me.Temp_Small);					//	REG_TOUCH_PICCOLO_SPLIT_1		Piccolo_Split_1				96						
0022D8  805B94     MOV 0xB72, W4
0022DA  780084     MOV W4, W1
0022DC  B3C010     MOV.B #0x1, W0
0022DE  07FA58     RCALL InsertReg
735:               				InsertReg(2, Me.Temp_Big);						//	REG_TOUCH_GRANDE_SPLIT_1		Grande_Split_1				97
0022E0  805B84     MOV 0xB70, W4
0022E2  780084     MOV W4, W1
0022E4  B3C020     MOV.B #0x2, W0
0022E6  07FA54     RCALL InsertReg
736:               				InsertReg(3, Me.Temp_Amb);						//	REG_TOUCH_ARIA_INGRESSO_SPLIT_1	Aria_Ingresso_Split_1		98
0022E8  805B64     MOV Me, W4
0022EA  780084     MOV W4, W1
0022EC  B3C030     MOV.B #0x3, W0
0022EE  07FA50     RCALL InsertReg
737:               				InsertReg(4, Me.Temp_AirOut);					//	REG_TOUCH_ARIA_USCITA_SPLIT_1	Aria_Uscita_Split_1			99
0022F0  805B74     MOV 0xB6E, W4
0022F2  780084     MOV W4, W1
0022F4  B3C040     MOV.B #0x4, W0
0022F6  07FA4C     RCALL InsertReg
738:               				InsertReg(5, Me.Fan_Tacho);						//	REG_TOUCH_VENTILATORE_SPLIT_1	FanSpeed_Split_1			100
0022F8  805C94     MOV 0xB92, W4
0022FA  780084     MOV W4, W1
0022FC  B3C050     MOV.B #0x5, W0
0022FE  07FA48     RCALL InsertReg
739:               				//InsertReg(6, Me.ExpValve_Act);					//	REG_TOUCH_STATO_VALVOLA_SPLIT_1	Stato_Valvola_Split_1		101
740:               				InsertReg(6, Split_Exp_Valve_Perc);					//	REG_TOUCH_STATO_VALVOLA_SPLIT_1	Stato_Valvola_Split_1		101
002300  90023E     MOV [W14+6], W4
002302  780084     MOV W4, W1
002304  B3C060     MOV.B #0x6, W0
002306  07FA44     RCALL InsertReg
741:               				WriteModListReg (TouchAddres, REG_TOUCH_PICCOLO_SPLIT_1, 6);
002308  200062     MOV #0x6, W2
00230A  200601     MOV #0x60, W1
00230C  90502E     MOV.B [W14+18], W0
00230E  07F930     RCALL WriteModListReg
742:               
743:               			break;
002310  370072     BRA 0x23F6
744:               			
745:               			case 12:		// pagina 15 -> Diagnostic Inverter data			//Ex.Pag.12			
746:               			case 16:		// pagina 16-> Power Monitor	
747:               				
748:               				// Dati restituiti da Inverter	=> Potenza in centesimi di Kw (es. 5Kw = 500)
749:               				//								=> Frequenza in centesimi di Hz (es. 120Hz = 12000)
750:               				//								=> Tensione in centesimi di % Perc. (es. 90% = 9000)
751:               				//								=> Corrente in centesimi di % Perc. (es. 35% = 3500)				
752:               				
753:               				Inverter_MaxCurr = K_Power_Inverter / K_Supply_Inverter;
002312  2000C4     MOV #0xC, W4
002314  980744     MOV W4, [W14+8]
754:               				Inverter_InCurr = DiagnosticInverter.InPower / K_Power_Inverter;
002316  8072A5     MOV 0xE54, W5
002318  20FA04     MOV #0xFA0, W4
00231A  090011     REPEAT #0x11
00231C  D88284     DIV.UW W5, W4
00231E  780200     MOV W0, W4
002320  980754     MOV W4, [W14+10]
755:               				Inverter_OutCurr = (unsigned int)(((float)DiagnosticInverter.OutCurr * (float)Inverter_MaxCurr)/100.0);	// Perc. -> Ampere (centesimi di A)
002322  807274     MOV 0xE4E, W4
002324  200005     MOV #0x0, W5
002326  BE0004     MOV.D W4, W0
002328  07F0CD     RCALL ___floatunsisf
00232A  BE0400     MOV.D W0, W8
00232C  90024E     MOV [W14+8], W4
00232E  200005     MOV #0x0, W5
002330  BE0004     MOV.D W4, W0
002332  07F0C8     RCALL ___floatunsisf
002334  BE0200     MOV.D W0, W4
002336  BE0104     MOV.D W4, W2
002338  BE0008     MOV.D W8, W0
00233A  07F170     RCALL ___mulsf3
00233C  BE0200     MOV.D W0, W4
00233E  200002     MOV #0x0, W2
002340  242C83     MOV #0x42C8, W3
002342  BE0004     MOV.D W4, W0
002344  07F03A     RCALL ___divsf3
002346  BE0200     MOV.D W0, W4
002348  BE0004     MOV.D W4, W0
00234A  07F09E     RCALL ___fixunssfsi
00234C  BE0200     MOV.D W0, W4
00234E  980764     MOV W4, [W14+12]
756:               				Inverter_InVolt = (unsigned int)(((float)DiagnosticInverter.InVolt * (float)K_Supply_Inverter)/100.0);	// Perc. -> Volt (centesimi di V)
002350  807284     MOV 0xE50, W4
002352  200005     MOV #0x0, W5
002354  BE0004     MOV.D W4, W0
002356  07F0B6     RCALL ___floatunsisf
002358  BE0200     MOV.D W0, W4
00235A  280002     MOV #0x8000, W2
00235C  243A23     MOV #0x43A2, W3
00235E  BE0004     MOV.D W4, W0
002360  07F15D     RCALL ___mulsf3
002362  BE0200     MOV.D W0, W4
002364  200002     MOV #0x0, W2
002366  242C83     MOV #0x42C8, W3
002368  BE0004     MOV.D W4, W0
00236A  07F027     RCALL ___divsf3
00236C  BE0200     MOV.D W0, W4
00236E  BE0004     MOV.D W4, W0
002370  07F08B     RCALL ___fixunssfsi
002372  BE0200     MOV.D W0, W4
002374  980774     MOV W4, [W14+14]
757:               				Inverter_OutVolt = (unsigned int)(((float)DiagnosticInverter.OutVolt * (float)K_Supply_Inverter)/100.0);	// Perc. -> Volt (centesimi di V)
002376  807294     MOV 0xE52, W4
002378  200005     MOV #0x0, W5
00237A  BE0004     MOV.D W4, W0
00237C  07F0A3     RCALL ___floatunsisf
00237E  BE0200     MOV.D W0, W4
002380  280002     MOV #0x8000, W2
002382  243A23     MOV #0x43A2, W3
002384  BE0004     MOV.D W4, W0
002386  07F14A     RCALL ___mulsf3
002388  BE0200     MOV.D W0, W4
00238A  200002     MOV #0x0, W2
00238C  242C83     MOV #0x42C8, W3
00238E  BE0004     MOV.D W4, W0
002390  07F014     RCALL ___divsf3
002392  BE0200     MOV.D W0, W4
002394  BE0004     MOV.D W4, W0
002396  07F078     RCALL ___fixunssfsi
002398  BE0200     MOV.D W0, W4
00239A  980F04     MOV W4, [W14+16]
758:               				
759:               				InsertReg(1, DiagnosticInverter.Alarm);					// REG_TOUCH_INVERTER_ALARM			bits
00239C  807244     MOV DiagnosticInverter, W4
00239E  780084     MOV W4, W1
0023A0  B3C010     MOV.B #0x1, W0
0023A2  07F9F6     RCALL InsertReg
760:               				InsertReg(2, DiagnosticInverter.OutFreq);				// REG_TOUCH_INVERTER_OUT_FREQ		Hz (centesimi)
0023A4  807254     MOV 0xE4A, W4
0023A6  780084     MOV W4, W1
0023A8  B3C020     MOV.B #0x2, W0
0023AA  07F9F2     RCALL InsertReg
761:               				InsertReg(3, DiagnosticInverter.Status);				// REG_TOUCH_INVERTER_STATUS		bits
0023AC  807264     MOV 0xE4C, W4
0023AE  780084     MOV W4, W1
0023B0  B3C030     MOV.B #0x3, W0
0023B2  07F9EE     RCALL InsertReg
762:               				InsertReg(4, Inverter_InCurr/*DiagnosticInverter.OutCurr*/);				// REG_TOUCH_INVERTER_OUT_CURR		% Perc. (centesimi) di Max Corrente (Taglia inverter in KW / Volt Inverter (400V)  
0023B4  90025E     MOV [W14+10], W4
0023B6  780084     MOV W4, W1
0023B8  B3C040     MOV.B #0x4, W0
0023BA  07F9EA     RCALL InsertReg
763:               				InsertReg(5, Inverter_InVolt/*DiagnosticInverter.InVolt*/);				// REG_TOUCH_INVERTER_IN_VOLT		% Perc. (centesimi)	di Max Volt alimentazione inverter 3F (400V))
0023BC  90027E     MOV [W14+14], W4
0023BE  780084     MOV W4, W1
0023C0  B3C050     MOV.B #0x5, W0
0023C2  07F9E6     RCALL InsertReg
764:               				InsertReg(6, Inverter_OutVolt/*DiagnosticInverter.OutVolt*/);				// REG_TOUCH_INVERTER_OUT_VOLT		% Perc. (centesimi)	di Max Volt alimentazione inverter 3F (400V))
0023C4  900A0E     MOV [W14+16], W4
0023C6  780084     MOV W4, W1
0023C8  B3C060     MOV.B #0x6, W0
0023CA  07F9E2     RCALL InsertReg
765:               				InsertReg(7, DiagnosticInverter.InPower);				// REG_TOUCH_INVERTER_IN_POWER		Kw (centesimi)
0023CC  8072A4     MOV 0xE54, W4
0023CE  780084     MOV W4, W1
0023D0  B3C070     MOV.B #0x7, W0
0023D2  07F9DE     RCALL InsertReg
766:               				InsertReg(8, DiagnosticInverter.OutPower);				// REG_TOUCH_INVERTER_OUT_POWER		Kw (centesimi)
0023D4  8072B4     MOV 0xE56, W4
0023D6  780084     MOV W4, W1
0023D8  B3C080     MOV.B #0x8, W0
0023DA  07F9DA     RCALL InsertReg
767:               				InsertReg(9, DiagnosticInverter.ReqFreq);				// REG_TOUCH_INVERTER_REQ_FREQ		Hz (centesimi)
0023DC  8072C4     MOV 0xE58, W4
0023DE  780084     MOV W4, W1
0023E0  B3C090     MOV.B #0x9, W0
0023E2  07F9D6     RCALL InsertReg
768:               				InsertReg(10, DiagnosticInverter.MaxReqFreq);			// REG_TOUCH_INVERTER_MAX_REQ_FREQ	Hz (centesimi)
0023E4  8072D4     MOV 0xE5A, W4
0023E6  780084     MOV W4, W1
0023E8  B3C0A0     MOV.B #0xA, W0
0023EA  07F9D2     RCALL InsertReg
769:               				WriteModListReg (TouchAddres, REG_TOUCH_INVERTER_ALARM, 10);						
0023EC  2000A2     MOV #0xA, W2
0023EE  2007E1     MOV #0x7E, W1
0023F0  90502E     MOV.B [W14+18], W0
0023F2  07F8BE     RCALL WriteModListReg
770:               			break;					
0023F4  000000     NOP
771:               				
772:               
773:               		}
774:               	}
775:               }
0023F6  BE044F     MOV.D [--W15], W8
0023F8  FA8000     ULNK
0023FA  060000     RETURN
776:               
777:               void RefreshAllTouchOutPut(void)
778:               {
0023FC  FA0000     LNK #0x0
779:               	/////for(i=1; i<=MaxTouch; i++)
780:               	for(i=Add_TouchRoom; i< (Add_TouchRoom+MaxTouch); i++)
0023FE  B3C014     MOV.B #0x1, W4
002400  784304     MOV.B W4, W6
002402  20AA45     MOV #0xAA4, W5
002404  784A86     MOV.B W6, [W5]
002406  37000A     BRA 0x241C
002410  20AA44     MOV #0xAA4, W4
002412  784214     MOV.B [W4], W4
002414  E84204     INC.B W4, W4
002416  784304     MOV.B W4, W6
002418  20AA45     MOV #0xAA4, W5
00241A  784A86     MOV.B W6, [W5]
00241C  20AA44     MOV #0xAA4, W4
00241E  784214     MOV.B [W4], W4
002420  524FE4     SUB.B W4, #0x4, [W15]
002422  34FFF2     BRA LE, 0x2408
781:               		RefreshTouchOutPut(i);
002408  20AA44     MOV #0xAA4, W4
00240A  784214     MOV.B [W4], W4
00240C  784004     MOV.B W4, W0
00240E  07FCA3     RCALL RefreshTouchOutPut
782:               }
002424  FA8000     ULNK
002426  060000     RETURN
783:               
784:               void InitTouch(void)
785:               {
002428  FA0000     LNK #0x0
786:               	//int pag; //DEBUG
787:               	
788:               	for(i=0; i<MaxTouch; i++)
00242A  EB4200     CLR.B W4
00242C  784304     MOV.B W4, W6
00242E  20AA45     MOV #0xAA4, W5
002430  784A86     MOV.B W6, [W5]
002432  37007A     BRA 0x2528
00251C  20AA44     MOV #0xAA4, W4
00251E  784214     MOV.B [W4], W4
002520  E84204     INC.B W4, W4
002522  784304     MOV.B W4, W6
002524  20AA45     MOV #0xAA4, W5
002526  784A86     MOV.B W6, [W5]
002528  20AA44     MOV #0xAA4, W4
00252A  784214     MOV.B [W4], W4
00252C  524FE3     SUB.B W4, #0x3, [W15]
00252E  34FF82     BRA LE, 0x2434
789:               	/////for(i=Add_TouchRoom; i< (Add_TouchRoom+MaxTouch); i++)
790:               	{
791:               		if(Touch[i].Enable && !Touch[i].OffLine)
002434  20AA44     MOV #0xAA4, W4
002436  784214     MOV.B [W4], W4
002438  FB0204     SE W4, W4
00243A  B92278     MUL.SU W4, #24, W4
00243C  780204     MOV W4, W4
00243E  4202F6     ADD W4, #0x16, W5
002440  20BAE4     MOV #0xBAE, W4
002442  428204     ADD W5, W4, W4
002444  780214     MOV [W4], W4
002446  784204     MOV.B W4, W4
002448  624261     AND.B W4, #0x1, W4
00244A  524FE0     SUB.B W4, #0x0, [W15]
00244C  320067     BRA Z, 0x251C
00244E  20AA44     MOV #0xAA4, W4
002450  784214     MOV.B [W4], W4
002452  FB0204     SE W4, W4
002454  B92278     MUL.SU W4, #24, W4
002456  780204     MOV W4, W4
002458  4202F6     ADD W4, #0x16, W5
00245A  20BAE4     MOV #0xBAE, W4
00245C  428204     ADD W5, W4, W4
00245E  780214     MOV [W4], W4
002460  D10204     LSR W4, W4
002462  624261     AND.B W4, #0x1, W4
002464  524FE0     SUB.B W4, #0x0, [W15]
002466  3A005A     BRA NZ, 0x251C
792:               		{
793:               /*
794:               			WriteModReg (Add_TouchRoom +i, REG_TOUCH_SP_ROOM, 2000);
795:               			WriteModReg (Add_TouchRoom +i, REG_TOUCH_SP_ROOM_F, 6400);
796:               			WriteModReg (Add_TouchRoom +i, REG_TOUCH_FAN_SPEED, 9);
797:               			WriteModReg (Add_TouchRoom +i, REG_TOUCH_PWR, 0);
798:               			WriteModReg (Add_TouchRoom +i, REG_TOUCH_MODE, CoreRiscaldamento);
799:               			WriteModReg (Add_TouchRoom +i, REG_TOUCH_MAX_PWR_LIMIT, InitPowerLimit);
800:               */
801:               			WriteModReg (Add_TouchRoom +i, REG_TOUCH_SP_ROOM, Touch[0].SetPoint);
002468  805D75     MOV Touch, W5
00246A  20AA44     MOV #0xAA4, W4
00246C  784214     MOV.B [W4], W4
00246E  E84204     INC.B W4, W4
002470  780105     MOV W5, W2
002472  200131     MOV #0x13, W1
002474  784004     MOV.B W4, W0
002476  07F851     RCALL WriteModReg
802:               			WriteModReg (Add_TouchRoom +i, REG_TOUCH_SP_ROOM_F, Touch[0].Script_SetPoint_F);
002478  805E15     MOV 0xBC2, W5
00247A  20AA44     MOV #0xAA4, W4
00247C  784214     MOV.B [W4], W4
00247E  E84204     INC.B W4, W4
002480  780105     MOV W5, W2
002482  200161     MOV #0x16, W1
002484  784004     MOV.B W4, W0
002486  07F849     RCALL WriteModReg
803:               			WriteModReg (Add_TouchRoom +i, REG_TOUCH_FAN_SPEED, Touch[0].FanMode);
002488  805D95     MOV 0xBB2, W5
00248A  20AA44     MOV #0xAA4, W4
00248C  784214     MOV.B [W4], W4
00248E  E84204     INC.B W4, W4
002490  780105     MOV W5, W2
002492  200141     MOV #0x14, W1
002494  784004     MOV.B W4, W0
002496  07F841     RCALL WriteModReg
804:               			WriteModReg (Add_TouchRoom +i, REG_TOUCH_PWR, Touch[0].Script_Split_Pwr);
002498  805E05     MOV 0xBC0, W5
00249A  20AA44     MOV #0xAA4, W4
00249C  784214     MOV.B [W4], W4
00249E  E84204     INC.B W4, W4
0024A0  780105     MOV W5, W2
0024A2  200021     MOV #0x2, W1
0024A4  784004     MOV.B W4, W0
0024A6  07F839     RCALL WriteModReg
805:               			WriteModReg (Add_TouchRoom +i, REG_TOUCH_MODE, Touch[0].DefMode);
0024A8  805DF5     MOV 0xBBE, W5
0024AA  20AA44     MOV #0xAA4, W4
0024AC  784214     MOV.B [W4], W4
0024AE  E84204     INC.B W4, W4
0024B0  780105     MOV W5, W2
0024B2  200031     MOV #0x3, W1
0024B4  784004     MOV.B W4, W0
0024B6  07F831     RCALL WriteModReg
806:               			WriteModReg (Add_TouchRoom +i, REG_TOUCH_FUNCTION_MODE, Touch[0].DefMode*Touch[0].Script_Split_Pwr);
0024B8  805DF5     MOV 0xBBE, W5
0024BA  805E04     MOV 0xBC0, W4
0024BC  B9AA04     MUL.SS W5, W4, W4
0024BE  780284     MOV W4, W5
0024C0  20AA44     MOV #0xAA4, W4
0024C2  784214     MOV.B [W4], W4
0024C4  E84204     INC.B W4, W4
0024C6  780105     MOV W5, W2
0024C8  200151     MOV #0x15, W1
0024CA  784004     MOV.B W4, W0
0024CC  07F826     RCALL WriteModReg
807:               			WriteModReg (Add_TouchRoom +i, REG_TOUCH_MAX_PWR_LIMIT, Touch[0].PowerLimit);	
0024CE  805DA5     MOV 0xBB4, W5
0024D0  20AA44     MOV #0xAA4, W4
0024D2  784214     MOV.B [W4], W4
0024D4  E84204     INC.B W4, W4
0024D6  780105     MOV W5, W2
0024D8  200201     MOV #0x20, W1
0024DA  784004     MOV.B W4, W0
0024DC  07F81E     RCALL WriteModReg
808:               	
809:               			WriteModReg (Add_TouchRoom +i, REG_TOUCH_MATRICOLA_LO, 0x3210);
0024DE  20AA44     MOV #0xAA4, W4
0024E0  784214     MOV.B [W4], W4
0024E2  E84204     INC.B W4, W4
0024E4  232102     MOV #0x3210, W2
0024E6  200401     MOV #0x40, W1
0024E8  784004     MOV.B W4, W0
0024EA  07F817     RCALL WriteModReg
810:               			WriteModReg (Add_TouchRoom +i, REG_TOUCH_MATRICOLA_HI, 0x7654);
0024EC  20AA44     MOV #0xAA4, W4
0024EE  784214     MOV.B [W4], W4
0024F0  E84204     INC.B W4, W4
0024F2  276542     MOV #0x7654, W2
0024F4  200411     MOV #0x41, W1
0024F6  784004     MOV.B W4, W0
0024F8  07F810     RCALL WriteModReg
811:               			WriteModReg (Add_TouchRoom +i, REG_TOUCH_MASTER_FW_VERSION, Versione_Fw);
0024FA  20AA44     MOV #0xAA4, W4
0024FC  784214     MOV.B [W4], W4
0024FE  E84204     INC.B W4, W4
002500  200042     MOV #0x4, W2
002502  200421     MOV #0x42, W1
002504  784004     MOV.B W4, W0
002506  07F809     RCALL WriteModReg
812:               			
813:               			//pag = 2; //DEBUG
814:               			if(Touch[0].Current_Page==0)
002508  805DD4     MOV 0xBBA, W4
00250A  520FE0     SUB W4, #0x0, [W15]
00250C  3A0007     BRA NZ, 0x251C
815:               				WriteModReg (Add_TouchRoom +i, REG_TOUCH_PAGE, 2);	// Modificato in v8.4.16 
00250E  20AA44     MOV #0xAA4, W4
002510  784214     MOV.B [W4], W4
002512  E84204     INC.B W4, W4
002514  200022     MOV #0x2, W2
002516  200011     MOV #0x1, W1
002518  784004     MOV.B W4, W0
00251A  07F7FF     RCALL WriteModReg
816:               				//WriteModReg (Add_TouchRoom +i, REG_TOUCH_PAGE_INIT, pag);	// Modificato in v8.4.16 DEBUG
817:               		}
818:               	}
819:               }
002530  FA8000     ULNK
002532  060000     RETURN
820:               
821:               
822:               
823:               
824:               //------------------------------------------------
825:               // Routines di gestione dei Pannelli NetBuilding
826:               //------------------------------------------------
827:               void Search_Panel(void)
828:               {
002534  FA0000     LNK #0x0
829:               	Result = 0;
002536  EB4200     CLR.B W4
002538  784304     MOV.B W4, W6
00253A  20A9E5     MOV #0xA9E, W5
00253C  784A86     MOV.B W6, [W5]
830:               
831:               	// Scansiono la rete alla ricerca dei Pannelli
832:               	for(i=0; i<MaxPanel; i++)
00253E  EB4200     CLR.B W4
002540  784304     MOV.B W4, W6
002542  20AA45     MOV #0xAA4, W5
002544  784A86     MOV.B W6, [W5]
002546  370042     BRA 0x25CC
0025C0  20AA44     MOV #0xAA4, W4
0025C2  784214     MOV.B [W4], W4
0025C4  E84204     INC.B W4, W4
0025C6  784304     MOV.B W4, W6
0025C8  20AA45     MOV #0xAA4, W5
0025CA  784A86     MOV.B W6, [W5]
0025CC  20AA44     MOV #0xAA4, W4
0025CE  784214     MOV.B [W4], W4
0025D0  524FE3     SUB.B W4, #0x3, [W15]
0025D2  34FFBA     BRA LE, 0x2548
833:               	{
834:               		Result = Send_WaitModRx(Add_PanelRoom+i, ReadModCmd, REG_PANEL_FW_REL, 1, MaxModChkWait, MaxModChkRetries);
002548  20AA44     MOV #0xAA4, W4
00254A  784214     MOV.B [W4], W4
00254C  42427E     ADD.B W4, #0x1E, W4
00254E  784304     MOV.B W4, W6
002550  B3C035     MOV.B #0x3, W5
002552  201904     MOV #0x190, W4
002554  200013     MOV #0x1, W3
002556  200032     MOV #0x3, W2
002558  B3C031     MOV.B #0x3, W1
00255A  784006     MOV.B W6, W0
00255C  07F6E1     RCALL Send_WaitModRx
00255E  784200     MOV.B W0, W4
002560  784304     MOV.B W4, W6
002562  20A9E5     MOV #0xA9E, W5
002564  784A86     MOV.B W6, [W5]
835:               		Panel[i].Enable = (Result == 0) ;
002566  20AA44     MOV #0xAA4, W4
002568  784214     MOV.B [W4], W4
00256A  FB0204     SE W4, W4
00256C  20A9E5     MOV #0xA9E, W5
00256E  784295     MOV.B [W5], W5
002570  FB8285     ZE W5, W5
002572  E90285     DEC W5, W5
002574  DE2ACF     LSR W5, #15, W5
002576  784305     MOV.B W5, W6
002578  B9226C     MUL.SU W4, #12, W4
00257A  780284     MOV W4, W5
00257C  20C184     MOV #0xC18, W4
00257E  428204     ADD W5, W4, W4
002580  FB8286     ZE W6, W5
002582  6282E1     AND W5, #0x1, W5
002584  780394     MOV [W4], W7
002586  2FFFE6     MOV #0xFFFE, W6
002588  638306     AND W7, W6, W6
00258A  728286     IOR W5, W6, W5
00258C  780A05     MOV W5, [W4]
836:               		Panel[i].OffLine = (Result != 0);
00258E  20AA44     MOV #0xAA4, W4
002590  784214     MOV.B [W4], W4
002592  FB0204     SE W4, W4
002594  20A9E5     MOV #0xA9E, W5
002596  784295     MOV.B [W5], W5
002598  FB8285     ZE W5, W5
00259A  EA0285     NEG W5, W5
00259C  DE2ACF     LSR W5, #15, W5
00259E  784305     MOV.B W5, W6
0025A0  B9226C     MUL.SU W4, #12, W4
0025A2  780284     MOV W4, W5
0025A4  20C184     MOV #0xC18, W4
0025A6  428204     ADD W5, W4, W4
0025A8  FB8286     ZE W6, W5
0025AA  6282E1     AND W5, #0x1, W5
0025AC  428285     ADD W5, W5, W5
0025AE  780394     MOV [W4], W7
0025B0  2FFFD6     MOV #0xFFFD, W6
0025B2  638306     AND W7, W6, W6
0025B4  728286     IOR W5, W6, W5
0025B6  780A05     MOV W5, [W4]
837:               		Mod_LastRx.Valid_Data = 0;
0025B8  EB4200     CLR.B W4
0025BA  784304     MOV.B W4, W6
0025BC  20A8E5     MOV #0xA8E, W5
0025BE  784A86     MOV.B W6, [W5]
838:               	}
839:               }
0025D4  FA8000     ULNK
0025D6  060000     RETURN
840:               
841:               void Resume_PanelOffLine(char * Cnt)
842:               {
0025D8  FA0002     LNK #0x2
0025DA  780F00     MOV W0, [W14]
843:               	Result = 0;
0025DC  EB4200     CLR.B W4
0025DE  784304     MOV.B W4, W6
0025E0  20A9E5     MOV #0xA9E, W5
0025E2  784A86     MOV.B W6, [W5]
844:               	
845:               	// Provo a recuperare i moduli Panel
846:               	if((Panel[(*Cnt)].Enable == 1) && (Panel[(*Cnt)].OffLine == 1))
0025E4  78021E     MOV [W14], W4
0025E6  784214     MOV.B [W4], W4
0025E8  FB0204     SE W4, W4
0025EA  B9226C     MUL.SU W4, #12, W4
0025EC  780204     MOV W4, W4
0025EE  4202EA     ADD W4, #0xA, W5
0025F0  20C0E4     MOV #0xC0E, W4
0025F2  428204     ADD W5, W4, W4
0025F4  780214     MOV [W4], W4
0025F6  784204     MOV.B W4, W4
0025F8  624261     AND.B W4, #0x1, W4
0025FA  524FE1     SUB.B W4, #0x1, [W15]
0025FC  3A0035     BRA NZ, 0x2668
0025FE  78021E     MOV [W14], W4
002600  784214     MOV.B [W4], W4
002602  FB0204     SE W4, W4
002604  B9226C     MUL.SU W4, #12, W4
002606  780204     MOV W4, W4
002608  4202EA     ADD W4, #0xA, W5
00260A  20C0E4     MOV #0xC0E, W4
00260C  428204     ADD W5, W4, W4
00260E  780214     MOV [W4], W4
002610  D10204     LSR W4, W4
002612  624261     AND.B W4, #0x1, W4
002614  524FE1     SUB.B W4, #0x1, [W15]
002616  3A0028     BRA NZ, 0x2668
847:               	{
848:               		Result = Send_WaitModRx(Add_PanelRoom +(*Cnt), ReadModCmd, REG_PANEL_FW_REL, 1, MaxModChkWait, MaxModChkRetries);
002618  78021E     MOV [W14], W4
00261A  784214     MOV.B [W4], W4
00261C  42427E     ADD.B W4, #0x1E, W4
00261E  784304     MOV.B W4, W6
002620  B3C035     MOV.B #0x3, W5
002622  201904     MOV #0x190, W4
002624  200013     MOV #0x1, W3
002626  200032     MOV #0x3, W2
002628  B3C031     MOV.B #0x3, W1
00262A  784006     MOV.B W6, W0
00262C  07F679     RCALL Send_WaitModRx
00262E  784200     MOV.B W0, W4
002630  784304     MOV.B W4, W6
002632  20A9E5     MOV #0xA9E, W5
002634  784A86     MOV.B W6, [W5]
849:               		Panel[(*Cnt)].OffLine = (Result != 0);
002636  78021E     MOV [W14], W4
002638  784214     MOV.B [W4], W4
00263A  FB0204     SE W4, W4
00263C  20A9E5     MOV #0xA9E, W5
00263E  784295     MOV.B [W5], W5
002640  FB8285     ZE W5, W5
002642  EA0285     NEG W5, W5
002644  DE2ACF     LSR W5, #15, W5
002646  784305     MOV.B W5, W6
002648  B9226C     MUL.SU W4, #12, W4
00264A  780284     MOV W4, W5
00264C  20C184     MOV #0xC18, W4
00264E  428204     ADD W5, W4, W4
002650  FB8286     ZE W6, W5
002652  6282E1     AND W5, #0x1, W5
002654  428285     ADD W5, W5, W5
002656  780394     MOV [W4], W7
002658  2FFFD6     MOV #0xFFFD, W6
00265A  638306     AND W7, W6, W6
00265C  728286     IOR W5, W6, W5
00265E  780A05     MOV W5, [W4]
850:               		Mod_LastRx.Valid_Data = 0;
002660  EB4200     CLR.B W4
002662  784304     MOV.B W4, W6
002664  20A8E5     MOV #0xA8E, W5
002666  784A86     MOV.B W6, [W5]
851:               	}
852:               	(*Cnt) += 1;
002668  78021E     MOV [W14], W4
00266A  784214     MOV.B [W4], W4
00266C  E84204     INC.B W4, W4
00266E  784284     MOV.B W4, W5
002670  78021E     MOV [W14], W4
002672  784A05     MOV.B W5, [W4]
853:               	if((*Cnt) >= MaxPanel)
002674  78021E     MOV [W14], W4
002676  784214     MOV.B [W4], W4
002678  524FE3     SUB.B W4, #0x3, [W15]
00267A  340003     BRA LE, 0x2682
854:               		(*Cnt) = 0;
00267C  78021E     MOV [W14], W4
00267E  EB4280     CLR.B W5
002680  784A05     MOV.B W5, [W4]
855:               }
002682  FA8000     ULNK
002684  060000     RETURN
856:               
857:               void RefreshPanelInPut(char PanelAddres)
858:               {
002686  FA0002     LNK #0x2
002688  781F88     MOV W8, [W15++]
00268A  784F00     MOV.B W0, [W14]
859:               	DataIndex = PanelAddres-Add_PanelRoom;
00268C  78421E     MOV.B [W14], W4
00268E  52427E     SUB.B W4, #0x1E, W4
002690  784304     MOV.B W4, W6
002692  20AA55     MOV #0xAA5, W5
002694  784A86     MOV.B W6, [W5]
860:               	if(Panel[DataIndex].Enable & !Panel[DataIndex].OffLine)
002696  20AA54     MOV #0xAA5, W4
002698  784214     MOV.B [W4], W4
00269A  FB0204     SE W4, W4
00269C  B9226C     MUL.SU W4, #12, W4
00269E  780204     MOV W4, W4
0026A0  4202EA     ADD W4, #0xA, W5
0026A2  20C0E4     MOV #0xC0E, W4
0026A4  428204     ADD W5, W4, W4
0026A6  780214     MOV [W4], W4
0026A8  784204     MOV.B W4, W4
0026AA  624261     AND.B W4, #0x1, W4
0026AC  FB8304     ZE W4, W6
0026AE  20AA54     MOV #0xAA5, W4
0026B0  784214     MOV.B [W4], W4
0026B2  FB0204     SE W4, W4
0026B4  B9226C     MUL.SU W4, #12, W4
0026B6  780204     MOV W4, W4
0026B8  4202EA     ADD W4, #0xA, W5
0026BA  20C0E4     MOV #0xC0E, W4
0026BC  428204     ADD W5, W4, W4
0026BE  780214     MOV [W4], W4
0026C0  D10204     LSR W4, W4
0026C2  624261     AND.B W4, #0x1, W4
0026C4  FB8204     ZE W4, W4
0026C6  E90204     DEC W4, W4
0026C8  DE224F     LSR W4, #15, W4
0026CA  630204     AND W6, W4, W4
0026CC  520FE0     SUB W4, #0x0, [W15]
0026CE  3200AB     BRA Z, 0x2826
861:               	{	
862:               		if(Send_WaitModRx(PanelAddres, ReadModCmd, REG_PANEL_TEMP_SETP_10, 1, MaxModReadWait, MaxModReadRetries))	// Il registro dei touch hanno un offset di 1
0026D0  B3C025     MOV.B #0x2, W5
0026D2  200324     MOV #0x32, W4
0026D4  200013     MOV #0x1, W3
0026D6  2002E2     MOV #0x2E, W2
0026D8  B3C031     MOV.B #0x3, W1
0026DA  78401E     MOV.B [W14], W0
0026DC  07F621     RCALL Send_WaitModRx
0026DE  784200     MOV.B W0, W4
0026E0  524FE0     SUB.B W4, #0x0, [W15]
0026E2  32000B     BRA Z, 0x26FA
863:               			Panel[DataIndex].OffLine = 1;
0026E4  20AA54     MOV #0xAA5, W4
0026E6  784214     MOV.B [W4], W4
0026E8  FB0204     SE W4, W4
0026EA  B9226C     MUL.SU W4, #12, W4
0026EC  780284     MOV W4, W5
0026EE  20C184     MOV #0xC18, W4
0026F0  428284     ADD W5, W4, W5
0026F2  780215     MOV [W5], W4
0026F4  A01004     BSET W4, #1
0026F6  780A84     MOV W4, [W5]
0026F8  37000D     BRA 0x2714
864:               		else
865:               			Panel[DataIndex].SetPoint = ExtracReg(1)*10; // Il setpoint che arriva dal pannello e' in decimi di grado
0026FA  20AA54     MOV #0xAA5, W4
0026FC  784214     MOV.B [W4], W4
0026FE  FB0404     SE W4, W8
002700  B3C010     MOV.B #0x1, W0
002702  07F81E     RCALL ExtracReg
002704  780200     MOV W0, W4
002706  B9226A     MUL.SU W4, #10, W4
002708  780304     MOV W4, W6
00270A  B9426C     MUL.SU W8, #12, W4
00270C  780284     MOV W4, W5
00270E  20C0E4     MOV #0xC0E, W4
002710  428204     ADD W5, W4, W4
002712  780A06     MOV W6, [W4]
866:               
867:               		if(Send_WaitModRx(PanelAddres, ReadModCmd, REG_PANEL_IMP_VEL_FAN, 1, MaxModReadWait, MaxModReadRetries))	// Il registro dei touch hanno un offset di 1
002714  B3C025     MOV.B #0x2, W5
002716  200324     MOV #0x32, W4
002718  200013     MOV #0x1, W3
00271A  2000F2     MOV #0xF, W2
00271C  B3C031     MOV.B #0x3, W1
00271E  78401E     MOV.B [W14], W0
002720  07F5FF     RCALL Send_WaitModRx
002722  784200     MOV.B W0, W4
002724  524FE0     SUB.B W4, #0x0, [W15]
002726  32000B     BRA Z, 0x273E
868:               			Panel[DataIndex].OffLine = 1;
002728  20AA54     MOV #0xAA5, W4
00272A  784214     MOV.B [W4], W4
00272C  FB0204     SE W4, W4
00272E  B9226C     MUL.SU W4, #12, W4
002730  780284     MOV W4, W5
002732  20C184     MOV #0xC18, W4
002734  428284     ADD W5, W4, W5
002736  780215     MOV [W5], W4
002738  A01004     BSET W4, #1
00273A  780A84     MOV W4, [W5]
00273C  37000B     BRA 0x2754
869:               		else
870:               			Panel[DataIndex].FanMode = ExtracReg(1);
00273E  20AA54     MOV #0xAA5, W4
002740  784214     MOV.B [W4], W4
002742  FB0404     SE W4, W8
002744  B3C010     MOV.B #0x1, W0
002746  07F7FC     RCALL ExtracReg
002748  780300     MOV W0, W6
00274A  B9426C     MUL.SU W8, #12, W4
00274C  780284     MOV W4, W5
00274E  20C124     MOV #0xC12, W4
002750  428204     ADD W5, W4, W4
002752  780A06     MOV W6, [W4]
871:               
872:               		if(Send_WaitModRx(PanelAddres, ReadModCmd, REG_PANEL_TEMP_ATT_10, 1, MaxModReadWait, MaxModReadRetries))	// Il registro dei touch hanno un offset di 1
002754  B3C025     MOV.B #0x2, W5
002756  200324     MOV #0x32, W4
002758  200013     MOV #0x1, W3
00275A  200292     MOV #0x29, W2
00275C  B3C031     MOV.B #0x3, W1
00275E  78401E     MOV.B [W14], W0
002760  07F5DF     RCALL Send_WaitModRx
002762  784200     MOV.B W0, W4
002764  524FE0     SUB.B W4, #0x0, [W15]
002766  32000B     BRA Z, 0x277E
873:               			Panel[DataIndex].OffLine = 1;
002768  20AA54     MOV #0xAA5, W4
00276A  784214     MOV.B [W4], W4
00276C  FB0204     SE W4, W4
00276E  B9226C     MUL.SU W4, #12, W4
002770  780284     MOV W4, W5
002772  20C184     MOV #0xC18, W4
002774  428284     ADD W5, W4, W5
002776  780215     MOV [W5], W4
002778  A01004     BSET W4, #1
00277A  780A84     MOV W4, [W5]
00277C  37000D     BRA 0x2798
874:               		else
875:               			Panel[DataIndex].Temperature = ExtracReg(1)*10; // La temperatura che arriva dal pannello e' in decimi di grado
00277E  20AA54     MOV #0xAA5, W4
002780  784214     MOV.B [W4], W4
002782  FB0404     SE W4, W8
002784  B3C010     MOV.B #0x1, W0
002786  07F7DC     RCALL ExtracReg
002788  780200     MOV W0, W4
00278A  B9226A     MUL.SU W4, #10, W4
00278C  780304     MOV W4, W6
00278E  B9426C     MUL.SU W8, #12, W4
002790  780284     MOV W4, W5
002792  20C144     MOV #0xC14, W4
002794  428204     ADD W5, W4, W4
002796  780A06     MOV W6, [W4]
876:               
877:               		if(Send_WaitModRx(PanelAddres, ReadModCmd, REG_PANEL_PRESSURE_10, 1, MaxModReadWait, MaxModReadRetries))	// Il registro dei touch hanno un offset di 1
002798  B3C025     MOV.B #0x2, W5
00279A  200324     MOV #0x32, W4
00279C  200013     MOV #0x1, W3
00279E  200302     MOV #0x30, W2
0027A0  B3C031     MOV.B #0x3, W1
0027A2  78401E     MOV.B [W14], W0
0027A4  07F5BD     RCALL Send_WaitModRx
0027A6  784200     MOV.B W0, W4
0027A8  524FE0     SUB.B W4, #0x0, [W15]
0027AA  32000B     BRA Z, 0x27C2
878:               			Panel[DataIndex].OffLine = 1;
0027AC  20AA54     MOV #0xAA5, W4
0027AE  784214     MOV.B [W4], W4
0027B0  FB0204     SE W4, W4
0027B2  B9226C     MUL.SU W4, #12, W4
0027B4  780284     MOV W4, W5
0027B6  20C184     MOV #0xC18, W4
0027B8  428284     ADD W5, W4, W5
0027BA  780215     MOV [W5], W4
0027BC  A01004     BSET W4, #1
0027BE  780A84     MOV W4, [W5]
0027C0  37000C     BRA 0x27DA
879:               		else
880:               			Panel[DataIndex].Pressure = ExtracReg(1); 		// La pressione che arriva dal pannello e' in decimi
0027C2  20AA54     MOV #0xAA5, W4
0027C4  784214     MOV.B [W4], W4
0027C6  FB0404     SE W4, W8
0027C8  B3C010     MOV.B #0x1, W0
0027CA  07F7BA     RCALL ExtracReg
0027CC  780200     MOV W0, W4
0027CE  780304     MOV W4, W6
0027D0  B9426C     MUL.SU W8, #12, W4
0027D2  780284     MOV W4, W5
0027D4  20C164     MOV #0xC16, W4
0027D6  428204     ADD W5, W4, W4
0027D8  780A06     MOV W6, [W4]
881:               
882:               		if(Send_WaitModRx(PanelAddres, ReadModCoil, REG_PANEL_SEASON, 16, MaxModReadWait, MaxModReadRetries))	// Il registro dei touch hanno un offset di 1
0027DA  B3C025     MOV.B #0x2, W5
0027DC  200324     MOV #0x32, W4
0027DE  200103     MOV #0x10, W3
0027E0  200022     MOV #0x2, W2
0027E2  B3C011     MOV.B #0x1, W1
0027E4  78401E     MOV.B [W14], W0
0027E6  07F59C     RCALL Send_WaitModRx
0027E8  784200     MOV.B W0, W4
0027EA  524FE0     SUB.B W4, #0x0, [W15]
0027EC  32000B     BRA Z, 0x2804
883:               			Panel[DataIndex].OffLine = 1;
0027EE  20AA54     MOV #0xAA5, W4
0027F0  784214     MOV.B [W4], W4
0027F2  FB0204     SE W4, W4
0027F4  B9226C     MUL.SU W4, #12, W4
0027F6  780284     MOV W4, W5
0027F8  20C184     MOV #0xC18, W4
0027FA  428284     ADD W5, W4, W5
0027FC  780215     MOV [W5], W4
0027FE  A01004     BSET W4, #1
002800  780A84     MOV W4, [W5]
002802  370011     BRA 0x2826
884:               		else
885:               			Panel[DataIndex].FunctionMode = ((ExtracReg(1) & 0x0100) != 0); 		// Estraggo flag stagione: Raffrescamento=0 o Riscaldamento=1
002804  20AA54     MOV #0xAA5, W4
002806  784214     MOV.B [W4], W4
002808  FB0404     SE W4, W8
00280A  B3C010     MOV.B #0x1, W0
00280C  07F799     RCALL ExtracReg
00280E  780200     MOV W0, W4
002810  201005     MOV #0x100, W5
002812  620205     AND W4, W5, W4
002814  A7F004     BTSC W4, #15
002816  EA0204     NEG W4, W4
002818  EA0204     NEG W4, W4
00281A  DE224F     LSR W4, #15, W4
00281C  B9436C     MUL.SU W8, #12, W6
00281E  780306     MOV W6, W6
002820  20C105     MOV #0xC10, W5
002822  430285     ADD W6, W5, W5
002824  780A84     MOV W4, [W5]
886:               	}
887:               }
002826  78044F     MOV [--W15], W8
002828  FA8000     ULNK
00282A  060000     RETURN
888:               
889:               void RefreshAllPanelInPut(void)
890:               {
00282C  FA0000     LNK #0x0
891:               	for(i=Add_PanelRoom; i < (Add_PanelRoom+MaxPanel); i++)
00282E  B3C1E4     MOV.B #0x1E, W4
002830  784304     MOV.B W4, W6
002832  20AA45     MOV #0xAA4, W5
002834  784A86     MOV.B W6, [W5]
002836  37000A     BRA 0x284C
002840  20AA44     MOV #0xAA4, W4
002842  784214     MOV.B [W4], W4
002844  E84204     INC.B W4, W4
002846  784304     MOV.B W4, W6
002848  20AA45     MOV #0xAA4, W5
00284A  784A86     MOV.B W6, [W5]
00284C  20AA45     MOV #0xAA4, W5
00284E  784295     MOV.B [W5], W5
002850  B3C214     MOV.B #0x21, W4
002852  52CF84     SUB.B W5, W4, [W15]
002854  34FFF1     BRA LE, 0x2838
892:               		RefreshPanelInPut(i);
002838  20AA44     MOV #0xAA4, W4
00283A  784214     MOV.B [W4], W4
00283C  784004     MOV.B W4, W0
00283E  07FF23     RCALL RefreshPanelInPut
893:               }
002856  FA8000     ULNK
002858  060000     RETURN
894:               
895:               void RefreshPanelOutPut(char PanelAddres)
896:               {
00285A  FA0002     LNK #0x2
00285C  784F00     MOV.B W0, [W14]
897:               //	int SysError = 0;
898:               /*
899:               	DataIndex = PanelAddres-Add_PanelRoom;
900:               	if(Panel[DataIndex].Enable & !Panel[DataIndex].OffLine)
901:               	{	
902:               
903:               
904:               //	.......
905:               
906:               	}
907:               */
908:               }
00285E  FA8000     ULNK
002860  060000     RETURN
909:               
910:               void RefreshAllPanelOutPut(void)
911:               {
002862  FA0000     LNK #0x0
912:               /*
913:               	for(i=Add_PanelRoom; i < (Add_PanelRoom+MaxPanel); i++)
914:               		RefreshPanelOutPut(i);
915:               */
916:               }
002864  FA8000     ULNK
002866  060000     RETURN
917:               
918:               void InitPanel(void)
919:               {
002868  FA0000     LNK #0x0
920:               /*
921:               	for(i=0; i<MaxPanel; i++)
922:               	{
923:               		if(Panel[i].Enable && !Panel[i].OffLine)
924:               		{
925:               
926:               //			WriteModRegPanel (Add_PanelRoom +i, REG_PANEL_..., valore);
927:               //			WriteModRegPanel (Add_PanelRoom +i, REG_PANEL_..., valore);
928:               //			WriteModRegPanel (Add_PanelRoom +i, REG_PANEL_..., valore);
929:               //			WriteModRegPanel (Add_PanelRoom +i, REG_PANEL_..., valore);
930:               		
931:               		}
932:               	}
933:               */
934:               }
00286A  FA8000     ULNK
00286C  060000     RETURN
935:               
936:               
---  D:/WORK3/Lavori/TERMODINAMICA/Work/FW/1 - Generico/Split/Split v.8.4.22 - Working/ProtocolloComunicazioneSec.c
1:                 //----------------------------------------------------------------------------------
2:                 //	Progect name:	ProtocolloComunicazione.c
3:                 //	Device:			PIC18F4550 @ 20Mhz (PLL 96 Mhz)
4:                 //	Autor:			Emanuele
5:                 //	Date:			22/05/2011
6:                 //	Description:	Corpo delle funzioni che gestiscono la comunicazione con il sistema
7:                 //----------------------------------------------------------------------------------
8:                 
9:                 //----------------------------------------------------------------------------------
10:                //	Include
11:                //----------------------------------------------------------------------------------
12:                #include "MicroModelSelection.h"
13:                #ifdef GB210
14:                	#include <p24FJ256GB210.h>
15:                #else
16:                	#include <p24FJ256GB110.h>
17:                #endif
18:                #include <stdio.h>
19:                #include "DefinePeriferiche.h"
20:                #include "Timer.h"
21:                #include "usart.h"
22:                #include "ADC.h"
23:                #include "PWM.h"
24:                #include "EEPROM.h"
25:                #include "Valvola_PassoPasso.h"
26:                #include "Driver_Comunicazione.h"
27:                #include "Driver_ComunicazioneSec.h"
28:                #include "ProtocolloComunicazione.h"
29:                #include "ProtocolloComunicazioneSec.h"
30:                #include "Core.h"
31:                
32:                //----------------------------------------------------------------------------------
33:                //	Funzioni
34:                //----------------------------------------------------------------------------------
35:                unsigned char WaitRxSec(int TimeOut_ms)
36:                {
00749C  FA0002     LNK #0x2
00749E  780F00     MOV W0, [W14]
37:                	TimeOutPktRxSec.Value = 0;			// resetto il timer per il time out della risposta
0074A0  EB0200     CLR W4
0074A2  885494     MOV W4, TimeOutPktRxSec
38:                	TimeOutPktRxSec.TimeOut = 0;		//
0074A4  A92A96     BCLR 0xA96, #1
39:                	TimeOutPktRxSec.Time = TimeOut_ms;	// lo configuro come richiesto
0074A6  78021E     MOV [W14], W4
0074A8  8854A4     MOV W4, 0xA94
40:                	TimeOutPktRxSec.Enable = 1;			// lo faccio partire
0074AA  A80A96     BSET 0xA96, #0
41:                
42:                	while((TimeOutPktRxSec.TimeOut == 0) && (LastRxSec.Valid_Data == 0))	// attendo un evento
0074AC  000000     NOP
0074AE  370001     BRA 0x74B2
0074B2  8054B4     MOV 0xA96, W4
0074B4  620262     AND W4, #0x2, W4
0074B6  520FE0     SUB W4, #0x0, [W15]
0074B8  3A0004     BRA NZ, 0x74C2
0074BA  209844     MOV #0x984, W4
0074BC  784214     MOV.B [W4], W4
0074BE  524FE0     SUB.B W4, #0x0, [W15]
0074C0  32FFF7     BRA Z, 0x74B0
43:                		continue;
0074B0  000000     NOP
44:                
45:                	TimeOutPktRxSec.Enable = 0;			// fermo il timer
0074C2  A90A96     BCLR 0xA96, #0
46:                	TimeOutPktRxSec.TimeOut = 0;		// resetto il time out
0074C4  A92A96     BCLR 0xA96, #1
47:                
48:                	if(LastRxSec.Valid_Data == 1)		// se ho ricevuto un dato valido 
0074C6  209844     MOV #0x984, W4
0074C8  784214     MOV.B [W4], W4
0074CA  524FE1     SUB.B W4, #0x1, [W15]
0074CC  3A0020     BRA NZ, 0x750E
49:                	{
50:                		if((LastRxSec.Mitt_Add == BufferTxSec.Dest_Add) &
0074CE  2097C5     MOV #0x97C, W5
0074D0  784295     MOV.B [W5], W5
0074D2  2096F4     MOV #0x96F, W4
0074D4  784214     MOV.B [W4], W4
0074D6  6AC284     XOR.B W5, W4, W5
0074D8  FB8205     ZE W5, W4
0074DA  E90204     DEC W4, W4
0074DC  DE224F     LSR W4, #15, W4
0074DE  784284     MOV.B W4, W5
0074F2  62C204     AND.B W5, W4, W4
0074F4  FB8284     ZE W4, W5
007506  520FE0     SUB W4, #0x0, [W15]
007508  320002     BRA Z, 0x750E
51:                			(LastRxSec.Comando == BufferTxSec.Comando) &
0074E0  2097D6     MOV #0x97D, W6
0074E2  784316     MOV.B [W6], W6
0074E4  209714     MOV #0x971, W4
0074E6  784214     MOV.B [W4], W4
0074E8  6B4204     XOR.B W6, W4, W4
0074EA  FB8204     ZE W4, W4
0074EC  E90204     DEC W4, W4
0074EE  DE224F     LSR W4, #15, W4
0074F0  784204     MOV.B W4, W4
007504  628204     AND W5, W4, W4
52:                			(LastRxSec.Registro == BufferTxSec.Registro)) 	// verifico il pacchetto
0074F6  804BF6     MOV 0x97E, W6
0074F8  804B94     MOV 0x972, W4
0074FA  6B0204     XOR W6, W4, W4
0074FC  A7F004     BTSC W4, #15
0074FE  EA0204     NEG W4, W4
007500  E90204     DEC W4, W4
007502  DE224F     LSR W4, #15, W4
53:                			return 0;				// ritorno 0 se è ok
00750A  EB4200     CLR.B W4
00750C  370001     BRA 0x7510
54:                	}
55:                	return 1;						// ritorno 1
00750E  B3C014     MOV.B #0x1, W4
56:                }
007510  784004     MOV.B W4, W0
007512  FA8000     ULNK
007514  060000     RETURN
57:                
58:                unsigned char Send_WaitRx_Sec(char Address, char Comando, int Registro, int Data, int TimeOut_ms, char Retry)
59:                {
007516  FA000C     LNK #0xC
007518  984720     MOV.B W0, [W14+2]
00751A  984731     MOV.B W1, [W14+3]
00751C  980722     MOV W2, [W14+4]
00751E  980733     MOV W3, [W14+6]
007520  980744     MOV W4, [W14+8]
007522  984F25     MOV.B W5, [W14+10]
60:                	char Result = 0;
007524  EB4200     CLR.B W4
007526  984714     MOV.B W4, [W14+1]
61:                	char RetryCnt = 0;
007528  EB4200     CLR.B W4
00752A  784F04     MOV.B W4, [W14]
62:                	while (RetryCnt < Retry)
00752C  370012     BRA 0x7552
007552  904A2E     MOV.B [W14+10], W4
007554  78429E     MOV.B [W14], W5
007556  52CF84     SUB.B W5, W4, [W15]
007558  35FFEA     BRA LT, 0x752E
63:                	{	
64:                		RetryCnt +=1;
00752E  78421E     MOV.B [W14], W4
007530  E84204     INC.B W4, W4
007532  784F04     MOV.B W4, [W14]
65:                		Write_Cmd_Sec(&BufferTxSec, Address, Comando, Registro, Data);
007534  90023E     MOV [W14+6], W4
007536  9001AE     MOV [W14+4], W3
007538  90413E     MOV.B [W14+3], W2
00753A  9040AE     MOV.B [W14+2], W1
00753C  2096E0     MOV #0x96E, W0
00753E  07083F     RCALL Write_Cmd_Sec
66:                		Result = WaitRxSec(TimeOut_ms);
007540  90004E     MOV [W14+8], W0
007542  07FFAC     RCALL WaitRxSec
007544  784200     MOV.B W0, W4
007546  984714     MOV.B W4, [W14+1]
67:                		if (Result == 0)	// se ricevo un pacchetto valido 
007548  90421E     MOV.B [W14+1], W4
00754A  524FE0     SUB.B W4, #0x0, [W15]
00754C  3A0002     BRA NZ, 0x7552
68:                			return 0;
00754E  EB4200     CLR.B W4
007550  370005     BRA 0x755C
69:                	}
70:                	return 1;				// se non ho nessuna risposta valida per dopo il numero di tentativi richiesti
00755A  B3C014     MOV.B #0x1, W4
71:                }
00755C  784004     MOV.B W4, W0
00755E  FA8000     ULNK
007560  060000     RETURN
72:                
73:                unsigned char Send_WriteReg_Sec(char Address, int Registro, int Data, int TimeOut_ms, char Retry)
74:                {
007562  FA000C     LNK #0xC
007564  984720     MOV.B W0, [W14+2]
007566  980721     MOV W1, [W14+4]
007568  980732     MOV W2, [W14+6]
00756A  980743     MOV W3, [W14+8]
00756C  984F24     MOV.B W4, [W14+10]
75:                	char Result = 1;
00756E  B3C014     MOV.B #0x1, W4
007570  984714     MOV.B W4, [W14+1]
76:                	char RetryCnt = 0;
007572  EB4200     CLR.B W4
007574  784F04     MOV.B W4, [W14]
77:                	while (RetryCnt < Retry)
007576  370027     BRA 0x75C6
0075C6  904A2E     MOV.B [W14+10], W4
0075C8  78429E     MOV.B [W14], W5
0075CA  52CF84     SUB.B W5, W4, [W15]
0075CC  35FFD5     BRA LT, 0x7578
78:                	{
79:                		RetryCnt +=1;
007578  78421E     MOV.B [W14], W4
00757A  E84204     INC.B W4, W4
00757C  784F04     MOV.B W4, [W14]
80:                		Write_Cmd_Sec(&BufferTxSec, Address, WriteReg, Registro, Data);
00757E  90023E     MOV [W14+6], W4
007580  9001AE     MOV [W14+4], W3
007582  B3C042     MOV.B #0x4, W2
007584  9040AE     MOV.B [W14+2], W1
007586  2096E0     MOV #0x96E, W0
007588  07081A     RCALL Write_Cmd_Sec
81:                		Result = WaitRxSec(TimeOut_ms);
00758A  90004E     MOV [W14+8], W0
00758C  07FF87     RCALL WaitRxSec
00758E  784200     MOV.B W0, W4
007590  984714     MOV.B W4, [W14+1]
82:                		if ((Result == 0) & (LastRxSec.Data == Ack))
007592  90421E     MOV.B [W14+1], W4
007594  FB8204     ZE W4, W4
007596  E90204     DEC W4, W4
007598  DE224F     LSR W4, #15, W4
00759A  784284     MOV.B W4, W5
00759C  804C06     MOV 0x980, W6
00759E  280004     MOV #0x8000, W4
0075A0  6B0204     XOR W6, W4, W4
0075A2  A7F004     BTSC W4, #15
0075A4  EA0204     NEG W4, W4
0075A6  E90204     DEC W4, W4
0075A8  DE224F     LSR W4, #15, W4
0075AA  784204     MOV.B W4, W4
0075AC  62C204     AND.B W5, W4, W4
0075AE  524FE0     SUB.B W4, #0x0, [W15]
0075B0  320006     BRA Z, 0x75BE
83:                		{
84:                			LastRxSec.Valid_Data = 0;
0075B2  EB4200     CLR.B W4
0075B4  784304     MOV.B W4, W6
0075B6  209845     MOV #0x984, W5
0075B8  784A86     MOV.B W6, [W5]
85:                			return 0;
0075BA  EB4200     CLR.B W4
0075BC  37000D     BRA 0x75D8
86:                		}
87:                		LastRxSec.Valid_Data = 0;
0075BE  EB4200     CLR.B W4
0075C0  784304     MOV.B W4, W6
0075C2  209845     MOV #0x984, W5
0075C4  784A86     MOV.B W6, [W5]
88:                	}
89:                	LastRxSec.Valid_Data = 0;
0075CE  EB4200     CLR.B W4
0075D0  784304     MOV.B W4, W6
0075D2  209845     MOV #0x984, W5
0075D4  784A86     MOV.B W6, [W5]
90:                	return 1;
0075D6  B3C014     MOV.B #0x1, W4
91:                }
0075D8  784004     MOV.B W4, W0
0075DA  FA8000     ULNK
0075DC  060000     RETURN
92:                
93:                unsigned char SendBrc_WriteReg_Sec(char Cmd, int Registro, int Data, int TimeOut_ms, char Retry)
94:                {
0075DE  FA000C     LNK #0xC
0075E0  984720     MOV.B W0, [W14+2]
0075E2  980721     MOV W1, [W14+4]
0075E4  980732     MOV W2, [W14+6]
0075E6  980743     MOV W3, [W14+8]
0075E8  984F24     MOV.B W4, [W14+10]
95:                	char Result = 1;
0075EA  B3C014     MOV.B #0x1, W4
0075EC  984714     MOV.B W4, [W14+1]
96:                	char RetryCnt = 0;
0075EE  EB4200     CLR.B W4
0075F0  784F04     MOV.B W4, [W14]
97:                	while (RetryCnt < Retry)
0075F2  370017     BRA 0x7622
007622  904A2E     MOV.B [W14+10], W4
007624  78429E     MOV.B [W14], W5
007626  52CF84     SUB.B W5, W4, [W15]
007628  35FFE5     BRA LT, 0x75F4
98:                	{
99:                		RetryCnt +=1;
0075F4  78421E     MOV.B [W14], W4
0075F6  E84204     INC.B W4, W4
0075F8  784F04     MOV.B W4, [W14]
100:               		Write_brc_Cmd_Sec(&BufferTxSec, Cmd, Registro, Data);
0075FA  9001BE     MOV [W14+6], W3
0075FC  90012E     MOV [W14+4], W2
0075FE  9040AE     MOV.B [W14+2], W1
007600  2096E0     MOV #0x96E, W0
007602  070810     RCALL Write_brc_Cmd_Sec
101:               
102:               		TimeOutPktRxSec.Value = 0;			// resetto il timer per il time out della risposta
007604  EB0200     CLR W4
007606  885494     MOV W4, TimeOutPktRxSec
103:               		TimeOutPktRxSec.TimeOut = 0;		//
007608  A92A96     BCLR 0xA96, #1
104:               		TimeOutPktRxSec.Time = TimeOut_ms;	// lo configuro come richiesto
00760A  90024E     MOV [W14+8], W4
00760C  8854A4     MOV W4, 0xA94
105:               		TimeOutPktRxSec.Enable = 1;			// lo faccio partire
00760E  A80A96     BSET 0xA96, #0
106:               	
107:               		while(TimeOutPktRxSec.TimeOut == 0)	// attendo un evento
007610  000000     NOP
007612  370001     BRA 0x7616
007616  8054B4     MOV 0xA96, W4
007618  620262     AND W4, #0x2, W4
00761A  520FE0     SUB W4, #0x0, [W15]
00761C  32FFFB     BRA Z, 0x7614
108:               			continue;
007614  000000     NOP
109:               	
110:               		TimeOutPktRxSec.Enable = 0;			// fermo il timer
00761E  A90A96     BCLR 0xA96, #0
111:               		TimeOutPktRxSec.TimeOut = 0;		// resetto il time out
007620  A92A96     BCLR 0xA96, #1
112:               	}
113:               	LastRx.Valid_Data = 0;
00762A  EB4200     CLR.B W4
00762C  784304     MOV.B W4, W6
00762E  209585     MOV #0x958, W5
007630  784A86     MOV.B W6, [W5]
114:               	return 0;
007632  EB4200     CLR.B W4
115:               }
007634  784004     MOV.B W4, W0
007636  FA8000     ULNK
007638  060000     RETURN
116:               
117:               unsigned FuncReadReg_Sec (char Address, int REG, int * StoreReg, unsigned OffLineFlag)
118:               {
00763A  FA0008     LNK #0x8
00763C  784F00     MOV.B W0, [W14]
00763E  980711     MOV W1, [W14+2]
007640  980722     MOV W2, [W14+4]
007642  980733     MOV W3, [W14+6]
119:               	if(!OffLineFlag)
007644  90023E     MOV [W14+6], W4
007646  520FE0     SUB W4, #0x0, [W15]
007648  3A0014     BRA NZ, 0x7672
120:               	{
121:               		if(!Send_WaitRx_Sec(Address, ReadReg, REG, 0, MaxReadWait, MaxReadRetries))
00764A  B3C025     MOV.B #0x2, W5
00764C  200324     MOV #0x32, W4
00764E  EB0180     CLR W3
007650  90011E     MOV [W14+2], W2
007652  B3C021     MOV.B #0x2, W1
007654  78401E     MOV.B [W14], W0
007656  07FF5F     RCALL Send_WaitRx_Sec
007658  784200     MOV.B W0, W4
00765A  524FE0     SUB.B W4, #0x0, [W15]
00765C  3A000A     BRA NZ, 0x7672
122:               		{
123:               			(*StoreReg) = LastRxSec.Data;
00765E  804C04     MOV 0x980, W4
007660  780284     MOV W4, W5
007662  90022E     MOV [W14+4], W4
007664  780A05     MOV W5, [W4]
124:               			LastRxSec.Valid_Data = 0;
007666  EB4200     CLR.B W4
007668  784304     MOV.B W4, W6
00766A  209845     MOV #0x984, W5
00766C  784A86     MOV.B W6, [W5]
125:               			return 0;
00766E  EB0200     CLR W4
007670  370001     BRA 0x7674
126:               		}
127:               	}
128:               	return 1;// se non ha risposto
007672  200014     MOV #0x1, W4
129:               }
007674  780004     MOV W4, W0
007676  FA8000     ULNK
007678  060000     RETURN
130:               
131:               unsigned FuncWriteReg_Sec (char Address, int REG, int SendData, unsigned OffLineFlag)
132:               {
00767A  FA0008     LNK #0x8
00767C  784F00     MOV.B W0, [W14]
00767E  980711     MOV W1, [W14+2]
007680  980722     MOV W2, [W14+4]
007682  980733     MOV W3, [W14+6]
133:               	if(!OffLineFlag)
007684  90023E     MOV [W14+6], W4
007686  520FE0     SUB W4, #0x0, [W15]
007688  3A0009     BRA NZ, 0x769C
134:               	{
135:               		return Send_WriteReg_Sec(Address, REG, SendData, MaxWriteWait, MaxWriteRetries);
00768A  B3C024     MOV.B #0x2, W4
00768C  200C83     MOV #0xC8, W3
00768E  90012E     MOV [W14+4], W2
007690  90009E     MOV [W14+2], W1
007692  78401E     MOV.B [W14], W0
007694  07FF66     RCALL Send_WriteReg_Sec
007696  784200     MOV.B W0, W4
007698  FB8204     ZE W4, W4
00769A  370001     BRA 0x769E
136:               	}
137:               	return 1;
00769C  200014     MOV #0x1, W4
138:               }
00769E  780004     MOV W4, W0
0076A0  FA8000     ULNK
0076A2  060000     RETURN
139:               
140:               unsigned FuncWriteBrcReg_Sec (char Comando, int REG, int SendData)
141:               {
0076A4  FA0006     LNK #0x6
0076A6  784F00     MOV.B W0, [W14]
0076A8  980711     MOV W1, [W14+2]
0076AA  980722     MOV W2, [W14+4]
142:               	return SendBrc_WriteReg_Sec(Comando, REG, SendData, WriteBrcWait, WriteBrcRetries);
0076AC  B3C024     MOV.B #0x2, W4
0076AE  2000A3     MOV #0xA, W3
0076B0  90012E     MOV [W14+4], W2
0076B2  90009E     MOV [W14+2], W1
0076B4  78401E     MOV.B [W14], W0
0076B6  07FF93     RCALL SendBrc_WriteReg_Sec
0076B8  784200     MOV.B W0, W4
0076BA  FB8204     ZE W4, W4
143:               }
0076BC  780004     MOV W4, W0
0076BE  FA8000     ULNK
0076C0  060000     RETURN
144:               
145:               void CheckModuli_Sec(void)
146:               {
0076C2  FA0002     LNK #0x2
147:               	char Result = 0;
0076C4  EB4200     CLR.B W4
0076C6  984714     MOV.B W4, [W14+1]
148:               	char i = 0;
0076C8  EB4200     CLR.B W4
0076CA  784F04     MOV.B W4, [W14]
149:               
150:               	// Scansiono la rete alla ricerca dei moduli di gestione delle valvole e degli split
151:               	for(i=0;i<Max_Unit_Sec; i++)
0076CC  EB4200     CLR.B W4
0076CE  784F04     MOV.B W4, [W14]
0076D0  37004D     BRA 0x776C
00776A  E84F1E     INC.B [W14], [W14]
00776C  78421E     MOV.B [W14], W4
00776E  524FEF     SUB.B W4, #0xF, [W15]
007770  34FFB0     BRA LE, 0x76D2
152:               	{
153:               		if(i == Me.My_Address)
0076D2  FB029E     SE [W14], W5
0076D4  20BA44     MOV #0xBA4, W4
0076D6  784214     MOV.B [W4], W4
0076D8  FB8204     ZE W4, W4
0076DA  528F84     SUB W5, W4, [W15]
0076DC  3A0001     BRA NZ, 0x76E0
154:               			i++;
0076DE  E84F1E     INC.B [W14], [W14]
155:               		Result = Send_WaitRx_Sec(i, Chek, 0, 0, MaxChkWait, MaxChkRetries);
0076E0  B3C035     MOV.B #0x3, W5
0076E2  200C84     MOV #0xC8, W4
0076E4  EB0180     CLR W3
0076E6  EB0100     CLR W2
0076E8  B3C081     MOV.B #0x8, W1
0076EA  78401E     MOV.B [W14], W0
0076EC  07FF14     RCALL Send_WaitRx_Sec
0076EE  784200     MOV.B W0, W4
0076F0  984714     MOV.B W4, [W14+1]
156:               		Room[i].OffLine = (Result != 0);
0076F2  FB021E     SE [W14], W4
0076F4  90429E     MOV.B [W14+1], W5
0076F6  FB8285     ZE W5, W5
0076F8  EA0285     NEG W5, W5
0076FA  DE2ACF     LSR W5, #15, W5
0076FC  784305     MOV.B W5, W6
0076FE  B9227E     MUL.SU W4, #30, W4
007700  780284     MOV W4, W5
007702  20C5A4     MOV #0xC5A, W4
007704  428204     ADD W5, W4, W4
007706  FB8286     ZE W6, W5
007708  6282E1     AND W5, #0x1, W5
00770A  428285     ADD W5, W5, W5
00770C  780394     MOV [W4], W7
00770E  2FFFD6     MOV #0xFFFD, W6
007710  638306     AND W7, W6, W6
007712  728286     IOR W5, W6, W5
007714  780A05     MOV W5, [W4]
157:               		LastRx.Valid_Data = 0;
007716  EB4200     CLR.B W4
007718  784304     MOV.B W4, W6
00771A  209585     MOV #0x958, W5
00771C  784A86     MOV.B W6, [W5]
158:               		Room[i].Enable = !Room[i].OffLine;
00771E  FB039E     SE [W14], W7
007720  FB021E     SE [W14], W4
007722  B9227E     MUL.SU W4, #30, W4
007724  780204     MOV W4, W4
007726  4202FC     ADD W4, #0x1C, W5
007728  20C3E4     MOV #0xC3E, W4
00772A  428204     ADD W5, W4, W4
00772C  780214     MOV [W4], W4
00772E  D10204     LSR W4, W4
007730  624261     AND.B W4, #0x1, W4
007732  FB8204     ZE W4, W4
007734  E90204     DEC W4, W4
007736  DE224F     LSR W4, #15, W4
007738  784304     MOV.B W4, W6
00773A  B93A7E     MUL.SU W7, #30, W4
00773C  780284     MOV W4, W5
00773E  20C5A4     MOV #0xC5A, W4
007740  428204     ADD W5, W4, W4
007742  FB8286     ZE W6, W5
007744  6282E1     AND W5, #0x1, W5
007746  780394     MOV [W4], W7
007748  2FFFE6     MOV #0xFFFE, W6
00774A  638306     AND W7, W6, W6
00774C  728286     IOR W5, W6, W5
00774E  780A05     MOV W5, [W4]
159:               		if(Room[i].Enable)		// se ho almeno uno split
007750  FB021E     SE [W14], W4
007752  B9227E     MUL.SU W4, #30, W4
007754  780204     MOV W4, W4
007756  4202FC     ADD W4, #0x1C, W5
007758  20C3E4     MOV #0xC3E, W4
00775A  428204     ADD W5, W4, W4
00775C  780214     MOV [W4], W4
00775E  784204     MOV.B W4, W4
007760  624261     AND.B W4, #0x1, W4
007762  524FE0     SUB.B W4, #0x0, [W15]
007764  320002     BRA Z, 0x776A
160:               			EnableMySecBus =1;	// segnalo al sistema di attivare la scansione
007766  200014     MOV #0x1, W4
007768  8870F4     MOV W4, EnableMySecBus
161:               	}
162:               /*
163:               	// Scansiono la rete alla ricerca dei moduli Dimmer
164:               	for(i=0; i<Max_Dimmer_Sec; i++)
165:               	{
166:               		Result = Send_WaitRx(Add_Dimmer_1+i, Chek, 0, 0, MaxChkWait, MaxChkRetries);
167:               		Dimmer[i].Enable = (Result == 0);
168:               		Dimmer[i].OffLine = 0;
169:               		LastRx.Valid_Data = 0;
170:               	}
171:               */
172:               }
007772  FA8000     ULNK
007774  060000     RETURN
173:               
174:               void ResumeOffLine_Sec(char * Cnt)
175:               {
007776  FA0004     LNK #0x4
007778  980710     MOV W0, [W14+2]
176:               	char Result = 0;
00777A  EB4200     CLR.B W4
00777C  784F04     MOV.B W4, [W14]
177:               
178:               	if(EnableMySecBus)
00777E  8070F4     MOV EnableMySecBus, W4
007780  520FE0     SUB W4, #0x0, [W15]
007782  32004A     BRA Z, 0x7818
179:               	{
180:               		if((Room[(*Cnt)].Enable == 1) && (Room[(*Cnt)].OffLine == 1))
007784  90021E     MOV [W14+2], W4
007786  784214     MOV.B [W4], W4
007788  FB0204     SE W4, W4
00778A  B9227E     MUL.SU W4, #30, W4
00778C  780204     MOV W4, W4
00778E  4202FC     ADD W4, #0x1C, W5
007790  20C3E4     MOV #0xC3E, W4
007792  428204     ADD W5, W4, W4
007794  780214     MOV [W4], W4
007796  784204     MOV.B W4, W4
007798  624261     AND.B W4, #0x1, W4
00779A  524FE1     SUB.B W4, #0x1, [W15]
00779C  3A0030     BRA NZ, 0x77FE
00779E  90021E     MOV [W14+2], W4
0077A0  784214     MOV.B [W4], W4
0077A2  FB0204     SE W4, W4
0077A4  B9227E     MUL.SU W4, #30, W4
0077A6  780204     MOV W4, W4
0077A8  4202FC     ADD W4, #0x1C, W5
0077AA  20C3E4     MOV #0xC3E, W4
0077AC  428204     ADD W5, W4, W4
0077AE  780214     MOV [W4], W4
0077B0  D10204     LSR W4, W4
0077B2  624261     AND.B W4, #0x1, W4
0077B4  524FE1     SUB.B W4, #0x1, [W15]
0077B6  3A0023     BRA NZ, 0x77FE
181:               		{
182:               			Result = Send_WaitRx_Sec((*Cnt), Chek, 0, 0, MaxChkWait, MaxChkRetries);
0077B8  90021E     MOV [W14+2], W4
0077BA  784314     MOV.B [W4], W6
0077BC  B3C035     MOV.B #0x3, W5
0077BE  200C84     MOV #0xC8, W4
0077C0  EB0180     CLR W3
0077C2  EB0100     CLR W2
0077C4  B3C081     MOV.B #0x8, W1
0077C6  784006     MOV.B W6, W0
0077C8  07FEA6     RCALL Send_WaitRx_Sec
0077CA  784200     MOV.B W0, W4
0077CC  784F04     MOV.B W4, [W14]
183:               			Room[(*Cnt)].OffLine = (Result != 0);
0077CE  90021E     MOV [W14+2], W4
0077D0  784214     MOV.B [W4], W4
0077D2  FB0204     SE W4, W4
0077D4  78431E     MOV.B [W14], W6
0077D6  FB8286     ZE W6, W5
0077D8  EA0285     NEG W5, W5
0077DA  DE2ACF     LSR W5, #15, W5
0077DC  784305     MOV.B W5, W6
0077DE  B9227E     MUL.SU W4, #30, W4
0077E0  780284     MOV W4, W5
0077E2  20C5A4     MOV #0xC5A, W4
0077E4  428204     ADD W5, W4, W4
0077E6  FB8286     ZE W6, W5
0077E8  6282E1     AND W5, #0x1, W5
0077EA  428285     ADD W5, W5, W5
0077EC  780394     MOV [W4], W7
0077EE  2FFFD6     MOV #0xFFFD, W6
0077F0  638306     AND W7, W6, W6
0077F2  728286     IOR W5, W6, W5
0077F4  780A05     MOV W5, [W4]
184:               			LastRxSec.Valid_Data = 0;
0077F6  EB4200     CLR.B W4
0077F8  784304     MOV.B W4, W6
0077FA  209845     MOV #0x984, W5
0077FC  784A86     MOV.B W6, [W5]
185:               		}
186:               		(*Cnt) += 1;
0077FE  90021E     MOV [W14+2], W4
007800  784214     MOV.B [W4], W4
007802  E84204     INC.B W4, W4
007804  784284     MOV.B W4, W5
007806  90021E     MOV [W14+2], W4
007808  784A05     MOV.B W5, [W4]
187:               		if((*Cnt) >= Max_Unit_Sec)
00780A  90021E     MOV [W14+2], W4
00780C  784214     MOV.B [W4], W4
00780E  524FEF     SUB.B W4, #0xF, [W15]
007810  340003     BRA LE, 0x7818
188:               			(*Cnt) = 0;
007812  90021E     MOV [W14+2], W4
007814  EB4280     CLR.B W5
007816  784A05     MOV.B W5, [W4]
189:               	}
190:               /*
191:               	else
192:               	{
193:               		if((*Cnt) < (Max_Room+Max_Dimmer))		// Provo a recuperare i moduli dimmer
194:               		{
195:               			CurrentId = (*Cnt) - Max_Room;
196:               			if((Dimmer[CurrentId].Enable == 1) & (Dimmer[CurrentId].OffLine == 1))
197:               			{
198:               				Result = Send_WaitRx(Add_Dimmer_1+CurrentId, Chek, 0, 0, MaxChkWait, MaxChkRetries);
199:               				Dimmer[CurrentId].OffLine= (Result != 0);
200:               				LastRx.Valid_Data = 0;
201:               			}
202:               		}
203:               	}
204:               
205:               */
206:               }
007818  FA8000     ULNK
00781A  060000     RETURN
207:               
208:               void RefreshInPutRoom_Sec(TypSplitSlave * DataStore, char Address)
209:               {
00781C  FA0004     LNK #0x4
00781E  780F00     MOV W0, [W14]
007820  984721     MOV.B W1, [W14+2]
210:               	if(DataStore->Enable == 1)		// se abilitato e OnLine
007822  78021E     MOV [W14], W4
007824  900A64     MOV [W4+28], W4
007826  620261     AND W4, #0x1, W4
007828  520FE0     SUB W4, #0x0, [W15]
00782A  320018     BRA Z, 0x785C
211:               		DataStore->OffLine = FuncReadReg_Sec (Address, REG_SPLIT_STATUS, &(DataStore->SplitStatus), DataStore->OffLine);
00782C  78021E     MOV [W14], W4
00782E  900A64     MOV [W4+28], W4
007830  D10204     LSR W4, W4
007832  624261     AND.B W4, #0x1, W4
007834  FB8284     ZE W4, W5
007836  78031E     MOV [W14], W6
007838  43027A     ADD W6, #0x1A, W4
00783A  780185     MOV W5, W3
00783C  780104     MOV W4, W2
00783E  2005A1     MOV #0x5A, W1
007840  90402E     MOV.B [W14+2], W0
007842  07FEFB     RCALL FuncReadReg_Sec
007844  780200     MOV W0, W4
007846  784204     MOV.B W4, W4
007848  6242E1     AND.B W4, #0x1, W5
00784A  78021E     MOV [W14], W4
00784C  FB8285     ZE W5, W5
00784E  6282E1     AND W5, #0x1, W5
007850  428285     ADD W5, W5, W5
007852  900BE4     MOV [W4+28], W7
007854  2FFFD6     MOV #0xFFFD, W6
007856  638306     AND W7, W6, W6
007858  728286     IOR W5, W6, W5
00785A  980A65     MOV W5, [W4+28]
212:               }
00785C  FA8000     ULNK
00785E  060000     RETURN
213:               
214:               
215:               /*
216:               void RefreshInPutDimmer_Sec(TypDimmer * DataStore, char Address)
217:               {
218:               	if(DataStore->Enable == 1)			// se abilitato e OnLine
219:               	{
220:               		DataStore->OffLine = FuncReadReg (Add_Dimmer_1 + Address, REG_OUT_CH1, &(DataStore->Ch1), DataStore->OffLine);
221:               		DataStore->OffLine = FuncReadReg (Add_Dimmer_1 + Address, REG_OUT_CH2, &(DataStore->Ch2), DataStore->OffLine);
222:               		DataStore->OffLine = FuncReadReg (Add_Dimmer_1 + Address, REG_OUT_CH3, &(DataStore->Ch3), DataStore->OffLine);
223:               		DataStore->OffLine = FuncReadReg (Add_Dimmer_1 + Address, REG_OUT_CH4, &(DataStore->Ch4), DataStore->OffLine);
224:               		DataStore->OffLine = FuncReadReg (Add_Dimmer_1 + Address, REG_OUT_CH5, &(DataStore->Ch5), DataStore->OffLine);
225:               		DataStore->OffLine = FuncReadReg (Add_Dimmer_1 + Address, REG_OUT_CH6, &(DataStore->Ch6), DataStore->OffLine);
226:               	}
227:               
228:               }
229:               */
230:               
231:               
232:               void RefreshAllInPut_Sec(void)
233:               {	
007860  FA0002     LNK #0x2
234:               	char i=0;
007862  EB4200     CLR.B W4
007864  784F04     MOV.B W4, [W14]
235:               
236:               	if(EnableMySecBus)
007866  8070F4     MOV EnableMySecBus, W4
007868  520FE0     SUB W4, #0x0, [W15]
00786A  32000F     BRA Z, 0x788A
237:               	{
238:               		for(i=0; i<Max_Unit_Sec; i++)
00786C  EB4200     CLR.B W4
00786E  784F04     MOV.B W4, [W14]
007870  370009     BRA 0x7884
007882  E84F1E     INC.B [W14], [W14]
007884  78421E     MOV.B [W14], W4
007886  524FEF     SUB.B W4, #0xF, [W15]
007888  34FFF4     BRA LE, 0x7872
239:               			RefreshInPutRoom_Sec(&Room[i], i);
007872  FB021E     SE [W14], W4
007874  B9227E     MUL.SU W4, #30, W4
007876  780284     MOV W4, W5
007878  20C3E4     MOV #0xC3E, W4
00787A  428204     ADD W5, W4, W4
00787C  78409E     MOV.B [W14], W1
00787E  780004     MOV W4, W0
007880  07FFCD     RCALL RefreshInPutRoom_Sec
240:               				
241:               	/*	for(i=0; i<Max_Dimmer_Sec; i++)
242:               			RefreshInPutDimmer_Sec(&Dimmer[i], i);
243:               	*/
244:               	}
245:               }
00788A  FA8000     ULNK
00788C  060000     RETURN
246:               
247:               void RefreshOutPutRoom_Sec(void)
248:               {
00788E  FA0002     LNK #0x2
249:               	int SlaveMode = 0;
007890  EB0200     CLR W4
007892  780F04     MOV W4, [W14]
250:               
251:               	switch(Me.Function_Mode)
007894  805C24     MOV 0xB84, W4
007896  520FE4     SUB W4, #0x4, [W15]
007898  320003     BRA Z, 0x78A0
00789A  520FE8     SUB W4, #0x8, [W15]
00789C  320004     BRA Z, 0x78A6
00789E  370006     BRA 0x78AC
252:               	{
253:               		case CoreRiscaldamento:
254:               			SlaveMode = CoreSlaveCaldo;
0078A0  200114     MOV #0x11, W4
0078A2  780F04     MOV W4, [W14]
255:               			break;
0078A4  370006     BRA 0x78B2
256:               		case CoreRaffrescamento:
257:               			SlaveMode = CoreSlaveFreddo;
0078A6  200124     MOV #0x12, W4
0078A8  780F04     MOV W4, [W14]
258:               			break;
0078AA  370003     BRA 0x78B2
259:               		default:
260:               			SlaveMode = Me.Function_Mode;
0078AC  805C24     MOV 0xB84, W4
0078AE  780F04     MOV W4, [W14]
261:               			break;
0078B0  000000     NOP
262:               	}
263:               
264:               	FuncWriteBrcReg_Sec (WriteSplitRegBrdCst, REG_SPLIT_FUNCTION_MODE, SlaveMode);
0078B2  78011E     MOV [W14], W2
0078B4  200271     MOV #0x27, W1
0078B6  B3C050     MOV.B #0x5, W0
0078B8  07FEF5     RCALL FuncWriteBrcReg_Sec
265:               	FuncWriteBrcReg_Sec (WriteSplitRegBrdCst, REG_SPLIT_VENTIL_MODE, Me.Ventil_Mode);
0078BA  805C54     MOV 0xB8A, W4
0078BC  780104     MOV W4, W2
0078BE  200261     MOV #0x26, W1
0078C0  B3C050     MOV.B #0x5, W0
0078C2  07FEF0     RCALL FuncWriteBrcReg_Sec
266:               	FuncWriteBrcReg_Sec (WriteSplitRegBrdCst, REG_SPLIT_CURRENT_SP, Me.SP);
0078C4  805BC4     MOV 0xB78, W4
0078C6  780104     MOV W4, W2
0078C8  200281     MOV #0x28, W1
0078CA  B3C050     MOV.B #0x5, W0
0078CC  07FEEB     RCALL FuncWriteBrcReg_Sec
267:               	FuncWriteBrcReg_Sec (WriteSplitRegBrdCst, REG_SPLIT_CURRENT_EVAP_TEMP, Me.Evap_Temp);
0078CE  805BF4     MOV 0xB7E, W4
0078D0  780104     MOV W4, W2
0078D2  200291     MOV #0x29, W1
0078D4  B3C050     MOV.B #0x5, W0
0078D6  07FEE6     RCALL FuncWriteBrcReg_Sec
268:               	FuncWriteBrcReg_Sec (WriteSplitRegBrdCst, REG_SPLIT_ERRORE_1_BOX_MOTORE, EngineBox.Errori1);
0078D8  805AF4     MOV 0xB5E, W4
0078DA  780104     MOV W4, W2
0078DC  200541     MOV #0x54, W1
0078DE  B3C050     MOV.B #0x5, W0
0078E0  07FEE1     RCALL FuncWriteBrcReg_Sec
269:               	FuncWriteBrcReg_Sec (WriteSplitRegBrdCst, REG_SPLIT_ERRORE_2_BOX_MOTORE, EngineBox.Errori2);
0078E2  805B04     MOV 0xB60, W4
0078E4  780104     MOV W4, W2
0078E6  200551     MOV #0x55, W1
0078E8  B3C050     MOV.B #0x5, W0
0078EA  07FEDC     RCALL FuncWriteBrcReg_Sec
270:               	FuncWriteBrcReg_Sec (WriteSplitRegBrdCst, REG_SPLIT_STATUS_BOX_MOTORE, EngineBox.StatoCompressore);
0078EC  20B4C4     MOV #0xB4C, W4
0078EE  784214     MOV.B [W4], W4
0078F0  FB0204     SE W4, W4
0078F2  780104     MOV W4, W2
0078F4  200561     MOV #0x56, W1
0078F6  B3C050     MOV.B #0x5, W0
0078F8  07FED5     RCALL FuncWriteBrcReg_Sec
271:               	FuncWriteBrcReg_Sec (WriteSplitRegBrdCst, REG_SPLIT_CURRENT_MODE_ENGENIE_BOX, EngineBox.FunctionMode);
0078FA  805A54     MOV 0xB4A, W4
0078FC  780104     MOV W4, W2
0078FE  200441     MOV #0x44, W1
007900  B3C050     MOV.B #0x5, W0
007902  07FED0     RCALL FuncWriteBrcReg_Sec
272:               }
007904  FA8000     ULNK
007906  060000     RETURN
273:               
274:               /*
275:               void RefreshOutPutDimmer_Sec(TypDimmer * DataStore, char Address)
276:               {
277:               
278:               	if((DataStore->Enable == 1) & (DataStore->RequestRefresh ==1))		// se abilitato e OnLine
279:               	{
280:               		DataStore->OffLine = FuncWriteReg (Add_Dimmer_1 + Address, REG_OUT_CH1, DataStore->Ch1, DataStore->OffLine);
281:               		DataStore->OffLine = FuncWriteReg (Add_Dimmer_1 + Address, REG_OUT_CH2, DataStore->Ch2, DataStore->OffLine);
282:               		DataStore->OffLine = FuncWriteReg (Add_Dimmer_1 + Address, REG_OUT_CH3, DataStore->Ch3, DataStore->OffLine);
283:               		DataStore->OffLine = FuncWriteReg (Add_Dimmer_1 + Address, REG_OUT_CH4, DataStore->Ch4, DataStore->OffLine);
284:               		DataStore->OffLine = FuncWriteReg (Add_Dimmer_1 + Address, REG_OUT_CH5, DataStore->Ch5, DataStore->OffLine);
285:               		DataStore->OffLine = FuncWriteReg (Add_Dimmer_1 + Address, REG_OUT_CH6, DataStore->Ch6, DataStore->OffLine);
286:               		if(DataStore->OffLine == 0)
287:               			DataStore->RequestRefresh = 0;
288:               	}
289:               
290:               }
291:               */
292:               
293:               void RefreshAllOutPut_Sec(void)
294:               {
007908  FA0000     LNK #0x0
295:               //	char i=0;
296:               
297:               	if(EnableMySecBus)
00790A  8070F4     MOV EnableMySecBus, W4
00790C  520FE0     SUB W4, #0x0, [W15]
00790E  320001     BRA Z, 0x7912
298:               	{
299:               		RefreshOutPutRoom_Sec();
007910  07FFBE     RCALL RefreshOutPutRoom_Sec
300:               	/*
301:               		for(i=0; i<Max_Dimmer_Sec; i++)
302:               			RefreshOutPutDimmer_Sec(&Dimmer[i], i);
303:               	*/
304:               	}
305:               }
007912  FA8000     ULNK
007914  060000     RETURN
306:               
---  D:/WORK3/Lavori/TERMODINAMICA/Work/FW/1 - Generico/Split/Split v.8.4.22 - Working/ProtocolloComunicazione.c
1:                 //----------------------------------------------------------------------------------
2:                 //	Progect name:	ProtocolloComunicazione.c
3:                 //	Device:			PIC24FJ256GB110 @ 32Mhz (FRCPLL)
4:                 //	Autor:			Emanuele
5:                 //	Date:			04/01/2014
6:                 //	Description:	Corpo delle funzioni che gestiscono la comunicazione con il sistema
7:                 //----------------------------------------------------------------------------------
8:                 
9:                 //----------------------------------------------------------------------------------
10:                //	Include
11:                //----------------------------------------------------------------------------------
12:                #include "MicroModelSelection.h"
13:                #ifdef GB210
14:                	#include <p24FJ256GB210.h>
15:                #else
16:                	#include <p24FJ256GB110.h>
17:                #endif
18:                #include <stdio.h>
19:                #include "DefinePeriferiche.h"
20:                #include "Timer.h"
21:                #include "usart.h"
22:                #include "ADC.h"
23:                #include "PWM.h"
24:                #include "EEPROM.h"
25:                #include "Valvola_PassoPasso.h"
26:                #include "Driver_Comunicazione.h"
27:                #include "ProtocolloComunicazione.h"
28:                #include "Core.h"
29:                
30:                //----------------------------------------------------------------------------------
31:                //	Funzioni
32:                //----------------------------------------------------------------------------------
33:                void SetMyAddress(char My_Add)
34:                {
003E26  FA0002     LNK #0x2
003E28  784F00     MOV.B W0, [W14]
35:                	My_Address = My_Add;
003E2A  78421E     MOV.B [W14], W4
003E2C  784304     MOV.B W4, W6
003E2E  20A915     MOV #0xA91, W5
003E30  784A86     MOV.B W6, [W5]
36:                }
003E32  FA8000     ULNK
003E34  060000     RETURN
37:                
38:                char GetMyAddress(void)
39:                {
003E36  FA0000     LNK #0x0
40:                	return My_Address;
003E38  20A914     MOV #0xA91, W4
003E3A  784214     MOV.B [W4], W4
41:                }
003E3C  784004     MOV.B W4, W0
003E3E  FA8000     ULNK
003E40  060000     RETURN
42:                
43:                void Process_Cmd(TypBuffer * LastCmd)
44:                {
003E42  FA0004     LNK #0x4
003E44  980710     MOV W0, [W14+2]
45:                	if(LastCmd->Valid_Data == 1)
003E46  90021E     MOV [W14+2], W4
003E48  904A24     MOV.B [W4+10], W4
003E4A  524FE1     SUB.B W4, #0x1, [W15]
003E4C  3A009C     BRA NZ, 0x3F86
46:                	{
47:                		char Esito = 0;
003E4E  EB4200     CLR.B W4
003E50  784F04     MOV.B W4, [W14]
48:                		switch (LastCmd->Comando)	// interpreto il comando
003E52  90021E     MOV [W14+2], W4
003E54  904234     MOV.B [W4+3], W4
003E56  FB8204     ZE W4, W4
003E58  B92361     MUL.SU W4, #1, W6
003E5A  EB8200     SETM W4
003E5C  EB8280     SETM W5
003E5E  420206     ADD W4, W6, W4
003E60  4A8287     ADDC W5, W7, W5
003E62  200076     MOV #0x7, W6
003E64  200007     MOV #0x0, W7
003E66  520F86     SUB W4, W6, [W15]
003E68  5A8F87     SUBB W5, W7, [W15]
003E6A  3E008A     BRA GTU, 0x3F80
003E6C  016004     BRA W4
003E6E  370007     BRA 0x3E7E
003E70  37001A     BRA 0x3EA6
003E72  370067     BRA 0x3F42
003E74  370032     BRA 0x3EDA
003E76  370065     BRA 0x3F42
003E78  370083     BRA 0x3F80
003E7A  370082     BRA 0x3F80
003E7C  37006D     BRA 0x3F58
49:                		{
50:                			case Prg:
51:                				while(BufferTx.Valid_Data == 1)	// attendo 
003E7E  000000     NOP
003E80  370001     BRA 0x3E84
003E84  2094C4     MOV #0x94C, W4
003E86  784214     MOV.B [W4], W4
003E88  524FE1     SUB.B W4, #0x1, [W15]
003E8A  32FFFB     BRA Z, 0x3E82
52:                					continue;
003E82  000000     NOP
53:                				Write_Cmd(&BufferTx,LastCmd->Mitt_Add, LastCmd->Comando, 0, LastCmd->Data);
003E8C  90021E     MOV [W14+2], W4
003E8E  900234     MOV [W4+6], W4
003E90  90029E     MOV [W14+2], W5
003E92  9042B5     MOV.B [W5+3], W5
003E94  784305     MOV.B W5, W6
003E96  90029E     MOV [W14+2], W5
003E98  9042A5     MOV.B [W5+2], W5
003E9A  EB0180     CLR W3
003E9C  784106     MOV.B W6, W2
003E9E  784085     MOV.B W5, W1
003EA0  209420     MOV #0x942, W0
003EA2  071EE6     RCALL Write_Cmd
54:                				break;
003EA4  37006D     BRA 0x3F80
55:                
56:                			case ReadReg:
57:                				while(BufferTx.Valid_Data == 1)	// attendo 
003EA6  000000     NOP
003EA8  370001     BRA 0x3EAC
003EAC  2094C4     MOV #0x94C, W4
003EAE  784214     MOV.B [W4], W4
003EB0  524FE1     SUB.B W4, #0x1, [W15]
003EB2  32FFFB     BRA Z, 0x3EAA
58:                					continue;
003EAA  000000     NOP
59:                				Write_Cmd(&BufferTx,LastCmd->Mitt_Add, LastCmd->Comando, LastCmd->Registro, GetData(LastCmd->Registro));
003EB4  90021E     MOV [W14+2], W4
003EB6  900224     MOV [W4+4], W4
003EB8  780004     MOV W4, W0
003EBA  070067     RCALL GetData
003EBC  780200     MOV W0, W4
003EBE  90029E     MOV [W14+2], W5
003EC0  9002A5     MOV [W5+4], W5
003EC2  780385     MOV W5, W7
003EC4  90029E     MOV [W14+2], W5
003EC6  9042B5     MOV.B [W5+3], W5
003EC8  784305     MOV.B W5, W6
003ECA  90029E     MOV [W14+2], W5
003ECC  9042A5     MOV.B [W5+2], W5
003ECE  780187     MOV W7, W3
003ED0  784106     MOV.B W6, W2
003ED2  784085     MOV.B W5, W1
003ED4  209420     MOV #0x942, W0
003ED6  071ECC     RCALL Write_Cmd
60:                				break;
003ED8  370053     BRA 0x3F80
61:                
62:                			case WriteReg:
63:                				while(BufferTx.Valid_Data == 1)	// attendo 
003EDA  000000     NOP
003EDC  370001     BRA 0x3EE0
003EE0  2094C4     MOV #0x94C, W4
003EE2  784214     MOV.B [W4], W4
003EE4  524FE1     SUB.B W4, #0x1, [W15]
003EE6  32FFFB     BRA Z, 0x3EDE
64:                					continue;
003EDE  000000     NOP
65:                				Esito = PutData(LastCmd->Registro, LastCmd->Data);	// Tento la scrittura del registro
003EE8  90021E     MOV [W14+2], W4
003EEA  900234     MOV [W4+6], W4
003EEC  780284     MOV W4, W5
003EEE  90021E     MOV [W14+2], W4
003EF0  900224     MOV [W4+4], W4
003EF2  780085     MOV W5, W1
003EF4  780004     MOV W4, W0
003EF6  0703E4     RCALL PutData
003EF8  784200     MOV.B W0, W4
003EFA  784F04     MOV.B W4, [W14]
66:                				if(Esito == 0)			// in base all'esito rispondo
003EFC  78421E     MOV.B [W14], W4
003EFE  524FE0     SUB.B W4, #0x0, [W15]
003F00  3A0010     BRA NZ, 0x3F22
67:                				{	Write_Cmd(&BufferTx,LastCmd->Mitt_Add, LastCmd->Comando, LastCmd->Registro, Ack);	}
003F02  90021E     MOV [W14+2], W4
003F04  900224     MOV [W4+4], W4
003F06  780384     MOV W4, W7
003F08  90021E     MOV [W14+2], W4
003F0A  904234     MOV.B [W4+3], W4
003F0C  784304     MOV.B W4, W6
003F0E  90021E     MOV [W14+2], W4
003F10  904224     MOV.B [W4+2], W4
003F12  784284     MOV.B W4, W5
003F14  280004     MOV #0x8000, W4
003F16  780187     MOV W7, W3
003F18  784106     MOV.B W6, W2
003F1A  784085     MOV.B W5, W1
003F1C  209420     MOV #0x942, W0
003F1E  071EA8     RCALL Write_Cmd
68:                				else
69:                				{	Write_Cmd(&BufferTx,LastCmd->Mitt_Add, LastCmd->Comando, LastCmd->Registro, N_Ack);	}
003F22  90021E     MOV [W14+2], W4
003F24  900224     MOV [W4+4], W4
003F26  780384     MOV W4, W7
003F28  90021E     MOV [W14+2], W4
003F2A  904234     MOV.B [W4+3], W4
003F2C  784304     MOV.B W4, W6
003F2E  90021E     MOV [W14+2], W4
003F30  904224     MOV.B [W4+2], W4
003F32  784284     MOV.B W4, W5
003F34  EB8200     SETM W4
003F36  780187     MOV W7, W3
003F38  784106     MOV.B W6, W2
003F3A  784085     MOV.B W5, W1
003F3C  209420     MOV #0x942, W0
003F3E  071E98     RCALL Write_Cmd
70:                				break;
003F20  37002F     BRA 0x3F80
003F40  37001F     BRA 0x3F80
71:                
72:                			case WriteRegBrdCst:
73:                			case WriteSplitRegBrdCst:
74:                				Esito = PutData(LastCmd->Registro, LastCmd->Data);	// Tento la scrittura del registro
003F42  90021E     MOV [W14+2], W4
003F44  900234     MOV [W4+6], W4
003F46  780284     MOV W4, W5
003F48  90021E     MOV [W14+2], W4
003F4A  900224     MOV [W4+4], W4
003F4C  780085     MOV W5, W1
003F4E  780004     MOV W4, W0
003F50  0703B7     RCALL PutData
003F52  784200     MOV.B W0, W4
003F54  784F04     MOV.B W4, [W14]
75:                				break;
003F56  370014     BRA 0x3F80
76:                
77:                			case Chek:
78:                				while(BufferTx.Valid_Data == 1)	// attendo 
003F58  000000     NOP
003F5A  370001     BRA 0x3F5E
003F5E  2094C4     MOV #0x94C, W4
003F60  784214     MOV.B [W4], W4
003F62  524FE1     SUB.B W4, #0x1, [W15]
003F64  32FFFB     BRA Z, 0x3F5C
79:                					continue;
003F5C  000000     NOP
80:                				Write_Cmd(&BufferTx,LastCmd->Mitt_Add, LastCmd->Comando, 0, Ack);
003F66  90021E     MOV [W14+2], W4
003F68  904234     MOV.B [W4+3], W4
003F6A  784304     MOV.B W4, W6
003F6C  90021E     MOV [W14+2], W4
003F6E  904224     MOV.B [W4+2], W4
003F70  784284     MOV.B W4, W5
003F72  280004     MOV #0x8000, W4
003F74  EB0180     CLR W3
003F76  784106     MOV.B W6, W2
003F78  784085     MOV.B W5, W1
003F7A  209420     MOV #0x942, W0
003F7C  071E79     RCALL Write_Cmd
81:                				break;
003F7E  000000     NOP
82:                
83:                		}
84:                		LastCmd->Valid_Data = 0;
003F80  90021E     MOV [W14+2], W4
003F82  EB4280     CLR.B W5
003F84  984A25     MOV.B W5, [W4+10]
85:                	}
86:                }
003F86  FA8000     ULNK
003F88  060000     RETURN
87:                
88:                int	GetData(int Reg)
89:                {
003F8A  FA0002     LNK #0x2
003F8C  780F00     MOV W0, [W14]
90:                	switch(Reg)
003F8E  78021E     MOV [W14], W4
003F90  B92361     MUL.SU W4, #1, W6
003F92  200604     MOV #0x60, W4
003F94  200005     MOV #0x0, W5
003F96  420206     ADD W4, W6, W4
003F98  4A8287     ADDC W5, W7, W5
003F9A  201DA6     MOV #0x1DA, W6
003F9C  200007     MOV #0x0, W7
003F9E  520F86     SUB W4, W6, [W15]
003FA0  5A8F87     SUBB W5, W7, [W15]
003FA2  3E038A     BRA GTU, 0x46B8
003FA4  016004     BRA W4
003FA6  370362     BRA 0x466C
003FA8  370363     BRA 0x4670
003FAA  370364     BRA 0x4674
003FAC  370365     BRA 0x4678
003FAE  370368     BRA 0x4680
003FB0  370370     BRA 0x4692
003FB2  370378     BRA 0x46A4
003FB4  370379     BRA 0x46A8
003FB6  37037A     BRA 0x46AC
003FB8  37037B     BRA 0x46B0
003FBA  37037C     BRA 0x46B4
003FBC  37037D     BRA 0x46B8
003FBE  37037C     BRA 0x46B8
003FC0  37037B     BRA 0x46B8
003FC2  37037A     BRA 0x46B8
003FC4  370379     BRA 0x46B8
003FC6  370378     BRA 0x46B8
003FC8  370377     BRA 0x46B8
003FCA  370376     BRA 0x46B8
003FCC  370375     BRA 0x46B8
003FCE  370374     BRA 0x46B8
003FD0  370373     BRA 0x46B8
003FD2  370372     BRA 0x46B8
003FD4  370371     BRA 0x46B8
003FD6  370370     BRA 0x46B8
003FD8  37036F     BRA 0x46B8
003FDA  37036E     BRA 0x46B8
003FDC  37036D     BRA 0x46B8
003FDE  37036C     BRA 0x46B8
003FE0  37036B     BRA 0x46B8
003FE2  37036A     BRA 0x46B8
003FE4  370369     BRA 0x46B8
003FE6  370368     BRA 0x46B8
003FE8  370367     BRA 0x46B8
003FEA  370366     BRA 0x46B8
003FEC  370365     BRA 0x46B8
003FEE  370364     BRA 0x46B8
003FF0  370363     BRA 0x46B8
003FF2  370362     BRA 0x46B8
003FF4  370361     BRA 0x46B8
003FF6  370360     BRA 0x46B8
003FF8  37035F     BRA 0x46B8
003FFA  37035E     BRA 0x46B8
003FFC  37035D     BRA 0x46B8
003FFE  37035C     BRA 0x46B8
004000  37035B     BRA 0x46B8
004002  37035A     BRA 0x46B8
004004  370359     BRA 0x46B8
004006  370358     BRA 0x46B8
004008  370357     BRA 0x46B8
00400A  370356     BRA 0x46B8
00400C  370355     BRA 0x46B8
00400E  370354     BRA 0x46B8
004010  370353     BRA 0x46B8
004012  370352     BRA 0x46B8
004014  370351     BRA 0x46B8
004016  370350     BRA 0x46B8
004018  37034F     BRA 0x46B8
00401A  37034E     BRA 0x46B8
00401C  37034D     BRA 0x46B8
00401E  37034C     BRA 0x46B8
004020  37034B     BRA 0x46B8
004022  37034A     BRA 0x46B8
004024  370349     BRA 0x46B8
004026  370348     BRA 0x46B8
004028  370347     BRA 0x46B8
00402A  370346     BRA 0x46B8
00402C  370345     BRA 0x46B8
00402E  370344     BRA 0x46B8
004030  370343     BRA 0x46B8
004032  370342     BRA 0x46B8
004034  370341     BRA 0x46B8
004036  370340     BRA 0x46B8
004038  37033F     BRA 0x46B8
00403A  37033E     BRA 0x46B8
00403C  37033D     BRA 0x46B8
00403E  37033C     BRA 0x46B8
004040  37033B     BRA 0x46B8
004042  37033A     BRA 0x46B8
004044  370339     BRA 0x46B8
004046  370338     BRA 0x46B8
004048  370337     BRA 0x46B8
00404A  370336     BRA 0x46B8
00404C  370335     BRA 0x46B8
00404E  370334     BRA 0x46B8
004050  370333     BRA 0x46B8
004052  370332     BRA 0x46B8
004054  370331     BRA 0x46B8
004056  370330     BRA 0x46B8
004058  37032F     BRA 0x46B8
00405A  37032E     BRA 0x46B8
00405C  37032D     BRA 0x46B8
00405E  37032C     BRA 0x46B8
004060  37032B     BRA 0x46B8
004062  37032A     BRA 0x46B8
004064  370329     BRA 0x46B8
004066  370328     BRA 0x46B8
004068  370179     BRA 0x435C
00406A  37017A     BRA 0x4360
00406C  37017B     BRA 0x4364
00406E  37017C     BRA 0x4368
004070  37017D     BRA 0x436C
004072  37017E     BRA 0x4370
004074  37017F     BRA 0x4374
004076  370320     BRA 0x46B8
004078  37031F     BRA 0x46B8
00407A  37031E     BRA 0x46B8
00407C  37031D     BRA 0x46B8
00407E  37031C     BRA 0x46B8
004080  37031B     BRA 0x46B8
004082  37031A     BRA 0x46B8
004084  370319     BRA 0x46B8
004086  370318     BRA 0x46B8
004088  370177     BRA 0x4378
00408A  370178     BRA 0x437C
00408C  370179     BRA 0x4380
00408E  37017A     BRA 0x4384
004090  37017B     BRA 0x4388
004092  37017C     BRA 0x438C
004094  37017D     BRA 0x4390
004096  370310     BRA 0x46B8
004098  37030F     BRA 0x46B8
00409A  37030E     BRA 0x46B8
00409C  37030D     BRA 0x46B8
00409E  37030C     BRA 0x46B8
0040A0  37030B     BRA 0x46B8
0040A2  37030A     BRA 0x46B8
0040A4  370309     BRA 0x46B8
0040A6  370308     BRA 0x46B8
0040A8  370175     BRA 0x4394
0040AA  370178     BRA 0x439C
0040AC  37017B     BRA 0x43A4
0040AE  37017C     BRA 0x43A8
0040B0  37017D     BRA 0x43AC
0040B2  37017E     BRA 0x43B0
0040B4  37017F     BRA 0x43B4
0040B6  370180     BRA 0x43B8
0040B8  370181     BRA 0x43BC
0040BA  370184     BRA 0x43C4
0040BC  370185     BRA 0x43C8
0040BE  370186     BRA 0x43CC
0040C0  370187     BRA 0x43D0
0040C2  37018A     BRA 0x43D8
0040C4  3702F9     BRA 0x46B8
0040C6  3702F8     BRA 0x46B8
0040C8  3702F7     BRA 0x46B8
0040CA  3702F6     BRA 0x46B8
0040CC  370179     BRA 0x43C0
0040CE  3702F4     BRA 0x46B8
0040D0  3702F3     BRA 0x46B8
0040D2  3702F2     BRA 0x46B8
0040D4  3702F1     BRA 0x46B8
0040D6  3702F0     BRA 0x46B8
0040D8  3702EF     BRA 0x46B8
0040DA  3702EE     BRA 0x46B8
0040DC  3702ED     BRA 0x46B8
0040DE  3702EC     BRA 0x46B8
0040E0  3702EB     BRA 0x46B8
0040E2  3702EA     BRA 0x46B8
0040E4  3702E9     BRA 0x46B8
0040E6  3702E8     BRA 0x46B8
0040E8  370179     BRA 0x43DC
0040EA  37017A     BRA 0x43E0
0040EC  37017B     BRA 0x43E4
0040EE  37017C     BRA 0x43E8
0040F0  37017D     BRA 0x43EC
0040F2  37017E     BRA 0x43F0
0040F4  37017F     BRA 0x43F4
0040F6  370180     BRA 0x43F8
0040F8  370181     BRA 0x43FC
0040FA  370182     BRA 0x4400
0040FC  370183     BRA 0x4404
0040FE  370184     BRA 0x4408
004100  370185     BRA 0x440C
004102  370186     BRA 0x4410
004104  370187     BRA 0x4414
004106  370188     BRA 0x4418
004108  370189     BRA 0x441C
00410A  37018A     BRA 0x4420
00410C  37018B     BRA 0x4424
00410E  37018C     BRA 0x4428
004110  37018D     BRA 0x442C
004112  37018E     BRA 0x4430
004114  370191     BRA 0x4438
004116  370194     BRA 0x4440
004118  370195     BRA 0x4444
00411A  370196     BRA 0x4448
00411C  370199     BRA 0x4450
00411E  37019A     BRA 0x4454
004120  3702CB     BRA 0x46B8
004122  3702CA     BRA 0x46B8
004124  3702C9     BRA 0x46B8
004126  370198     BRA 0x4458
004128  370199     BRA 0x445C
00412A  37019A     BRA 0x4460
00412C  37019B     BRA 0x4464
00412E  37019C     BRA 0x4468
004130  37019D     BRA 0x446C
004132  37019E     BRA 0x4470
004134  37019F     BRA 0x4474
004136  3701A0     BRA 0x4478
004138  3701A1     BRA 0x447C
00413A  3701A2     BRA 0x4480
00413C  3701A3     BRA 0x4484
00413E  3701A4     BRA 0x4488
004140  3701A5     BRA 0x448C
004142  3701A6     BRA 0x4490
004144  3701A7     BRA 0x4494
004146  3701A8     BRA 0x4498
004148  3701A9     BRA 0x449C
00414A  3701AA     BRA 0x44A0
00414C  3701AB     BRA 0x44A4
00414E  3701AC     BRA 0x44A8
004150  3701AD     BRA 0x44AC
004152  3701AE     BRA 0x44B0
004154  3701AF     BRA 0x44B4
004156  3702B0     BRA 0x46B8
004158  3702AF     BRA 0x46B8
00415A  3702AE     BRA 0x46B8
00415C  3702AD     BRA 0x46B8
00415E  3702AC     BRA 0x46B8
004160  3702AB     BRA 0x46B8
004162  3702AA     BRA 0x46B8
004164  3702A9     BRA 0x46B8
004166  3701A8     BRA 0x44B8
004168  3701A9     BRA 0x44BC
00416A  3701AA     BRA 0x44C0
00416C  3701AB     BRA 0x44C4
00416E  3701AC     BRA 0x44C8
004170  3701AD     BRA 0x44CC
004172  3701AE     BRA 0x44D0
004174  3701AF     BRA 0x44D4
004176  3701B0     BRA 0x44D8
004178  37029F     BRA 0x46B8
00417A  37029E     BRA 0x46B8
00417C  37029D     BRA 0x46B8
00417E  37029C     BRA 0x46B8
004180  37029B     BRA 0x46B8
004182  37029A     BRA 0x46B8
004184  370299     BRA 0x46B8
004186  3701AA     BRA 0x44DC
004188  3701AB     BRA 0x44E0
00418A  3701AC     BRA 0x44E4
00418C  3701AD     BRA 0x44E8
00418E  3701AE     BRA 0x44EC
004190  3701AF     BRA 0x44F0
004192  3701B0     BRA 0x44F4
004194  3701B1     BRA 0x44F8
004196  370290     BRA 0x46B8
004198  37028F     BRA 0x46B8
00419A  37028E     BRA 0x46B8
00419C  37028D     BRA 0x46B8
00419E  37028C     BRA 0x46B8
0041A0  37028B     BRA 0x46B8
0041A2  37028A     BRA 0x46B8
0041A4  370289     BRA 0x46B8
0041A6  370288     BRA 0x46B8
0041A8  370287     BRA 0x46B8
0041AA  370286     BRA 0x46B8
0041AC  370285     BRA 0x46B8
0041AE  370284     BRA 0x46B8
0041B0  370283     BRA 0x46B8
0041B2  370282     BRA 0x46B8
0041B4  370281     BRA 0x46B8
0041B6  370280     BRA 0x46B8
0041B8  37027F     BRA 0x46B8
0041BA  37027E     BRA 0x46B8
0041BC  37027D     BRA 0x46B8
0041BE  37027C     BRA 0x46B8
0041C0  37027B     BRA 0x46B8
0041C2  37027A     BRA 0x46B8
0041C4  370279     BRA 0x46B8
0041C6  370278     BRA 0x46B8
0041C8  370277     BRA 0x46B8
0041CA  370276     BRA 0x46B8
0041CC  370275     BRA 0x46B8
0041CE  370274     BRA 0x46B8
0041D0  370273     BRA 0x46B8
0041D2  370272     BRA 0x46B8
0041D4  370271     BRA 0x46B8
0041D6  370270     BRA 0x46B8
0041D8  37026F     BRA 0x46B8
0041DA  37026E     BRA 0x46B8
0041DC  37026D     BRA 0x46B8
0041DE  37026C     BRA 0x46B8
0041E0  37026B     BRA 0x46B8
0041E2  37026A     BRA 0x46B8
0041E4  370269     BRA 0x46B8
0041E6  370268     BRA 0x46B8
0041E8  370267     BRA 0x46B8
0041EA  370266     BRA 0x46B8
0041EC  370265     BRA 0x46B8
0041EE  370264     BRA 0x46B8
0041F0  370263     BRA 0x46B8
0041F2  370262     BRA 0x46B8
0041F4  370261     BRA 0x46B8
0041F6  370260     BRA 0x46B8
0041F8  37025F     BRA 0x46B8
0041FA  37025E     BRA 0x46B8
0041FC  37025D     BRA 0x46B8
0041FE  37025C     BRA 0x46B8
004200  37025B     BRA 0x46B8
004202  37025A     BRA 0x46B8
004204  370259     BRA 0x46B8
004206  370258     BRA 0x46B8
004208  370257     BRA 0x46B8
00420A  370256     BRA 0x46B8
00420C  370255     BRA 0x46B8
00420E  370254     BRA 0x46B8
004210  370253     BRA 0x46B8
004212  370252     BRA 0x46B8
004214  370251     BRA 0x46B8
004216  370250     BRA 0x46B8
004218  37024F     BRA 0x46B8
00421A  37024E     BRA 0x46B8
00421C  37024D     BRA 0x46B8
00421E  37024C     BRA 0x46B8
004220  37024B     BRA 0x46B8
004222  37024A     BRA 0x46B8
004224  370249     BRA 0x46B8
004226  370248     BRA 0x46B8
004228  370247     BRA 0x46B8
00422A  370246     BRA 0x46B8
00422C  370245     BRA 0x46B8
00422E  370244     BRA 0x46B8
004230  370243     BRA 0x46B8
004232  370242     BRA 0x46B8
004234  370241     BRA 0x46B8
004236  370240     BRA 0x46B8
004238  37023F     BRA 0x46B8
00423A  37023E     BRA 0x46B8
00423C  37023D     BRA 0x46B8
00423E  37023C     BRA 0x46B8
004240  37023B     BRA 0x46B8
004242  37023A     BRA 0x46B8
004244  370239     BRA 0x46B8
004246  370238     BRA 0x46B8
004248  370237     BRA 0x46B8
00424A  370236     BRA 0x46B8
00424C  370235     BRA 0x46B8
00424E  370234     BRA 0x46B8
004250  370233     BRA 0x46B8
004252  370232     BRA 0x46B8
004254  370231     BRA 0x46B8
004256  370230     BRA 0x46B8
004258  37022F     BRA 0x46B8
00425A  37022E     BRA 0x46B8
00425C  37022D     BRA 0x46B8
00425E  37022C     BRA 0x46B8
004260  37022B     BRA 0x46B8
004262  37022A     BRA 0x46B8
004264  370229     BRA 0x46B8
004266  37014A     BRA 0x44FC
004268  37014B     BRA 0x4500
00426A  37014C     BRA 0x4504
00426C  37014D     BRA 0x4508
00426E  37014E     BRA 0x450C
004270  37014F     BRA 0x4510
004272  370150     BRA 0x4514
004274  370151     BRA 0x4518
004276  370152     BRA 0x451C
004278  370153     BRA 0x4520
00427A  370154     BRA 0x4524
00427C  370155     BRA 0x4528
00427E  37021C     BRA 0x46B8
004280  37021B     BRA 0x46B8
004282  37021A     BRA 0x46B8
004284  370219     BRA 0x46B8
004286  370152     BRA 0x452C
004288  370153     BRA 0x4530
00428A  370154     BRA 0x4534
00428C  370155     BRA 0x4538
00428E  370156     BRA 0x453C
004290  370157     BRA 0x4540
004292  370158     BRA 0x4544
004294  370159     BRA 0x4548
004296  37015A     BRA 0x454C
004298  37015B     BRA 0x4550
00429A  37015C     BRA 0x4554
00429C  37015D     BRA 0x4558
00429E  37020C     BRA 0x46B8
0042A0  37020B     BRA 0x46B8
0042A2  37020A     BRA 0x46B8
0042A4  370209     BRA 0x46B8
0042A6  37015A     BRA 0x455C
0042A8  37015B     BRA 0x4560
0042AA  37015C     BRA 0x4564
0042AC  37015D     BRA 0x4568
0042AE  37015E     BRA 0x456C
0042B0  37015F     BRA 0x4570
0042B2  370160     BRA 0x4574
0042B4  370161     BRA 0x4578
0042B6  370162     BRA 0x457C
0042B8  370163     BRA 0x4580
0042BA  370164     BRA 0x4584
0042BC  370165     BRA 0x4588
0042BE  3701FC     BRA 0x46B8
0042C0  3701FB     BRA 0x46B8
0042C2  3701FA     BRA 0x46B8
0042C4  3701F9     BRA 0x46B8
0042C6  370162     BRA 0x458C
0042C8  370163     BRA 0x4590
0042CA  370164     BRA 0x4594
0042CC  370165     BRA 0x4598
0042CE  370166     BRA 0x459C
0042D0  370167     BRA 0x45A0
0042D2  370168     BRA 0x45A4
0042D4  370169     BRA 0x45A8
0042D6  37016A     BRA 0x45AC
0042D8  37016B     BRA 0x45B0
0042DA  37016C     BRA 0x45B4
0042DC  37016D     BRA 0x45B8
0042DE  3701EC     BRA 0x46B8
0042E0  3701EB     BRA 0x46B8
0042E2  3701EA     BRA 0x46B8
0042E4  3701E9     BRA 0x46B8
0042E6  37016A     BRA 0x45BC
0042E8  37016B     BRA 0x45C0
0042EA  37016C     BRA 0x45C4
0042EC  37016D     BRA 0x45C8
0042EE  37016E     BRA 0x45CC
0042F0  37016F     BRA 0x45D0
0042F2  370170     BRA 0x45D4
0042F4  370171     BRA 0x45D8
0042F6  370172     BRA 0x45DC
0042F8  370173     BRA 0x45E0
0042FA  370174     BRA 0x45E4
0042FC  3701DD     BRA 0x46B8
0042FE  3701DC     BRA 0x46B8
004300  3701DB     BRA 0x46B8
004302  3701DA     BRA 0x46B8
004304  3701D9     BRA 0x46B8
004306  370170     BRA 0x45E8
004308  370171     BRA 0x45EC
00430A  370172     BRA 0x45F0
00430C  370173     BRA 0x45F4
00430E  370174     BRA 0x45F8
004310  370175     BRA 0x45FC
004312  370176     BRA 0x4600
004314  370177     BRA 0x4604
004316  370178     BRA 0x4608
004318  370179     BRA 0x460C
00431A  37017A     BRA 0x4610
00431C  3701CD     BRA 0x46B8
00431E  3701CC     BRA 0x46B8
004320  3701CB     BRA 0x46B8
004322  3701CA     BRA 0x46B8
004324  3701C9     BRA 0x46B8
004326  370176     BRA 0x4614
004328  370177     BRA 0x4618
00432A  370178     BRA 0x461C
00432C  370179     BRA 0x4620
00432E  37017A     BRA 0x4624
004330  37017B     BRA 0x4628
004332  37017C     BRA 0x462C
004334  37017D     BRA 0x4630
004336  37017E     BRA 0x4634
004338  37017F     BRA 0x4638
00433A  370180     BRA 0x463C
00433C  3701BD     BRA 0x46B8
00433E  3701BC     BRA 0x46B8
004340  3701BB     BRA 0x46B8
004342  3701BA     BRA 0x46B8
004344  3701B9     BRA 0x46B8
004346  37017C     BRA 0x4640
004348  37017D     BRA 0x4644
00434A  37017E     BRA 0x4648
00434C  37017F     BRA 0x464C
00434E  370180     BRA 0x4650
004350  370181     BRA 0x4654
004352  370182     BRA 0x4658
004354  370183     BRA 0x465C
004356  370184     BRA 0x4660
004358  370185     BRA 0x4664
00435A  370186     BRA 0x4668
91:                	{
92:                		case REG_SPLIT_TEMP_BULBO_GRANDE:			// valori sonde già convertiti
93:                			return Me.Temp_Big;
00435C  805B84     MOV 0xB70, W4
00435E  3701AD     BRA 0x46BA
94:                		case REG_SPLIT_TEMP_BULBO_PICCOLO:
95:                			return Me.Temp_Small;
004360  805B94     MOV 0xB72, W4
004362  3701AB     BRA 0x46BA
96:                		case REG_SPLIT_TEMP_ARIA_USCITA:
97:                			return Me.Temp_AirOut;
004364  805B74     MOV 0xB6E, W4
004366  3701A9     BRA 0x46BA
98:                		case REG_SPLIT_TEMP_AMBIENTE:
99:                			return Me.Temp_Amb;
004368  805B64     MOV Me, W4
00436A  3701A7     BRA 0x46BA
100:               		case REG_SPLIT_PRES_BULBO_GRANDE:
101:               			return Me.Pres_Big;
00436C  805BA4     MOV 0xB74, W4
00436E  3701A5     BRA 0x46BA
102:               		case REG_SPLIT_PRES_BULBO_PICCOLO:
103:               			return Me.Pres_Small;
004370  805BB4     MOV 0xB76, W4
004372  3701A3     BRA 0x46BA
104:               		case REG_SPLIT_I_FAN:
105:               			return Me.Fan_Power;
004374  805CA4     MOV 0xB94, W4
004376  3701A1     BRA 0x46BA
106:               
107:               		case REG_SPLIT_TEMP_BULBO_GRANDE_ADC:		// valori grezzi acquisizione adc
108:               			return Adc_T_Grande;
004378  804294     MOV Adc_T_Grande, W4
00437A  37019F     BRA 0x46BA
109:               		case REG_SPLIT_TEMP_BULBO_PICCOLO_ADC:
110:               			return Adc_T_Piccolo;
00437C  804284     MOV Adc_T_Piccolo, W4
00437E  37019D     BRA 0x46BA
111:               		case REG_SPLIT_TEMP_ARIA_USCITA_ADC:
112:               			return Adc_T_Out;
004380  8042A4     MOV Adc_T_Out, W4
004382  37019B     BRA 0x46BA
113:               		case REG_SPLIT_TEMP_AMBIENTE_ADC:
114:               			return Adc_T_Amb;
004384  8042B4     MOV Adc_T_Amb, W4
004386  370199     BRA 0x46BA
115:               		case REG_SPLIT_PRES_BULBO_GRANDE_ADC:
116:               			return Adc_P_Grande;
004388  8042C4     MOV Adc_P_Grande, W4
00438A  370197     BRA 0x46BA
117:               		case REG_SPLIT_PRES_BULBO_PICCOLO_ADC:
118:               			return Adc_P_Piccolo;
00438C  8042D4     MOV Adc_P_Piccolo, W4
00438E  370195     BRA 0x46BA
119:               		case REG_SPLIT_I_FAN_ADC:
120:               			return Adc_I_Fan;
004390  8042E4     MOV Adc_I_Fan, W4
004392  370193     BRA 0x46BA
121:               
122:               		case REG_SPLIT_DIGIT_INPUT:					// stato digital input
123:               			return Me.Digi_In;
004394  20BA24     MOV #0xBA2, W4
004396  784214     MOV.B [W4], W4
004398  FB8204     ZE W4, W4
00439A  37018F     BRA 0x46BA
124:               		case REG_SPLIT_DIGIT_OUTPUT:				// stato digital out
125:               			return Me.Digi_Out;
00439C  20BA34     MOV #0xBA3, W4
00439E  784214     MOV.B [W4], W4
0043A0  FB8204     ZE W4, W4
0043A2  37018B     BRA 0x46BA
126:               
127:               		case REG_SPLIT_PWM_REQ_FAN_VALUE:			// gestione ventola
128:               			return Me.Pwm_Req;
0043A4  805C74     MOV 0xB8E, W4
0043A6  370189     BRA 0x46BA
129:               		case REG_SPLIT_PWM_ACT_FAN_VALUE:
130:               			return Me.Pwm_Value;
0043A8  805C84     MOV 0xB90, W4
0043AA  370187     BRA 0x46BA
131:               		case REG_SPLIT_FAN_TACHO:
132:               			return Me.Fan_Tacho;
0043AC  805C94     MOV 0xB92, W4
0043AE  370185     BRA 0x46BA
133:               
134:               		case  REG_SPLIT_VENTIL_MODE:				// gestione modalità operativa
135:               			return Me.Ventil_Mode;
0043B0  805C54     MOV 0xB8A, W4
0043B2  370183     BRA 0x46BA
136:               		case REG_SPLIT_FUNCTION_MODE:
137:               			return Me.Function_Mode;
0043B4  805C24     MOV 0xB84, W4
0043B6  370181     BRA 0x46BA
138:               		case REG_SPLIT_CURRENT_SP:
139:               			return Me.SP;
0043B8  805BC4     MOV 0xB78, W4
0043BA  37017F     BRA 0x46BA
140:               		case REG_SPLIT_CURRENT_EVAP_TEMP:
141:               			return Me.Evap_Temp;
0043BC  805BF4     MOV 0xB7E, W4
0043BE  37017D     BRA 0x46BA
142:               
143:               		case REG_SPLIT_DEFINE_MODE:
144:               			return Me.DefMode;
0043C0  805C34     MOV 0xB86, W4
0043C2  37017B     BRA 0x46BA
145:               		case REG_SPLIT_CURRENT_EVAP_PRESURE:
146:               			return Me.Evap_Press;
0043C4  805C04     MOV 0xB80, W4
0043C6  370179     BRA 0x46BA
147:               
148:               		case REG_SPLIT_VALVOLA_CUR_POS:				// gestione valvola
149:               			return Me.ExpValve_Act;
0043C8  805CC4     MOV 0xB98, W4
0043CA  370177     BRA 0x46BA
150:               		case REG_SPLIT_VALVOLA_SET_POS:
151:               			return Me.ExpValve_Req;
0043CC  805CB4     MOV 0xB96, W4
0043CE  370175     BRA 0x46BA
152:               		case REG_SPLIT_VALV_STP_REF_TIME:
153:               			return StepRefreshTime;
0043D0  20AF24     MOV #0xAF2, W4
0043D2  784214     MOV.B [W4], W4
0043D4  FB8204     ZE W4, W4
0043D6  370171     BRA 0x46BA
154:               		case REG_SPLIT_VALV_MAX_STEP:
155:               			return ValvolaMaxStepNum;
0043D8  8057A4     MOV ValvolaMaxStepNum, W4
0043DA  37016F     BRA 0x46BA
156:               /*		case REG_SPLIT_CORRENTE_MAX_VALV:
157:               			return 0x0000;
158:               		case REG_SPLIT_CORRENTE_MIN_VALV:
159:               			return 0x0000;
160:               		case REG_SPLIT_THR_MIN_AMP_VALV:
161:               			return 0x0000;
162:               		case REG_SPLIT_THR_MAX_AMP_VALV:
163:               			return 0x0000;
164:               */
165:               
166:               		case REG_SPLIT_ENGENIE_BOX_COMPRESSOR_SPEED:	// gestione info box motore
167:               			return EngineBox.Compressor_Speed;
0043DC  805A04     MOV 0xB40, W4
0043DE  37016D     BRA 0x46BA
168:               		case REG_SPLIT_ENGENIE_BOX_WATER_PUMP_SPEED:
169:               			return EngineBox.Pump_Speed;
0043E0  805A14     MOV 0xB42, W4
0043E2  37016B     BRA 0x46BA
170:               		case REG_SPLIT_ENGENIE_BOX_FLUX:
171:               			return EngineBox.Water_Flux;
0043E4  805A24     MOV 0xB44, W4
0043E6  370169     BRA 0x46BA
172:               		case REG_SPLIT_CURRENT_MODE_ENGENIE_BOX:
173:               			return EngineBox.FunctionMode;
0043E8  805A54     MOV 0xB4A, W4
0043EA  370167     BRA 0x46BA
174:               		case REG_SPLIT_CURRENT_REQ_PRESSURE:
175:               			return EngineBox.Ric_Pressione;
0043EC  8059F4     MOV 0xB3E, W4
0043EE  370165     BRA 0x46BA
176:               		case REG_SPLIT_ENGENIE_BOX_TEMP_MANDATA:
177:               			return EngineBox.Temp_Mandata;
0043F0  805944     MOV EngineBox, W4
0043F2  370163     BRA 0x46BA
178:               		case REG_SPLIT_ENGENIE_BOX_TEMP_RITORNO:
179:               			return EngineBox.Temp_Ritorno;
0043F4  805954     MOV 0xB2A, W4
0043F6  370161     BRA 0x46BA
180:               		case REG_SPLIT_ENGENIE_BOX_TEMP_ACQUA_MARE:
181:               			return EngineBox.Temp_Acqua_Mare;
0043F8  805974     MOV 0xB2E, W4
0043FA  37015F     BRA 0x46BA
182:               		case REG_SPLIT_ENGENIE_BOX_TEMP_CONDENSATORE:
183:               			return EngineBox.Temp_Condensatore;
0043FC  805964     MOV 0xB2C, W4
0043FE  37015D     BRA 0x46BA
184:               		case REG_SPLIT_ENGENIE_BOX_TEMP_BIG:
185:               			return EngineBox.Temp_Collettore_Grande;
004400  805984     MOV 0xB30, W4
004402  37015B     BRA 0x46BA
186:               		case REG_SPLIT_ENGENIE_BOX_TEMP_SMALL:
187:               			return EngineBox.Temp_Collettore_Piccolo;
004404  805994     MOV 0xB32, W4
004406  370159     BRA 0x46BA
188:               		case REG_SPLIT_ENGENIE_BOX_PRESSURE_BIG:
189:               			return EngineBox.Pressione_Gas_G;
004408  8059A4     MOV 0xB34, W4
00440A  370157     BRA 0x46BA
190:               		case REG_SPLIT_ENGENIE_BOX_PRESSURE_SMALL:
191:               			return EngineBox.Pressione_Liq_P;
00440C  8059B4     MOV 0xB36, W4
00440E  370155     BRA 0x46BA
192:               		case REG_SPLIT_ENGENIE_BOX_PRESSURE_VRV_BOX:
193:               			return EngineBox.Pressione_VRV_Box;
004410  8059C4     MOV 0xB38, W4
004412  370153     BRA 0x46BA
194:               		case REG_SPLIT_ENGENIE_BOX_PRESSURE_AUX:
195:               			return EngineBox.Pressione_Aux;
004414  8059D4     MOV 0xB3A, W4
004416  370151     BRA 0x46BA
196:               		case REG_SPLIT_ENGENIE_BOX_RELE_SATUS:
197:               			return EngineBox.ReleSt;
004418  805AE4     MOV 0xB5C, W4
00441A  37014F     BRA 0x46BA
198:               		case REG_SPLIT_ENGENIE_BOX_INPUT_STATUS:
199:               			return EngineBox.InputSt;
00441C  805AC4     MOV 0xB58, W4
00441E  37014D     BRA 0x46BA
200:               		case REG_SPLIT_ENGENIE_BOX_SYS_ID_LO:
201:               			return EngineBox.SysNumLo;
004420  805B24     MOV 0xB64, W4
004422  37014B     BRA 0x46BA
202:               		case REG_SPLIT_ENGENIE_BOX_SYS_ID_HI:
203:               			return EngineBox.SysNumHi;
004424  805B34     MOV 0xB66, W4
004426  370149     BRA 0x46BA
204:               		case REG_SPLIT_ERRORE_1_BOX_MOTORE:
205:               			return EngineBox.Errori1;
004428  805AF4     MOV 0xB5E, W4
00442A  370147     BRA 0x46BA
206:               		case REG_SPLIT_ERRORE_2_BOX_MOTORE:
207:               			return EngineBox.Errori2;
00442C  805B04     MOV 0xB60, W4
00442E  370145     BRA 0x46BA
208:               		case REG_SPLIT_STATUS_BOX_MOTORE:
209:               			return EngineBox.StatoCompressore;
004430  20B4C4     MOV #0xB4C, W4
004432  784214     MOV.B [W4], W4
004434  FB0204     SE W4, W4
004436  370141     BRA 0x46BA
210:               		case REG_SPLIT_ID_SPLIT_MASTER:
211:               			return EngineBox.IdMasterSplit;
004438  20B4D4     MOV #0xB4D, W4
00443A  784214     MOV.B [W4], W4
00443C  FB0204     SE W4, W4
00443E  37013D     BRA 0x46BA
212:               		case REG_SPLIT_POWER_LIMIT:
213:               			return EngineBox.PowerLimit;
004440  805A34     MOV 0xB46, W4
004442  37013B     BRA 0x46BA
214:               		case REG_SPLIT_POWER_LIMIT_REQ:
215:               			return Me.PowerLimit;
004444  805BD4     MOV 0xB7A, W4
004446  370139     BRA 0x46BA
216:               		case REG_SPLIT_STATUS:
217:               			Me.Error.ClearErrReq = 0;
004448  A90BAC     BCLR 0xBAC, #0
218:               			Me.Error.ClearDiagnosticSplitErrReq = 0;
00444A  A92BAD     BCLR 0xBAD, #1
219:               			return Me.SplitStatus;
00444C  805CF4     MOV 0xB9E, W4
00444E  370135     BRA 0x46BA
220:               		case REG_SPLIT_ENGINE_BOX_CYCLE_TIME:
221:               			return EngineBox.SystemCycleTime;
004450  805B44     MOV 0xB68, W4
004452  370133     BRA 0x46BA
222:               		case REG_SPLIT_ENGINE_BOX_HOURS_OF_LIFE:
223:               			return EngineBox.HoursOfLife;
004454  805B54     MOV 0xB6A, W4
004456  370131     BRA 0x46BA
224:               
225:               		case REG_DIAG_SPLIT_TEST_ADDRESS:			// #v16
226:               			return DiagnosticSplit.Address;			// Indirizzo slave da monitorare
004458  807144     MOV DiagnosticSplit, W4
00445A  37012F     BRA 0x46BA
227:               		case REG_DIAG_SPLIT_STATUS:					
228:               			return DiagnosticSplit.SplitStatus;		
00445C  807154     MOV 0xE2A, W4
00445E  37012D     BRA 0x46BA
229:               		case REG_DIAG_SPLIT_LIQ_TEMP:					
230:               			return DiagnosticSplit.Temp_Liq;	
004460  807174     MOV 0xE2E, W4
004462  37012B     BRA 0x46BA
231:               		case REG_DIAG_SPLIT_GAS_TEMP:					
232:               			return DiagnosticSplit.Temp_Gas;	
004464  807164     MOV 0xE2C, W4
004466  370129     BRA 0x46BA
233:               		case REG_DIAG_SPLIT_AIR_IN:					
234:               			return DiagnosticSplit.Temp_AirIn;	
004468  807194     MOV 0xE32, W4
00446A  370127     BRA 0x46BA
235:               		case REG_DIAG_SPLIT_AIR_OUT:					
236:               			return DiagnosticSplit.Temp_AirOut;	
00446C  807184     MOV 0xE30, W4
00446E  370125     BRA 0x46BA
237:               		case REG_DIAG_SPLIT_FAN_SPEED:					
238:               			return DiagnosticSplit.FanSpeed;	
004470  8071A4     MOV 0xE34, W4
004472  370123     BRA 0x46BA
239:               		case REG_DIAG_SPLIT_EXP_VALVE:					
240:               			return DiagnosticSplit.Exp_Valve;	
004474  8071B4     MOV 0xE36, W4
004476  370121     BRA 0x46BA
241:               		case REG_DIAG_SPLIT_GAS_PRESSURE:					
242:               			return DiagnosticSplit.Gas_Pressure;	
004478  8071C4     MOV 0xE38, W4
00447A  37011F     BRA 0x46BA
243:               		case REG_DIAG_SPLIT_LIQ_PRESSURE:					
244:               			return DiagnosticSplit.Liq_Pressure;	
00447C  8071D4     MOV 0xE3A, W4
00447E  37011D     BRA 0x46BA
245:               		case REG_DIAG_SPLIT_REQUEST_AIR_TEMP:					
246:               			return DiagnosticSplit.Req_AirTemp;	
004480  8071E4     MOV 0xE3C, W4
004482  37011B     BRA 0x46BA
247:               		case REG_DIAG_SPLIT_REQUEST_AIR_PRES:					
248:               			return DiagnosticSplit.Req_Pressure;	
004484  8071F4     MOV 0xE3E, W4
004486  370119     BRA 0x46BA
249:               		case REG_DIAG_SPLIT_ENG_MODE:					
250:               			return DiagnosticSplit.Split_Eng_Mode;
004488  807204     MOV 0xE40, W4
00448A  370117     BRA 0x46BA
251:               		case REG_DIAG_SPLIT_CYCLE_TIME:					
252:               			return Me.CycleTime;
00448C  805D04     MOV 0xBA0, W4
00448E  370115     BRA 0x46BA
253:               
254:               		case REG_DIAG_INVERTER_ALARM:	
255:               			return DiagnosticInverter.Alarm;		
004490  807244     MOV DiagnosticInverter, W4
004492  370113     BRA 0x46BA
256:               		case REG_DIAG_INVERTER_OUT_FREQ:
257:               			return DiagnosticInverter.OutFreq;				
004494  807254     MOV 0xE4A, W4
004496  370111     BRA 0x46BA
258:               		case REG_DIAG_INVERTER_STATUS:		
259:               			return DiagnosticInverter.Status;		 
004498  807264     MOV 0xE4C, W4
00449A  37010F     BRA 0x46BA
260:               		case REG_DIAG_INVERTER_OUT_CURRENT:	
261:               			return DiagnosticInverter.OutCurr;	
00449C  807274     MOV 0xE4E, W4
00449E  37010D     BRA 0x46BA
262:               		case REG_DIAG_INVERTER_IN_VOLTAGE:	
263:               			return DiagnosticInverter.InVolt;	
0044A0  807284     MOV 0xE50, W4
0044A2  37010B     BRA 0x46BA
264:               		case REG_DIAG_INVERTER_OUT_VOLTAGE:	
265:               			return DiagnosticInverter.OutVolt;	
0044A4  807294     MOV 0xE52, W4
0044A6  370109     BRA 0x46BA
266:               		case REG_DIAG_INVERTER_IN_POWER:	
267:               			return DiagnosticInverter.InPower;
0044A8  8072A4     MOV 0xE54, W4
0044AA  370107     BRA 0x46BA
268:               		case REG_DIAG_INVERTER_OUT_POWER:	
269:               			return DiagnosticInverter.OutPower;
0044AC  8072B4     MOV 0xE56, W4
0044AE  370105     BRA 0x46BA
270:               		case REG_DIAG_INVERTER_REQ_FREQ:	
271:               			return DiagnosticInverter.ReqFreq;
0044B0  8072C4     MOV 0xE58, W4
0044B2  370103     BRA 0x46BA
272:               		case REG_DIAG_INVERTER_MAX_REQ_FREQ:	
273:               			return DiagnosticInverter.MaxReqFreq;
0044B4  8072D4     MOV 0xE5A, W4
0044B6  370101     BRA 0x46BA
274:               
275:               		case REG_SPLIT_PWM_VALUE_OFF:				// valori predefiniti delle velocità
276:               			return PWMValue[0];
0044B8  8055C4     MOV PWMValue, W4
0044BA  3700FF     BRA 0x46BA
277:               		case REG_SPLIT_PWM_VALUE_NIGHT:
278:               			return PWMValue[1];
0044BC  8055D4     MOV 0xABA, W4
0044BE  3700FD     BRA 0x46BA
279:               		case REG_SPLIT_PWM_VALUE_SPEED1:
280:               			return PWMValue[2];
0044C0  8055E4     MOV 0xABC, W4
0044C2  3700FB     BRA 0x46BA
281:               		case REG_SPLIT_PWM_VALUE_SPEED2:
282:               			return PWMValue[3];
0044C4  8055F4     MOV 0xABE, W4
0044C6  3700F9     BRA 0x46BA
283:               		case REG_SPLIT_PWM_VALUE_SPEED3:
284:               			return PWMValue[4];
0044C8  805604     MOV 0xAC0, W4
0044CA  3700F7     BRA 0x46BA
285:               		case REG_SPLIT_PWM_VALUE_SPEED4:
286:               			return PWMValue[5];
0044CC  805614     MOV 0xAC2, W4
0044CE  3700F5     BRA 0x46BA
287:               		case REG_SPLIT_PWM_VALUE_SPEED5:
288:               			return PWMValue[6];
0044D0  805624     MOV 0xAC4, W4
0044D2  3700F3     BRA 0x46BA
289:               		case REG_SPLIT_PWM_VALUE_SPEED6:
290:               			return PWMValue[7];
0044D4  805634     MOV 0xAC6, W4
0044D6  3700F1     BRA 0x46BA
291:               		case REG_SPLIT_PWM_VALUE_SPEED7:
292:               			return PWMValue[8];
0044D8  805644     MOV 0xAC8, W4
0044DA  3700EF     BRA 0x46BA
293:               
294:               		case REG_SPLIT_TEMP_LIMIT_NIGHT:			// valori di temp limite per le velocità
295:               			return TempLimitSpeed[0];
0044DC  805654     MOV TempLimitSpeed, W4
0044DE  3700ED     BRA 0x46BA
296:               		case REG_SPLIT_TEMP_LIMIT_SPEED1:
297:               			return TempLimitSpeed[1];
0044E0  805664     MOV 0xACC, W4
0044E2  3700EB     BRA 0x46BA
298:               		case REG_SPLIT_TEMP_LIMIT_SPEED2:
299:               			return TempLimitSpeed[2];
0044E4  805674     MOV 0xACE, W4
0044E6  3700E9     BRA 0x46BA
300:               		case REG_SPLIT_TEMP_LIMIT_SPEED3:
301:               			return TempLimitSpeed[3];
0044E8  805684     MOV 0xAD0, W4
0044EA  3700E7     BRA 0x46BA
302:               		case REG_SPLIT_TEMP_LIMIT_SPEED4:
303:               			return TempLimitSpeed[4];
0044EC  805694     MOV 0xAD2, W4
0044EE  3700E5     BRA 0x46BA
304:               		case REG_SPLIT_TEMP_LIMIT_SPEED5:
305:               			return TempLimitSpeed[5];
0044F0  8056A4     MOV 0xAD4, W4
0044F2  3700E3     BRA 0x46BA
306:               		case REG_SPLIT_TEMP_LIMIT_SPEED6:
307:               			return TempLimitSpeed[6];
0044F4  8056B4     MOV 0xAD6, W4
0044F6  3700E1     BRA 0x46BA
308:               		case REG_SPLIT_TEMP_LIMIT_SPEED7:
309:               			return TempLimitSpeed[7];
0044F8  8056C4     MOV 0xAD8, W4
0044FA  3700DF     BRA 0x46BA
310:               
311:               		case REG_SPLIT_AD_T1_0:						// valori AD notevoli per calibrazione temp bulbo grande
312:               			return AD_T_Grande[0];
0044FC  804484     MOV AD_T_Grande, W4
0044FE  3700DD     BRA 0x46BA
313:               		case REG_SPLIT_AD_T1_1:
314:               			return AD_T_Grande[1];
004500  804494     MOV 0x892, W4
004502  3700DB     BRA 0x46BA
315:               		case REG_SPLIT_AD_T1_2:
316:               			return AD_T_Grande[2];
004504  8044A4     MOV 0x894, W4
004506  3700D9     BRA 0x46BA
317:               		case REG_SPLIT_AD_T1_3:
318:               			return AD_T_Grande[3];
004508  8044B4     MOV 0x896, W4
00450A  3700D7     BRA 0x46BA
319:               		case REG_SPLIT_AD_T1_4:
320:               			return AD_T_Grande[4];
00450C  8044C4     MOV 0x898, W4
00450E  3700D5     BRA 0x46BA
321:               		case REG_SPLIT_AD_T1_5:
322:               			return AD_T_Grande[5];
004510  8044D4     MOV 0x89A, W4
004512  3700D3     BRA 0x46BA
323:               		case REG_SPLIT_AD_T1_6:
324:               			return AD_T_Grande[6];
004514  8044E4     MOV 0x89C, W4
004516  3700D1     BRA 0x46BA
325:               		case REG_SPLIT_AD_T1_7:
326:               			return AD_T_Grande[7];
004518  8044F4     MOV 0x89E, W4
00451A  3700CF     BRA 0x46BA
327:               		case REG_SPLIT_AD_T1_8:
328:               			return AD_T_Grande[8];
00451C  804504     MOV 0x8A0, W4
00451E  3700CD     BRA 0x46BA
329:               		case REG_SPLIT_AD_T1_9:
330:               			return AD_T_Grande[9];
004520  804514     MOV 0x8A2, W4
004522  3700CB     BRA 0x46BA
331:               		case REG_SPLIT_AD_T1_10:
332:               			return AD_T_Grande[10];
004524  804524     MOV 0x8A4, W4
004526  3700C9     BRA 0x46BA
333:               		case REG_SPLIT_AD_T1_11:
334:               			return AD_T_Grande[11];
004528  804534     MOV 0x8A6, W4
00452A  3700C7     BRA 0x46BA
335:               
336:               		case REG_SPLIT_AD_T2_0:						// valori AD notevoli per calibrazione temp bulbo piccolo
337:               			return AD_T_Piccolo[0];
00452C  8043C4     MOV AD_T_Piccolo, W4
00452E  3700C5     BRA 0x46BA
338:               		case REG_SPLIT_AD_T2_1:
339:               			return AD_T_Piccolo[1];
004530  8043D4     MOV 0x87A, W4
004532  3700C3     BRA 0x46BA
340:               		case REG_SPLIT_AD_T2_2:
341:               			return AD_T_Piccolo[2];
004534  8043E4     MOV 0x87C, W4
004536  3700C1     BRA 0x46BA
342:               		case REG_SPLIT_AD_T2_3:
343:               			return AD_T_Piccolo[3];
004538  8043F4     MOV 0x87E, W4
00453A  3700BF     BRA 0x46BA
344:               		case REG_SPLIT_AD_T2_4:
345:               			return AD_T_Piccolo[4];
00453C  804404     MOV 0x880, W4
00453E  3700BD     BRA 0x46BA
346:               		case REG_SPLIT_AD_T2_5:
347:               			return AD_T_Piccolo[5];
004540  804414     MOV 0x882, W4
004542  3700BB     BRA 0x46BA
348:               		case REG_SPLIT_AD_T2_6:
349:               			return AD_T_Piccolo[6];
004544  804424     MOV 0x884, W4
004546  3700B9     BRA 0x46BA
350:               		case REG_SPLIT_AD_T2_7:
351:               			return AD_T_Piccolo[7];
004548  804434     MOV 0x886, W4
00454A  3700B7     BRA 0x46BA
352:               		case REG_SPLIT_AD_T2_8:
353:               			return AD_T_Piccolo[8];
00454C  804444     MOV 0x888, W4
00454E  3700B5     BRA 0x46BA
354:               		case REG_SPLIT_AD_T2_9:
355:               			return AD_T_Piccolo[9];
004550  804454     MOV 0x88A, W4
004552  3700B3     BRA 0x46BA
356:               		case REG_SPLIT_AD_T2_10:
357:               			return AD_T_Piccolo[10];
004554  804464     MOV 0x88C, W4
004556  3700B1     BRA 0x46BA
358:               		case REG_SPLIT_AD_T2_11:
359:               			return AD_T_Piccolo[11];
004558  804474     MOV 0x88E, W4
00455A  3700AF     BRA 0x46BA
360:               
361:               		case REG_SPLIT_AD_T3_0:						// valori AD notevoli per calibrazione temp aria uscita
362:               			return AD_T_Out[0];
00455C  804544     MOV AD_T_Out, W4
00455E  3700AD     BRA 0x46BA
363:               		case REG_SPLIT_AD_T3_1:
364:               			return AD_T_Out[1];
004560  804554     MOV 0x8AA, W4
004562  3700AB     BRA 0x46BA
365:               		case REG_SPLIT_AD_T3_2:
366:               			return AD_T_Out[2];
004564  804564     MOV 0x8AC, W4
004566  3700A9     BRA 0x46BA
367:               		case REG_SPLIT_AD_T3_3:
368:               			return AD_T_Out[3];
004568  804574     MOV 0x8AE, W4
00456A  3700A7     BRA 0x46BA
369:               		case REG_SPLIT_AD_T3_4:
370:               			return AD_T_Out[4];
00456C  804584     MOV 0x8B0, W4
00456E  3700A5     BRA 0x46BA
371:               		case REG_SPLIT_AD_T3_5:
372:               			return AD_T_Out[5];
004570  804594     MOV 0x8B2, W4
004572  3700A3     BRA 0x46BA
373:               		case REG_SPLIT_AD_T3_6:
374:               			return AD_T_Out[6];
004574  8045A4     MOV 0x8B4, W4
004576  3700A1     BRA 0x46BA
375:               		case REG_SPLIT_AD_T3_7:
376:               			return AD_T_Out[7];
004578  8045B4     MOV 0x8B6, W4
00457A  37009F     BRA 0x46BA
377:               		case REG_SPLIT_AD_T3_8:
378:               			return AD_T_Out[8];
00457C  8045C4     MOV 0x8B8, W4
00457E  37009D     BRA 0x46BA
379:               		case REG_SPLIT_AD_T3_9:
380:               			return AD_T_Out[9];
004580  8045D4     MOV 0x8BA, W4
004582  37009B     BRA 0x46BA
381:               		case REG_SPLIT_AD_T3_10:
382:               			return AD_T_Out[10];
004584  8045E4     MOV 0x8BC, W4
004586  370099     BRA 0x46BA
383:               		case REG_SPLIT_AD_T3_11:
384:               			return AD_T_Out[11];
004588  8045F4     MOV 0x8BE, W4
00458A  370097     BRA 0x46BA
385:               
386:               		case REG_SPLIT_AD_T4_0:						// valori AD notevoli per calibrazione temp aria ambiente
387:               			return AD_T_Amb[0];
00458C  804604     MOV AD_T_Amb, W4
00458E  370095     BRA 0x46BA
388:               		case REG_SPLIT_AD_T4_1:
389:               			return AD_T_Amb[1];
004590  804614     MOV 0x8C2, W4
004592  370093     BRA 0x46BA
390:               		case REG_SPLIT_AD_T4_2:
391:               			return AD_T_Amb[2];
004594  804624     MOV 0x8C4, W4
004596  370091     BRA 0x46BA
392:               		case REG_SPLIT_AD_T4_3:
393:               			return AD_T_Amb[3];
004598  804634     MOV 0x8C6, W4
00459A  37008F     BRA 0x46BA
394:               		case REG_SPLIT_AD_T4_4:
395:               			return AD_T_Amb[4];
00459C  804644     MOV 0x8C8, W4
00459E  37008D     BRA 0x46BA
396:               		case REG_SPLIT_AD_T4_5:
397:               			return AD_T_Amb[5];
0045A0  804654     MOV 0x8CA, W4
0045A2  37008B     BRA 0x46BA
398:               		case REG_SPLIT_AD_T4_6:
399:               			return AD_T_Amb[6];
0045A4  804664     MOV 0x8CC, W4
0045A6  370089     BRA 0x46BA
400:               		case REG_SPLIT_AD_T4_7:
401:               			return AD_T_Amb[7];
0045A8  804674     MOV 0x8CE, W4
0045AA  370087     BRA 0x46BA
402:               		case REG_SPLIT_AD_T4_8:
403:               			return AD_T_Amb[8];
0045AC  804684     MOV 0x8D0, W4
0045AE  370085     BRA 0x46BA
404:               		case REG_SPLIT_AD_T4_9:
405:               			return AD_T_Amb[9];
0045B0  804694     MOV 0x8D2, W4
0045B2  370083     BRA 0x46BA
406:               		case REG_SPLIT_AD_T4_10:
407:               			return AD_T_Amb[10];
0045B4  8046A4     MOV 0x8D4, W4
0045B6  370081     BRA 0x46BA
408:               		case REG_SPLIT_AD_T4_11:
409:               			return AD_T_Amb[11];
0045B8  8046B4     MOV 0x8D6, W4
0045BA  37007F     BRA 0x46BA
410:               
411:               		case REG_SPLIT_KT_T1_0:						// fattore di crescita per calibrazione temp bulbo grande
412:               			return Kt_T_Grande[0];
0045BC  804774     MOV Kt_T_Grande, W4
0045BE  37007D     BRA 0x46BA
413:               		case REG_SPLIT_KT_T1_1:
414:               			return Kt_T_Grande[1];
0045C0  804784     MOV 0x8F0, W4
0045C2  37007B     BRA 0x46BA
415:               		case REG_SPLIT_KT_T1_2:
416:               			return Kt_T_Grande[2];
0045C4  804794     MOV 0x8F2, W4
0045C6  370079     BRA 0x46BA
417:               		case REG_SPLIT_KT_T1_3:
418:               			return Kt_T_Grande[3];
0045C8  8047A4     MOV 0x8F4, W4
0045CA  370077     BRA 0x46BA
419:               		case REG_SPLIT_KT_T1_4:
420:               			return Kt_T_Grande[4];
0045CC  8047B4     MOV 0x8F6, W4
0045CE  370075     BRA 0x46BA
421:               		case REG_SPLIT_KT_T1_5:
422:               			return Kt_T_Grande[5];
0045D0  8047C4     MOV 0x8F8, W4
0045D2  370073     BRA 0x46BA
423:               		case REG_SPLIT_KT_T1_6:
424:               			return Kt_T_Grande[6];
0045D4  8047D4     MOV 0x8FA, W4
0045D6  370071     BRA 0x46BA
425:               		case REG_SPLIT_KT_T1_7:
426:               			return Kt_T_Grande[7];
0045D8  8047E4     MOV 0x8FC, W4
0045DA  37006F     BRA 0x46BA
427:               		case REG_SPLIT_KT_T1_8:
428:               			return Kt_T_Grande[8];
0045DC  8047F4     MOV 0x8FE, W4
0045DE  37006D     BRA 0x46BA
429:               		case REG_SPLIT_KT_T1_9:
430:               			return Kt_T_Grande[9];
0045E0  804804     MOV 0x900, W4
0045E2  37006B     BRA 0x46BA
431:               		case REG_SPLIT_KT_T1_10:
432:               			return Kt_T_Grande[10];
0045E4  804814     MOV 0x902, W4
0045E6  370069     BRA 0x46BA
433:               
434:               		case REG_SPLIT_KT_T2_0:						// fattore di crescita per calibrazione temp bulbo piccolo
435:               			return Kt_T_Piccolo[0];
0045E8  8046C4     MOV Kt_T_Piccolo, W4
0045EA  370067     BRA 0x46BA
436:               		case REG_SPLIT_KT_T2_1:
437:               			return Kt_T_Piccolo[1];
0045EC  8046D4     MOV 0x8DA, W4
0045EE  370065     BRA 0x46BA
438:               		case REG_SPLIT_KT_T2_2:
439:               			return Kt_T_Piccolo[2];
0045F0  8046E4     MOV 0x8DC, W4
0045F2  370063     BRA 0x46BA
440:               		case REG_SPLIT_KT_T2_3:
441:               			return Kt_T_Piccolo[3];
0045F4  8046F4     MOV 0x8DE, W4
0045F6  370061     BRA 0x46BA
442:               		case REG_SPLIT_KT_T2_4:
443:               			return Kt_T_Piccolo[4];
0045F8  804704     MOV 0x8E0, W4
0045FA  37005F     BRA 0x46BA
444:               		case REG_SPLIT_KT_T2_5:
445:               			return Kt_T_Piccolo[5];
0045FC  804714     MOV 0x8E2, W4
0045FE  37005D     BRA 0x46BA
446:               		case REG_SPLIT_KT_T2_6:
447:               			return Kt_T_Piccolo[6];
004600  804724     MOV 0x8E4, W4
004602  37005B     BRA 0x46BA
448:               		case REG_SPLIT_KT_T2_7:
449:               			return Kt_T_Piccolo[7];
004604  804734     MOV 0x8E6, W4
004606  370059     BRA 0x46BA
450:               		case REG_SPLIT_KT_T2_8:
451:               			return Kt_T_Piccolo[8];
004608  804744     MOV 0x8E8, W4
00460A  370057     BRA 0x46BA
452:               		case REG_SPLIT_KT_T2_9:
453:               			return Kt_T_Piccolo[9];
00460C  804754     MOV 0x8EA, W4
00460E  370055     BRA 0x46BA
454:               		case REG_SPLIT_KT_T2_10:
455:               			return Kt_T_Piccolo[10];
004610  804764     MOV 0x8EC, W4
004612  370053     BRA 0x46BA
456:               
457:               		case REG_SPLIT_KT_T3_0:						// fattore di crescita per calibrazione temp aria uscita
458:               			return Kt_T_Out[0];
004614  804824     MOV Kt_T_Out, W4
004616  370051     BRA 0x46BA
459:               		case REG_SPLIT_KT_T3_1:
460:               			return Kt_T_Out[1];
004618  804834     MOV 0x906, W4
00461A  37004F     BRA 0x46BA
461:               		case REG_SPLIT_KT_T3_2:
462:               			return Kt_T_Out[2];
00461C  804844     MOV 0x908, W4
00461E  37004D     BRA 0x46BA
463:               		case REG_SPLIT_KT_T3_3:
464:               			return Kt_T_Out[3];
004620  804854     MOV 0x90A, W4
004622  37004B     BRA 0x46BA
465:               		case REG_SPLIT_KT_T3_4:
466:               			return Kt_T_Out[4];
004624  804864     MOV 0x90C, W4
004626  370049     BRA 0x46BA
467:               		case REG_SPLIT_KT_T3_5:
468:               			return Kt_T_Out[5];
004628  804874     MOV 0x90E, W4
00462A  370047     BRA 0x46BA
469:               		case REG_SPLIT_KT_T3_6:
470:               			return Kt_T_Out[6];
00462C  804884     MOV 0x910, W4
00462E  370045     BRA 0x46BA
471:               		case REG_SPLIT_KT_T3_7:
472:               			return Kt_T_Out[7];
004630  804894     MOV 0x912, W4
004632  370043     BRA 0x46BA
473:               		case REG_SPLIT_KT_T3_8:
474:               			return Kt_T_Out[8];
004634  8048A4     MOV 0x914, W4
004636  370041     BRA 0x46BA
475:               		case REG_SPLIT_KT_T3_9:
476:               			return Kt_T_Out[9];
004638  8048B4     MOV 0x916, W4
00463A  37003F     BRA 0x46BA
477:               		case REG_SPLIT_KT_T3_10:
478:               			return Kt_T_Out[10];
00463C  8048C4     MOV 0x918, W4
00463E  37003D     BRA 0x46BA
479:               
480:               		case REG_SPLIT_KT_T4_0:						// fattore di crescita per calibrazione temp ambiente
481:               			return Kt_T_Amb[0];
004640  8048D4     MOV Kt_T_Amb, W4
004642  37003B     BRA 0x46BA
482:               		case REG_SPLIT_KT_T4_1:
483:               			return Kt_T_Amb[1];
004644  8048E4     MOV 0x91C, W4
004646  370039     BRA 0x46BA
484:               		case REG_SPLIT_KT_T4_2:
485:               			return Kt_T_Amb[2];
004648  8048F4     MOV 0x91E, W4
00464A  370037     BRA 0x46BA
486:               		case REG_SPLIT_KT_T4_3:
487:               			return Kt_T_Amb[3];
00464C  804904     MOV 0x920, W4
00464E  370035     BRA 0x46BA
488:               		case REG_SPLIT_KT_T4_4:
489:               			return Kt_T_Amb[4];
004650  804914     MOV 0x922, W4
004652  370033     BRA 0x46BA
490:               		case REG_SPLIT_KT_T4_5:
491:               			return Kt_T_Amb[5];
004654  804924     MOV 0x924, W4
004656  370031     BRA 0x46BA
492:               		case REG_SPLIT_KT_T4_6:
493:               			return Kt_T_Amb[6];
004658  804934     MOV 0x926, W4
00465A  37002F     BRA 0x46BA
494:               		case REG_SPLIT_KT_T4_7:
495:               			return Kt_T_Amb[7];
00465C  804944     MOV 0x928, W4
00465E  37002D     BRA 0x46BA
496:               		case REG_SPLIT_KT_T4_8:
497:               			return Kt_T_Amb[8];
004660  804954     MOV 0x92A, W4
004662  37002B     BRA 0x46BA
498:               		case REG_SPLIT_KT_T4_9:
499:               			return Kt_T_Amb[9];
004664  804964     MOV 0x92C, W4
004666  370029     BRA 0x46BA
500:               		case REG_SPLIT_KT_T4_10:
501:               			return Kt_T_Amb[10];
004668  804974     MOV 0x92E, W4
00466A  370027     BRA 0x46BA
502:               
503:               		case REG_SPLIT_FW_VERSION:						// info generali
504:               			return Versione_Fw;
00466C  200044     MOV #0x4, W4
00466E  370025     BRA 0x46BA
505:               		case REG_SPLIT_FW_REVISION:
506:               			return Revisione_Fw;
004670  200134     MOV #0x13, W4
004672  370023     BRA 0x46BA
507:               		case REG_SPLIT_ID_MODULO:
508:               			return Id_Modulo;
004674  200184     MOV #0x18, W4
004676  370021     BRA 0x46BA
509:               		case REG_SPLIT_ADD_MODULO:
510:               			return My_Address;
004678  20A914     MOV #0xA91, W4
00467A  784214     MOV.B [W4], W4
00467C  FB8204     ZE W4, W4
00467E  37001D     BRA 0x46BA
511:               		case REG_SPLIT_SYSTEM_NUMBER_LO:
512:               			return ToInt(SN2, SN1);
004680  20AAA5     MOV #0xAAA, W5
004682  784295     MOV.B [W5], W5
004684  20AAB4     MOV #0xAAB, W4
004686  784214     MOV.B [W4], W4
004688  784085     MOV.B W5, W1
00468A  784004     MOV.B W4, W0
00468C  07115D     RCALL ToInt
00468E  780200     MOV W0, W4
004690  370014     BRA 0x46BA
513:               		case REG_SPLIT_SYSTEM_NUMBER_HI:
514:               			return ToInt(SN4, SN3);
004692  20AAC5     MOV #0xAAC, W5
004694  784295     MOV.B [W5], W5
004696  20AAD4     MOV #0xAAD, W4
004698  784214     MOV.B [W4], W4
00469A  784085     MOV.B W5, W1
00469C  784004     MOV.B W4, W0
00469E  071154     RCALL ToInt
0046A0  780200     MOV W0, W4
0046A2  37000B     BRA 0x46BA
515:               		case REG_SPLIT_FABRICATION_DAY:
516:               			return GiornoFabbricazione;
0046A4  805574     MOV GiornoFabbricazione, W4
0046A6  370009     BRA 0x46BA
517:               		case REG_SPLIT_FABRICATION_MONTH:
518:               			return MeseFabbricazione;
0046A8  805584     MOV MeseFabbricazione, W4
0046AA  370007     BRA 0x46BA
519:               		case REG_SPLIT_FABRICATION_YEAR:
520:               			return AnnoFabbricazione;
0046AC  805594     MOV AnnoFabbricazione, W4
0046AE  370005     BRA 0x46BA
521:               		case REG_SPLIT_CRC_16:
522:               			return CRC_Flash;
0046B0  805544     MOV CRC_Flash, W4
0046B2  370003     BRA 0x46BA
523:               		case REG_SPLIT_SAVE_2_E2:
524:               			return WriteE2Status;
0046B4  805534     MOV WriteE2Status, W4
0046B6  370001     BRA 0x46BA
525:               
526:               		default:
527:               			return 0xFFFF;
0046B8  EB8200     SETM W4
528:               	}
529:               }
0046BA  780004     MOV W4, W0
0046BC  FA8000     ULNK
0046BE  060000     RETURN
530:               
531:               char PutData(int Reg, int Value)
532:               {
0046C0  FA0004     LNK #0x4
0046C2  780F00     MOV W0, [W14]
0046C4  980711     MOV W1, [W14+2]
533:               	switch(Reg)
0046C6  78021E     MOV [W14], W4
0046C8  B92361     MUL.SU W4, #1, W6
0046CA  2005D4     MOV #0x5D, W4
0046CC  200005     MOV #0x0, W5
0046CE  420206     ADD W4, W6, W4
0046D0  4A8287     ADDC W5, W7, W5
0046D2  201D76     MOV #0x1D7, W6
0046D4  200007     MOV #0x0, W7
0046D6  520F86     SUB W4, W6, [W15]
0046D8  5A8F87     SUBB W5, W7, [W15]
0046DA  3E04E2     BRA GTU, 0x50A0
0046DC  016004     BRA W4
0046DE  3704A9     BRA 0x5032
0046E0  3704AF     BRA 0x5040
0046E2  3704BC     BRA 0x505C
0046E4  3704C9     BRA 0x5078
0046E6  3704CC     BRA 0x5080
0046E8  3704CF     BRA 0x5088
0046EA  3704D2     BRA 0x5090
0046EC  3704D5     BRA 0x5098
0046EE  3704D8     BRA 0x50A0
0046F0  3704D7     BRA 0x50A0
0046F2  3704D6     BRA 0x50A0
0046F4  3704D5     BRA 0x50A0
0046F6  3704D4     BRA 0x50A0
0046F8  3704D3     BRA 0x50A0
0046FA  3704D2     BRA 0x50A0
0046FC  3704D1     BRA 0x50A0
0046FE  3704D0     BRA 0x50A0
004700  3704CF     BRA 0x50A0
004702  3704CE     BRA 0x50A0
004704  3704CD     BRA 0x50A0
004706  3704CC     BRA 0x50A0
004708  3704CB     BRA 0x50A0
00470A  3704CA     BRA 0x50A0
00470C  3704C9     BRA 0x50A0
00470E  3704C8     BRA 0x50A0
004710  3704C7     BRA 0x50A0
004712  3704C6     BRA 0x50A0
004714  3704C5     BRA 0x50A0
004716  3704C4     BRA 0x50A0
004718  3704C3     BRA 0x50A0
00471A  3704C2     BRA 0x50A0
00471C  3704C1     BRA 0x50A0
00471E  3704C0     BRA 0x50A0
004720  3704BF     BRA 0x50A0
004722  3704BE     BRA 0x50A0
004724  3704BD     BRA 0x50A0
004726  3704BC     BRA 0x50A0
004728  3704BB     BRA 0x50A0
00472A  3704BA     BRA 0x50A0
00472C  3704B9     BRA 0x50A0
00472E  3704B8     BRA 0x50A0
004730  3704B7     BRA 0x50A0
004732  3704B6     BRA 0x50A0
004734  3704B5     BRA 0x50A0
004736  3704B4     BRA 0x50A0
004738  3704B3     BRA 0x50A0
00473A  3704B2     BRA 0x50A0
00473C  3704B1     BRA 0x50A0
00473E  3704B0     BRA 0x50A0
004740  3704AF     BRA 0x50A0
004742  3704AE     BRA 0x50A0
004744  3704AD     BRA 0x50A0
004746  3704AC     BRA 0x50A0
004748  3704AB     BRA 0x50A0
00474A  3704AA     BRA 0x50A0
00474C  3704A9     BRA 0x50A0
00474E  3704A8     BRA 0x50A0
004750  3704A7     BRA 0x50A0
004752  3704A6     BRA 0x50A0
004754  3704A5     BRA 0x50A0
004756  3704A4     BRA 0x50A0
004758  3704A3     BRA 0x50A0
00475A  3704A2     BRA 0x50A0
00475C  3704A1     BRA 0x50A0
00475E  3704A0     BRA 0x50A0
004760  37049F     BRA 0x50A0
004762  37049E     BRA 0x50A0
004764  37049D     BRA 0x50A0
004766  37049C     BRA 0x50A0
004768  37049B     BRA 0x50A0
00476A  37049A     BRA 0x50A0
00476C  370499     BRA 0x50A0
00476E  370498     BRA 0x50A0
004770  370497     BRA 0x50A0
004772  370496     BRA 0x50A0
004774  370495     BRA 0x50A0
004776  370494     BRA 0x50A0
004778  370493     BRA 0x50A0
00477A  370492     BRA 0x50A0
00477C  370491     BRA 0x50A0
00477E  370490     BRA 0x50A0
004780  37048F     BRA 0x50A0
004782  37048E     BRA 0x50A0
004784  37048D     BRA 0x50A0
004786  37048C     BRA 0x50A0
004788  37048B     BRA 0x50A0
00478A  37048A     BRA 0x50A0
00478C  370489     BRA 0x50A0
00478E  370488     BRA 0x50A0
004790  370487     BRA 0x50A0
004792  370486     BRA 0x50A0
004794  370485     BRA 0x50A0
004796  370484     BRA 0x50A0
004798  370483     BRA 0x50A0
00479A  370482     BRA 0x50A0
00479C  370481     BRA 0x50A0
00479E  370480     BRA 0x50A0
0047A0  37047F     BRA 0x50A0
0047A2  37047E     BRA 0x50A0
0047A4  37047D     BRA 0x50A0
0047A6  37047C     BRA 0x50A0
0047A8  37047B     BRA 0x50A0
0047AA  37047A     BRA 0x50A0
0047AC  370479     BRA 0x50A0
0047AE  370478     BRA 0x50A0
0047B0  370477     BRA 0x50A0
0047B2  370476     BRA 0x50A0
0047B4  370475     BRA 0x50A0
0047B6  370474     BRA 0x50A0
0047B8  370473     BRA 0x50A0
0047BA  370472     BRA 0x50A0
0047BC  370471     BRA 0x50A0
0047BE  370470     BRA 0x50A0
0047C0  37046F     BRA 0x50A0
0047C2  37046E     BRA 0x50A0
0047C4  37046D     BRA 0x50A0
0047C6  37046C     BRA 0x50A0
0047C8  37046B     BRA 0x50A0
0047CA  37046A     BRA 0x50A0
0047CC  370469     BRA 0x50A0
0047CE  370468     BRA 0x50A0
0047D0  370467     BRA 0x50A0
0047D2  370466     BRA 0x50A0
0047D4  370465     BRA 0x50A0
0047D6  370464     BRA 0x50A0
0047D8  370463     BRA 0x50A0
0047DA  370462     BRA 0x50A0
0047DC  370158     BRA 0x4A8E
0047DE  37015E     BRA 0x4A9C
0047E0  370161     BRA 0x4AA4
0047E2  37045E     BRA 0x50A0
0047E4  370163     BRA 0x4AAC
0047E6  370166     BRA 0x4AB4
0047E8  370169     BRA 0x4ABC
0047EA  37016C     BRA 0x4AC4
0047EC  370459     BRA 0x50A0
0047EE  370458     BRA 0x50A0
0047F0  370183     BRA 0x4AF8
0047F2  370186     BRA 0x4B00
0047F4  37018C     BRA 0x4B0E
0047F6  370454     BRA 0x50A0
0047F8  370453     BRA 0x50A0
0047FA  370452     BRA 0x50A0
0047FC  370451     BRA 0x50A0
0047FE  37016A     BRA 0x4AD4
004800  370165     BRA 0x4ACC
004802  37044E     BRA 0x50A0
004804  37044D     BRA 0x50A0
004806  37044C     BRA 0x50A0
004808  37044B     BRA 0x50A0
00480A  37044A     BRA 0x50A0
00480C  370449     BRA 0x50A0
00480E  370448     BRA 0x50A0
004810  370447     BRA 0x50A0
004812  370446     BRA 0x50A0
004814  370445     BRA 0x50A0
004816  370444     BRA 0x50A0
004818  370443     BRA 0x50A0
00481A  37017D     BRA 0x4B16
00481C  370180     BRA 0x4B1E
00481E  370183     BRA 0x4B26
004820  370186     BRA 0x4B2E
004822  370189     BRA 0x4B36
004824  37018C     BRA 0x4B3E
004826  37018F     BRA 0x4B46
004828  370192     BRA 0x4B4E
00482A  370195     BRA 0x4B56
00482C  370198     BRA 0x4B5E
00482E  37019B     BRA 0x4B66
004830  37019E     BRA 0x4B6E
004832  3701A1     BRA 0x4B76
004834  3701A4     BRA 0x4B7E
004836  3701A7     BRA 0x4B86
004838  3701AA     BRA 0x4B8E
00483A  3701AD     BRA 0x4B96
00483C  3701B0     BRA 0x4B9E
00483E  3701B3     BRA 0x4BA6
004840  3701B6     BRA 0x4BAE
004842  3701B9     BRA 0x4BB6
004844  3701BC     BRA 0x4BBE
004846  3701C2     BRA 0x4BCC
004848  3701C8     BRA 0x4BDA
00484A  3701CB     BRA 0x4BE2
00484C  3701CE     BRA 0x4BEA
00484E  3701D1     BRA 0x4BF2
004850  3701D4     BRA 0x4BFA
004852  370426     BRA 0x50A0
004854  370425     BRA 0x50A0
004856  3701D5     BRA 0x4C02
004858  3701D8     BRA 0x4C0A
00485A  3701DB     BRA 0x4C12
00485C  3701DE     BRA 0x4C1A
00485E  3701E1     BRA 0x4C22
004860  3701E4     BRA 0x4C2A
004862  3701E7     BRA 0x4C32
004864  3701EA     BRA 0x4C3A
004866  3701ED     BRA 0x4C42
004868  3701F0     BRA 0x4C4A
00486A  3701F3     BRA 0x4C52
00486C  3701F6     BRA 0x4C5A
00486E  3701F9     BRA 0x4C62
004870  3701FC     BRA 0x4C6A
004872  3701FF     BRA 0x4C72
004874  370202     BRA 0x4C7A
004876  370205     BRA 0x4C82
004878  370208     BRA 0x4C8A
00487A  37020B     BRA 0x4C92
00487C  37020E     BRA 0x4C9A
00487E  370211     BRA 0x4CA2
004880  370214     BRA 0x4CAA
004882  370217     BRA 0x4CB2
004884  37021A     BRA 0x4CBA
004886  37021D     BRA 0x4CC2
004888  37040B     BRA 0x50A0
00488A  37040A     BRA 0x50A0
00488C  370409     BRA 0x50A0
00488E  370408     BRA 0x50A0
004890  370407     BRA 0x50A0
004892  370406     BRA 0x50A0
004894  370405     BRA 0x50A0
004896  370404     BRA 0x50A0
004898  370218     BRA 0x4CCA
00489A  37021B     BRA 0x4CD2
00489C  37021E     BRA 0x4CDA
00489E  370221     BRA 0x4CE2
0048A0  370224     BRA 0x4CEA
0048A2  370227     BRA 0x4CF2
0048A4  37022A     BRA 0x4CFA
0048A6  37022D     BRA 0x4D02
0048A8  370230     BRA 0x4D0A
0048AA  3703FA     BRA 0x50A0
0048AC  3703F9     BRA 0x50A0
0048AE  3703F8     BRA 0x50A0
0048B0  3703F7     BRA 0x50A0
0048B2  3703F6     BRA 0x50A0
0048B4  3703F5     BRA 0x50A0
0048B6  3703F4     BRA 0x50A0
0048B8  37022C     BRA 0x4D12
0048BA  37022F     BRA 0x4D1A
0048BC  370232     BRA 0x4D22
0048BE  370235     BRA 0x4D2A
0048C0  370238     BRA 0x4D32
0048C2  37023B     BRA 0x4D3A
0048C4  37023E     BRA 0x4D42
0048C6  370241     BRA 0x4D4A
0048C8  3703EB     BRA 0x50A0
0048CA  3703EA     BRA 0x50A0
0048CC  3703E9     BRA 0x50A0
0048CE  3703E8     BRA 0x50A0
0048D0  3703E7     BRA 0x50A0
0048D2  3703E6     BRA 0x50A0
0048D4  3703E5     BRA 0x50A0
0048D6  3703E4     BRA 0x50A0
0048D8  3703E3     BRA 0x50A0
0048DA  3703E2     BRA 0x50A0
0048DC  3703E1     BRA 0x50A0
0048DE  3703E0     BRA 0x50A0
0048E0  3703DF     BRA 0x50A0
0048E2  3703DE     BRA 0x50A0
0048E4  3703DD     BRA 0x50A0
0048E6  3703DC     BRA 0x50A0
0048E8  3703DB     BRA 0x50A0
0048EA  3703DA     BRA 0x50A0
0048EC  3703D9     BRA 0x50A0
0048EE  3703D8     BRA 0x50A0
0048F0  3703D7     BRA 0x50A0
0048F2  3703D6     BRA 0x50A0
0048F4  3703D5     BRA 0x50A0
0048F6  3703D4     BRA 0x50A0
0048F8  3703D3     BRA 0x50A0
0048FA  3703D2     BRA 0x50A0
0048FC  3703D1     BRA 0x50A0
0048FE  3703D0     BRA 0x50A0
004900  3703CF     BRA 0x50A0
004902  3703CE     BRA 0x50A0
004904  3703CD     BRA 0x50A0
004906  3703CC     BRA 0x50A0
004908  3703CB     BRA 0x50A0
00490A  3703CA     BRA 0x50A0
00490C  3703C9     BRA 0x50A0
00490E  3703C8     BRA 0x50A0
004910  3703C7     BRA 0x50A0
004912  3703C6     BRA 0x50A0
004914  3703C5     BRA 0x50A0
004916  3703C4     BRA 0x50A0
004918  3703C3     BRA 0x50A0
00491A  3703C2     BRA 0x50A0
00491C  3703C1     BRA 0x50A0
00491E  3703C0     BRA 0x50A0
004920  3703BF     BRA 0x50A0
004922  3703BE     BRA 0x50A0
004924  3703BD     BRA 0x50A0
004926  3703BC     BRA 0x50A0
004928  3703BB     BRA 0x50A0
00492A  3703BA     BRA 0x50A0
00492C  3703B9     BRA 0x50A0
00492E  3703B8     BRA 0x50A0
004930  3703B7     BRA 0x50A0
004932  3703B6     BRA 0x50A0
004934  3703B5     BRA 0x50A0
004936  3703B4     BRA 0x50A0
004938  3703B3     BRA 0x50A0
00493A  3703B2     BRA 0x50A0
00493C  3703B1     BRA 0x50A0
00493E  3703B0     BRA 0x50A0
004940  3703AF     BRA 0x50A0
004942  3703AE     BRA 0x50A0
004944  3703AD     BRA 0x50A0
004946  3703AC     BRA 0x50A0
004948  3703AB     BRA 0x50A0
00494A  3703AA     BRA 0x50A0
00494C  3703A9     BRA 0x50A0
00494E  3703A8     BRA 0x50A0
004950  3703A7     BRA 0x50A0
004952  3703A6     BRA 0x50A0
004954  3703A5     BRA 0x50A0
004956  3703A4     BRA 0x50A0
004958  3703A3     BRA 0x50A0
00495A  3703A2     BRA 0x50A0
00495C  3703A1     BRA 0x50A0
00495E  3703A0     BRA 0x50A0
004960  37039F     BRA 0x50A0
004962  37039E     BRA 0x50A0
004964  37039D     BRA 0x50A0
004966  37039C     BRA 0x50A0
004968  37039B     BRA 0x50A0
00496A  37039A     BRA 0x50A0
00496C  370399     BRA 0x50A0
00496E  370398     BRA 0x50A0
004970  370397     BRA 0x50A0
004972  370396     BRA 0x50A0
004974  370395     BRA 0x50A0
004976  370394     BRA 0x50A0
004978  370393     BRA 0x50A0
00497A  370392     BRA 0x50A0
00497C  370391     BRA 0x50A0
00497E  370390     BRA 0x50A0
004980  37038F     BRA 0x50A0
004982  37038E     BRA 0x50A0
004984  37038D     BRA 0x50A0
004986  37038C     BRA 0x50A0
004988  37038B     BRA 0x50A0
00498A  37038A     BRA 0x50A0
00498C  370389     BRA 0x50A0
00498E  370388     BRA 0x50A0
004990  370387     BRA 0x50A0
004992  370386     BRA 0x50A0
004994  370385     BRA 0x50A0
004996  370384     BRA 0x50A0
004998  3701DC     BRA 0x4D52
00499A  3701DF     BRA 0x4D5A
00499C  3701E2     BRA 0x4D62
00499E  3701E5     BRA 0x4D6A
0049A0  3701E8     BRA 0x4D72
0049A2  3701EB     BRA 0x4D7A
0049A4  3701EE     BRA 0x4D82
0049A6  3701F1     BRA 0x4D8A
0049A8  3701F4     BRA 0x4D92
0049AA  3701F7     BRA 0x4D9A
0049AC  3701FA     BRA 0x4DA2
0049AE  3701FD     BRA 0x4DAA
0049B0  370377     BRA 0x50A0
0049B2  370376     BRA 0x50A0
0049B4  370375     BRA 0x50A0
0049B6  370374     BRA 0x50A0
0049B8  3701FC     BRA 0x4DB2
0049BA  3701FF     BRA 0x4DBA
0049BC  370202     BRA 0x4DC2
0049BE  370205     BRA 0x4DCA
0049C0  370208     BRA 0x4DD2
0049C2  37020B     BRA 0x4DDA
0049C4  37020E     BRA 0x4DE2
0049C6  370211     BRA 0x4DEA
0049C8  370214     BRA 0x4DF2
0049CA  370217     BRA 0x4DFA
0049CC  37021A     BRA 0x4E02
0049CE  37021D     BRA 0x4E0A
0049D0  370367     BRA 0x50A0
0049D2  370366     BRA 0x50A0
0049D4  370365     BRA 0x50A0
0049D6  370364     BRA 0x50A0
0049D8  37021C     BRA 0x4E12
0049DA  37021F     BRA 0x4E1A
0049DC  370222     BRA 0x4E22
0049DE  370225     BRA 0x4E2A
0049E0  370228     BRA 0x4E32
0049E2  37022B     BRA 0x4E3A
0049E4  37022E     BRA 0x4E42
0049E6  370231     BRA 0x4E4A
0049E8  370234     BRA 0x4E52
0049EA  370237     BRA 0x4E5A
0049EC  37023A     BRA 0x4E62
0049EE  37023D     BRA 0x4E6A
0049F0  370357     BRA 0x50A0
0049F2  370356     BRA 0x50A0
0049F4  370355     BRA 0x50A0
0049F6  370354     BRA 0x50A0
0049F8  37023C     BRA 0x4E72
0049FA  37023F     BRA 0x4E7A
0049FC  370242     BRA 0x4E82
0049FE  370245     BRA 0x4E8A
004A00  370248     BRA 0x4E92
004A02  37024B     BRA 0x4E9A
004A04  37024E     BRA 0x4EA2
004A06  370251     BRA 0x4EAA
004A08  370254     BRA 0x4EB2
004A0A  370257     BRA 0x4EBA
004A0C  37025A     BRA 0x4EC2
004A0E  37025D     BRA 0x4ECA
004A10  370347     BRA 0x50A0
004A12  370346     BRA 0x50A0
004A14  370345     BRA 0x50A0
004A16  370344     BRA 0x50A0
004A18  37025C     BRA 0x4ED2
004A1A  37025F     BRA 0x4EDA
004A1C  370262     BRA 0x4EE2
004A1E  370265     BRA 0x4EEA
004A20  370268     BRA 0x4EF2
004A22  37026B     BRA 0x4EFA
004A24  37026E     BRA 0x4F02
004A26  370271     BRA 0x4F0A
004A28  370274     BRA 0x4F12
004A2A  370277     BRA 0x4F1A
004A2C  37027A     BRA 0x4F22
004A2E  370338     BRA 0x50A0
004A30  370337     BRA 0x50A0
004A32  370336     BRA 0x50A0
004A34  370335     BRA 0x50A0
004A36  370334     BRA 0x50A0
004A38  370278     BRA 0x4F2A
004A3A  37027B     BRA 0x4F32
004A3C  37027E     BRA 0x4F3A
004A3E  370281     BRA 0x4F42
004A40  370284     BRA 0x4F4A
004A42  370287     BRA 0x4F52
004A44  37028A     BRA 0x4F5A
004A46  37028D     BRA 0x4F62
004A48  370290     BRA 0x4F6A
004A4A  370293     BRA 0x4F72
004A4C  370296     BRA 0x4F7A
004A4E  370328     BRA 0x50A0
004A50  370327     BRA 0x50A0
004A52  370326     BRA 0x50A0
004A54  370325     BRA 0x50A0
004A56  370324     BRA 0x50A0
004A58  370294     BRA 0x4F82
004A5A  370297     BRA 0x4F8A
004A5C  37029A     BRA 0x4F92
004A5E  37029D     BRA 0x4F9A
004A60  3702A0     BRA 0x4FA2
004A62  3702A3     BRA 0x4FAA
004A64  3702A6     BRA 0x4FB2
004A66  3702A9     BRA 0x4FBA
004A68  3702AC     BRA 0x4FC2
004A6A  3702AF     BRA 0x4FCA
004A6C  3702B2     BRA 0x4FD2
004A6E  370318     BRA 0x50A0
004A70  370317     BRA 0x50A0
004A72  370316     BRA 0x50A0
004A74  370315     BRA 0x50A0
004A76  370314     BRA 0x50A0
004A78  3702B0     BRA 0x4FDA
004A7A  3702B3     BRA 0x4FE2
004A7C  3702B6     BRA 0x4FEA
004A7E  3702B9     BRA 0x4FF2
004A80  3702BC     BRA 0x4FFA
004A82  3702BF     BRA 0x5002
004A84  3702C2     BRA 0x500A
004A86  3702C5     BRA 0x5012
004A88  3702C8     BRA 0x501A
004A8A  3702CB     BRA 0x5022
004A8C  3702CE     BRA 0x502A
534:               	{
535:               		case REG_SPLIT_DIGIT_OUTPUT:		// digital output
536:               			Me.Digi_Out = Value;
004A8E  90021E     MOV [W14+2], W4
004A90  784204     MOV.B W4, W4
004A92  784304     MOV.B W4, W6
004A94  20BA35     MOV #0xBA3, W5
004A96  784A86     MOV.B W6, [W5]
537:               			return 0;
004A98  EB4200     CLR.B W4
004A9A  370303     BRA 0x50A2
538:               
539:               		case REG_SPLIT_PWM_REQ_FAN_VALUE:	// gestione ventola
540:               			Me.Pwm_Req = Value;
004A9C  90021E     MOV [W14+2], W4
004A9E  885C74     MOV W4, 0xB8E
541:               			return 0;
004AA0  EB4200     CLR.B W4
004AA2  3702FF     BRA 0x50A2
542:               		case REG_SPLIT_PWM_ACT_FAN_VALUE:
543:               			Me.Pwm_Value = Value;
004AA4  90029E     MOV [W14+2], W5
004AA6  885C85     MOV W5, 0xB90
544:               			return 0;
004AA8  EB4200     CLR.B W4
004AAA  3702FB     BRA 0x50A2
545:               
546:               		case REG_SPLIT_VENTIL_MODE:			// gestione modalità
547:               			Me.Ventil_Mode = Value;
004AAC  90031E     MOV [W14+2], W6
004AAE  885C56     MOV W6, 0xB8A
548:               			return 0;
004AB0  EB4200     CLR.B W4
004AB2  3702F7     BRA 0x50A2
549:               		case REG_SPLIT_FUNCTION_MODE:
550:               			Me.Function_Mode = Value;
004AB4  90021E     MOV [W14+2], W4
004AB6  885C24     MOV W4, 0xB84
551:               			return 0;
004AB8  EB4200     CLR.B W4
004ABA  3702F3     BRA 0x50A2
552:               		case REG_SPLIT_CURRENT_SP:
553:               			Me.SP = Value;
004ABC  90029E     MOV [W14+2], W5
004ABE  885BC5     MOV W5, 0xB78
554:               			return 0;
004AC0  EB4200     CLR.B W4
004AC2  3702EF     BRA 0x50A2
555:               		case REG_SPLIT_CURRENT_EVAP_TEMP:
556:               			Me.Evap_Temp = Value;
004AC4  90031E     MOV [W14+2], W6
004AC6  885BF6     MOV W6, 0xB7E
557:               			return 0;
004AC8  EB4200     CLR.B W4
004ACA  3702EB     BRA 0x50A2
558:               
559:               		case REG_SPLIT_MASTER_STATUS:
560:               			Me.RoomMaster_Status = Value;
004ACC  90021E     MOV [W14+2], W4
004ACE  885CE4     MOV W4, 0xB9C
561:               			return 0;
004AD0  EB4200     CLR.B W4
004AD2  3702E7     BRA 0x50A2
562:               			
563:               		case REG_SPLIT_DEFINE_MODE:
564:               			if((Touch[0].FanMode == 0) && Me.NetPanelActive)			// Eccezione per gestire la mancanza del tasto ON/OFF sul Pannellino NetBuilding    0 = OFF
004AD4  805D94     MOV 0xBB2, W4
004AD6  520FE0     SUB W4, #0x0, [W15]
004AD8  3A0007     BRA NZ, 0x4AE8
004ADA  20BA54     MOV #0xBA5, W4
004ADC  784214     MOV.B [W4], W4
004ADE  524FE0     SUB.B W4, #0x0, [W15]
004AE0  320003     BRA Z, 0x4AE8
565:               				Me.DefMode = 0;
004AE2  EB0200     CLR W4
004AE4  885C34     MOV W4, 0xB86
004AE6  370006     BRA 0x4AF4
566:               			else if(My_Address != k_Split_Master_Add)
004AE8  20A914     MOV #0xA91, W4
004AEA  784214     MOV.B [W4], W4
004AEC  524FE1     SUB.B W4, #0x1, [W15]
004AEE  320002     BRA Z, 0x4AF4
567:               				Me.DefMode = Value;
004AF0  90021E     MOV [W14+2], W4
004AF2  885C34     MOV W4, 0xB86
568:               			return 0;
004AF4  EB4200     CLR.B W4
004AF6  3702D5     BRA 0x50A2
569:               
570:               		case REG_SPLIT_VALVOLA_SET_POS:		// gestione valvola
571:               			Me.ExpValve_Req = Value;
004AF8  90029E     MOV [W14+2], W5
004AFA  885CB5     MOV W5, 0xB96
572:               			return 0;
004AFC  EB4200     CLR.B W4
004AFE  3702D1     BRA 0x50A2
573:               		case REG_SPLIT_VALV_STP_REF_TIME:
574:               			StepRefreshTime = Value;
004B00  90021E     MOV [W14+2], W4
004B02  784204     MOV.B W4, W4
004B04  784284     MOV.B W4, W5
004B06  20AF26     MOV #0xAF2, W6
004B08  784B05     MOV.B W5, [W6]
575:               			return 0;
004B0A  EB4200     CLR.B W4
004B0C  3702CA     BRA 0x50A2
576:               		case REG_SPLIT_VALV_MAX_STEP:
577:               			ValvolaMaxStepNum = Value;
004B0E  90021E     MOV [W14+2], W4
004B10  8857A4     MOV W4, ValvolaMaxStepNum
578:               			return 0;
004B12  EB4200     CLR.B W4
004B14  3702C6     BRA 0x50A2
579:               /*		case REG_SPLIT_THR_MIN_AMP_VALV:
580:               			DigitalOutput = Value;
581:               			return 0;
582:               		case REG_SPLIT_THR_MAX_AMP_VALV:
583:               			DigitalOutput = Value;
584:               			return 0;
585:               */
586:               
587:               		case REG_SPLIT_ENGENIE_BOX_COMPRESSOR_SPEED:	// gestione info box motore
588:               			EngineBox.Compressor_Speed = Value;
004B16  90031E     MOV [W14+2], W6
004B18  885A06     MOV W6, 0xB40
589:               			return 0;
004B1A  EB4200     CLR.B W4
004B1C  3702C2     BRA 0x50A2
590:               		case REG_SPLIT_ENGENIE_BOX_WATER_PUMP_SPEED:
591:               			EngineBox.Pump_Speed = Value;
004B1E  90021E     MOV [W14+2], W4
004B20  885A14     MOV W4, 0xB42
592:               			return 0;
004B22  EB4200     CLR.B W4
004B24  3702BE     BRA 0x50A2
593:               		case REG_SPLIT_ENGENIE_BOX_FLUX:
594:               			EngineBox.Water_Flux = Value;
004B26  90029E     MOV [W14+2], W5
004B28  885A25     MOV W5, 0xB44
595:               			return 0;
004B2A  EB4200     CLR.B W4
004B2C  3702BA     BRA 0x50A2
596:               		case REG_SPLIT_CURRENT_MODE_ENGENIE_BOX:
597:               			EngineBox.FunctionMode = Value;
004B2E  90031E     MOV [W14+2], W6
004B30  885A56     MOV W6, 0xB4A
598:               			return 0;
004B32  EB4200     CLR.B W4
004B34  3702B6     BRA 0x50A2
599:               		case REG_SPLIT_CURRENT_REQ_PRESSURE:
600:               			EngineBox.Ric_Pressione = Value;
004B36  90021E     MOV [W14+2], W4
004B38  8859F4     MOV W4, 0xB3E
601:               			return 0;
004B3A  EB4200     CLR.B W4
004B3C  3702B2     BRA 0x50A2
602:               		case REG_SPLIT_ENGENIE_BOX_TEMP_MANDATA:
603:               			EngineBox.Temp_Mandata = Value;
004B3E  90021E     MOV [W14+2], W4
004B40  885944     MOV W4, EngineBox
604:               			return 0;
004B42  EB4200     CLR.B W4
004B44  3702AE     BRA 0x50A2
605:               		case REG_SPLIT_ENGENIE_BOX_TEMP_RITORNO:
606:               			EngineBox.Temp_Ritorno = Value;
004B46  90029E     MOV [W14+2], W5
004B48  885955     MOV W5, 0xB2A
607:               			return 0;
004B4A  EB4200     CLR.B W4
004B4C  3702AA     BRA 0x50A2
608:               		case REG_SPLIT_ENGENIE_BOX_TEMP_ACQUA_MARE:
609:               			EngineBox.Temp_Acqua_Mare = Value;
004B4E  90031E     MOV [W14+2], W6
004B50  885976     MOV W6, 0xB2E
610:               			return 0;
004B52  EB4200     CLR.B W4
004B54  3702A6     BRA 0x50A2
611:               		case REG_SPLIT_ENGENIE_BOX_TEMP_CONDENSATORE:
612:               			EngineBox.Temp_Condensatore = Value;
004B56  90021E     MOV [W14+2], W4
004B58  885964     MOV W4, 0xB2C
613:               			return 0;
004B5A  EB4200     CLR.B W4
004B5C  3702A2     BRA 0x50A2
614:               		case REG_SPLIT_ENGENIE_BOX_TEMP_BIG:
615:               			EngineBox.Temp_Collettore_Grande = Value;
004B5E  90029E     MOV [W14+2], W5
004B60  885985     MOV W5, 0xB30
616:               			return 0;
004B62  EB4200     CLR.B W4
004B64  37029E     BRA 0x50A2
617:               		case REG_SPLIT_ENGENIE_BOX_TEMP_SMALL:
618:               			EngineBox.Temp_Collettore_Piccolo = Value;
004B66  90031E     MOV [W14+2], W6
004B68  885996     MOV W6, 0xB32
619:               			return 0;
004B6A  EB4200     CLR.B W4
004B6C  37029A     BRA 0x50A2
620:               		case REG_SPLIT_ENGENIE_BOX_PRESSURE_BIG:
621:               			EngineBox.Pressione_Gas_G = Value;
004B6E  90021E     MOV [W14+2], W4
004B70  8859A4     MOV W4, 0xB34
622:               			return 0;
004B72  EB4200     CLR.B W4
004B74  370296     BRA 0x50A2
623:               		case REG_SPLIT_ENGENIE_BOX_PRESSURE_SMALL:
624:               			EngineBox.Pressione_Liq_P = Value;
004B76  90021E     MOV [W14+2], W4
004B78  8859B4     MOV W4, 0xB36
625:               			return 0;
004B7A  EB4200     CLR.B W4
004B7C  370292     BRA 0x50A2
626:               		case REG_SPLIT_ENGENIE_BOX_PRESSURE_VRV_BOX:
627:               			EngineBox.Pressione_VRV_Box = Value;
004B7E  90021E     MOV [W14+2], W4
004B80  8859C4     MOV W4, 0xB38
628:               			return 0;
004B82  EB4200     CLR.B W4
004B84  37028E     BRA 0x50A2
629:               		case REG_SPLIT_ENGENIE_BOX_PRESSURE_AUX:
630:               			EngineBox.Pressione_Aux = Value;
004B86  90021E     MOV [W14+2], W4
004B88  8859D4     MOV W4, 0xB3A
631:               			return 0;
004B8A  EB4200     CLR.B W4
004B8C  37028A     BRA 0x50A2
632:               		case REG_SPLIT_ENGENIE_BOX_RELE_SATUS:
633:               			EngineBox.ReleSt = Value;
004B8E  90021E     MOV [W14+2], W4
004B90  885AE4     MOV W4, 0xB5C
634:               			return 0;
004B92  EB4200     CLR.B W4
004B94  370286     BRA 0x50A2
635:               		case REG_SPLIT_ENGENIE_BOX_INPUT_STATUS:
636:               			EngineBox.InputSt = Value;
004B96  90021E     MOV [W14+2], W4
004B98  885AC4     MOV W4, 0xB58
637:               			return 0;
004B9A  EB4200     CLR.B W4
004B9C  370282     BRA 0x50A2
638:               		case REG_SPLIT_ENGENIE_BOX_SYS_ID_LO:
639:               			EngineBox.SysNumLo = Value;
004B9E  90021E     MOV [W14+2], W4
004BA0  885B24     MOV W4, 0xB64
640:               			return 0;
004BA2  EB4200     CLR.B W4
004BA4  37027E     BRA 0x50A2
641:               		case REG_SPLIT_ENGENIE_BOX_SYS_ID_HI:
642:               			EngineBox.SysNumHi = Value;
004BA6  90021E     MOV [W14+2], W4
004BA8  885B34     MOV W4, 0xB66
643:               			return 0;
004BAA  EB4200     CLR.B W4
004BAC  37027A     BRA 0x50A2
644:               		case REG_SPLIT_ERRORE_1_BOX_MOTORE:
645:               			EngineBox.Errori1 = Value;
004BAE  90021E     MOV [W14+2], W4
004BB0  885AF4     MOV W4, 0xB5E
646:               			return 0;
004BB2  EB4200     CLR.B W4
004BB4  370276     BRA 0x50A2
647:               		case REG_SPLIT_ERRORE_2_BOX_MOTORE:
648:               			EngineBox.Errori2 = Value;
004BB6  90021E     MOV [W14+2], W4
004BB8  885B04     MOV W4, 0xB60
649:               			return 0;
004BBA  EB4200     CLR.B W4
004BBC  370272     BRA 0x50A2
650:               		case REG_SPLIT_STATUS_BOX_MOTORE:
651:               			EngineBox.StatoCompressore = Value;
004BBE  90021E     MOV [W14+2], W4
004BC0  784204     MOV.B W4, W4
004BC2  784304     MOV.B W4, W6
004BC4  20B4C5     MOV #0xB4C, W5
004BC6  784A86     MOV.B W6, [W5]
652:               			return 0;
004BC8  EB4200     CLR.B W4
004BCA  37026B     BRA 0x50A2
653:               		case REG_SPLIT_ID_SPLIT_MASTER:
654:               			EngineBox.IdMasterSplit = Value;
004BCC  90021E     MOV [W14+2], W4
004BCE  784204     MOV.B W4, W4
004BD0  784304     MOV.B W4, W6
004BD2  20B4D5     MOV #0xB4D, W5
004BD4  784A86     MOV.B W6, [W5]
655:               			return 0;
004BD6  EB4200     CLR.B W4
004BD8  370264     BRA 0x50A2
656:               		case REG_SPLIT_POWER_LIMIT:
657:               			EngineBox.PowerLimit = Value;
004BDA  90021E     MOV [W14+2], W4
004BDC  885A34     MOV W4, 0xB46
658:               			return 0;
004BDE  EB4200     CLR.B W4
004BE0  370260     BRA 0x50A2
659:               		case REG_SPLIT_POWER_LIMIT_REQ:
660:               			Me.PowerLimit = Value;
004BE2  90029E     MOV [W14+2], W5
004BE4  885BD5     MOV W5, 0xB7A
661:               			return 0;
004BE6  EB4200     CLR.B W4
004BE8  37025C     BRA 0x50A2
662:               		case REG_SPLIT_STATUS:
663:               			Me.SplitStatus = Value;
004BEA  90021E     MOV [W14+2], W4
004BEC  885CF4     MOV W4, 0xB9E
664:               			return 0;
004BEE  EB4200     CLR.B W4
004BF0  370258     BRA 0x50A2
665:               		case REG_SPLIT_ENGINE_BOX_CYCLE_TIME:
666:               			EngineBox.SystemCycleTime = Value;
004BF2  90021E     MOV [W14+2], W4
004BF4  885B44     MOV W4, 0xB68
667:               			return 0;
004BF6  EB4200     CLR.B W4
004BF8  370254     BRA 0x50A2
668:               		case REG_SPLIT_ENGINE_BOX_HOURS_OF_LIFE:
669:               			EngineBox.HoursOfLife = Value;
004BFA  90021E     MOV [W14+2], W4
004BFC  885B54     MOV W4, 0xB6A
670:               			return 0;
004BFE  EB4200     CLR.B W4
004C00  370250     BRA 0x50A2
671:               
672:               		case REG_DIAG_SPLIT_RES_REQ_ADDRESS:		
673:               			DiagnosticSplit.Reset_Req_Address = Value;	// indirizzo dello slave su cui effettuare il reset allarmi proveniente dallo slave master
004C02  90031E     MOV [W14+2], W6
004C04  887216     MOV W6, 0xE42
674:               			return 0;			
004C06  EB4200     CLR.B W4
004C08  37024C     BRA 0x50A2
675:               		case REG_DIAG_SPLIT_TEST_ADDRESS:		// #v16
676:               			DiagnosticSplit.Address = Value;	// Indirizzo slave da monitorare
004C0A  90021E     MOV [W14+2], W4
004C0C  887144     MOV W4, DiagnosticSplit
677:               			return 0;
004C0E  EB4200     CLR.B W4
004C10  370248     BRA 0x50A2
678:               		case REG_DIAG_SPLIT_STATUS:					
679:               			DiagnosticSplit.SplitStatus = Value;	
004C12  90029E     MOV [W14+2], W5
004C14  887155     MOV W5, 0xE2A
680:               			return 0;	
004C16  EB4200     CLR.B W4
004C18  370244     BRA 0x50A2
681:               		case REG_DIAG_SPLIT_LIQ_TEMP:					
682:               			DiagnosticSplit.Temp_Liq = Value;	
004C1A  90031E     MOV [W14+2], W6
004C1C  887176     MOV W6, 0xE2E
683:               			return 0;
004C1E  EB4200     CLR.B W4
004C20  370240     BRA 0x50A2
684:               		case REG_DIAG_SPLIT_GAS_TEMP:					
685:               			DiagnosticSplit.Temp_Gas = Value;	
004C22  90021E     MOV [W14+2], W4
004C24  887164     MOV W4, 0xE2C
686:               			return 0;
004C26  EB4200     CLR.B W4
004C28  37023C     BRA 0x50A2
687:               		case REG_DIAG_SPLIT_AIR_IN:					
688:               			DiagnosticSplit.Temp_AirIn = Value;	
004C2A  90029E     MOV [W14+2], W5
004C2C  887195     MOV W5, 0xE32
689:               			return 0;
004C2E  EB4200     CLR.B W4
004C30  370238     BRA 0x50A2
690:               		case REG_DIAG_SPLIT_AIR_OUT:					
691:               			DiagnosticSplit.Temp_AirOut = Value;	
004C32  90031E     MOV [W14+2], W6
004C34  887186     MOV W6, 0xE30
692:               			return 0;
004C36  EB4200     CLR.B W4
004C38  370234     BRA 0x50A2
693:               		case REG_DIAG_SPLIT_FAN_SPEED:					
694:               			DiagnosticSplit.FanSpeed = Value;
004C3A  90021E     MOV [W14+2], W4
004C3C  8871A4     MOV W4, 0xE34
695:               			return 0;	
004C3E  EB4200     CLR.B W4
004C40  370230     BRA 0x50A2
696:               		case REG_DIAG_SPLIT_EXP_VALVE:					
697:               			DiagnosticSplit.Exp_Valve = Value;	
004C42  90029E     MOV [W14+2], W5
004C44  8871B5     MOV W5, 0xE36
698:               			return 0;
004C46  EB4200     CLR.B W4
004C48  37022C     BRA 0x50A2
699:               		case REG_DIAG_SPLIT_GAS_PRESSURE:					
700:               			DiagnosticSplit.Gas_Pressure = Value;	
004C4A  90031E     MOV [W14+2], W6
004C4C  8871C6     MOV W6, 0xE38
701:               			return 0;
004C4E  EB4200     CLR.B W4
004C50  370228     BRA 0x50A2
702:               		case REG_DIAG_SPLIT_LIQ_PRESSURE:					
703:               			DiagnosticSplit.Liq_Pressure = Value;	
004C52  90021E     MOV [W14+2], W4
004C54  8871D4     MOV W4, 0xE3A
704:               			return 0;
004C56  EB4200     CLR.B W4
004C58  370224     BRA 0x50A2
705:               		case REG_DIAG_SPLIT_REQUEST_AIR_TEMP:					
706:               			DiagnosticSplit.Req_AirTemp = Value;	
004C5A  90029E     MOV [W14+2], W5
004C5C  8871E5     MOV W5, 0xE3C
707:               			return 0;
004C5E  EB4200     CLR.B W4
004C60  370220     BRA 0x50A2
708:               		case REG_DIAG_SPLIT_REQUEST_AIR_PRES:					
709:               			DiagnosticSplit.Req_Pressure = Value;	
004C62  90031E     MOV [W14+2], W6
004C64  8871F6     MOV W6, 0xE3E
710:               			return 0;
004C66  EB4200     CLR.B W4
004C68  37021C     BRA 0x50A2
711:               		case REG_DIAG_SPLIT_ENG_MODE:					
712:               			DiagnosticSplit.Split_Eng_Mode = Value;
004C6A  90021E     MOV [W14+2], W4
004C6C  887204     MOV W4, 0xE40
713:               			return 0;
004C6E  EB4200     CLR.B W4
004C70  370218     BRA 0x50A2
714:               		case REG_DIAG_SPLIT_CYCLE_TIME:					
715:               			DiagnosticSplit.CycleTime = Value;
004C72  90021E     MOV [W14+2], W4
004C74  887224     MOV W4, 0xE44
716:               			return 0;
004C76  EB4200     CLR.B W4
004C78  370214     BRA 0x50A2
717:               
718:               		case REG_DIAG_INVERTER_ALARM:	
719:               			DiagnosticInverter.Alarm = Value;
004C7A  90021E     MOV [W14+2], W4
004C7C  887244     MOV W4, DiagnosticInverter
720:               			return 0;		
004C7E  EB4200     CLR.B W4
004C80  370210     BRA 0x50A2
721:               		case REG_DIAG_INVERTER_OUT_FREQ:
722:               			DiagnosticInverter.OutFreq = Value;				
004C82  90021E     MOV [W14+2], W4
004C84  887254     MOV W4, 0xE4A
723:               			return 0;
004C86  EB4200     CLR.B W4
004C88  37020C     BRA 0x50A2
724:               		case REG_DIAG_INVERTER_STATUS:		
725:               			DiagnosticInverter.Status = Value;		 
004C8A  90021E     MOV [W14+2], W4
004C8C  887264     MOV W4, 0xE4C
726:               			return 0;
004C8E  EB4200     CLR.B W4
004C90  370208     BRA 0x50A2
727:               		case REG_DIAG_INVERTER_OUT_CURRENT:	
728:               			DiagnosticInverter.OutCurr = Value;	
004C92  90021E     MOV [W14+2], W4
004C94  887274     MOV W4, 0xE4E
729:               			return 0;
004C96  EB4200     CLR.B W4
004C98  370204     BRA 0x50A2
730:               		case REG_DIAG_INVERTER_IN_VOLTAGE:	
731:               			DiagnosticInverter.InVolt = Value;	
004C9A  90021E     MOV [W14+2], W4
004C9C  887284     MOV W4, 0xE50
732:               			return 0;
004C9E  EB4200     CLR.B W4
004CA0  370200     BRA 0x50A2
733:               		case REG_DIAG_INVERTER_OUT_VOLTAGE:	
734:               			DiagnosticInverter.OutVolt = Value;	
004CA2  90021E     MOV [W14+2], W4
004CA4  887294     MOV W4, 0xE52
735:               			return 0;
004CA6  EB4200     CLR.B W4
004CA8  3701FC     BRA 0x50A2
736:               		case REG_DIAG_INVERTER_IN_POWER:	
737:               			DiagnosticInverter.InPower = Value;	
004CAA  90021E     MOV [W14+2], W4
004CAC  8872A4     MOV W4, 0xE54
738:               			return 0;
004CAE  EB4200     CLR.B W4
004CB0  3701F8     BRA 0x50A2
739:               		case REG_DIAG_INVERTER_OUT_POWER:	
740:               			DiagnosticInverter.OutPower = Value;	
004CB2  90021E     MOV [W14+2], W4
004CB4  8872B4     MOV W4, 0xE56
741:               			return 0;
004CB6  EB4200     CLR.B W4
004CB8  3701F4     BRA 0x50A2
742:               		case REG_DIAG_INVERTER_REQ_FREQ:	
743:               			DiagnosticInverter.ReqFreq = Value;	
004CBA  90021E     MOV [W14+2], W4
004CBC  8872C4     MOV W4, 0xE58
744:               			return 0;
004CBE  EB4200     CLR.B W4
004CC0  3701F0     BRA 0x50A2
745:               		case REG_DIAG_INVERTER_MAX_REQ_FREQ:	
746:               			DiagnosticInverter.MaxReqFreq = Value;	
004CC2  90021E     MOV [W14+2], W4
004CC4  8872D4     MOV W4, 0xE5A
747:               			return 0;
004CC6  EB4200     CLR.B W4
004CC8  3701EC     BRA 0x50A2
748:               
749:               		case REG_SPLIT_PWM_VALUE_OFF:			// gestione valori pwm velocità predefinite
750:               			PWMValue[0] = Value;
004CCA  90029E     MOV [W14+2], W5
004CCC  8855C5     MOV W5, PWMValue
751:               			return 0;
004CCE  EB4200     CLR.B W4
004CD0  3701E8     BRA 0x50A2
752:               		case REG_SPLIT_PWM_VALUE_NIGHT:
753:               			PWMValue[1] = Value;
004CD2  90031E     MOV [W14+2], W6
004CD4  8855D6     MOV W6, 0xABA
754:               			return 0;
004CD6  EB4200     CLR.B W4
004CD8  3701E4     BRA 0x50A2
755:               		case REG_SPLIT_PWM_VALUE_SPEED1:
756:               			PWMValue[2] = Value;
004CDA  90021E     MOV [W14+2], W4
004CDC  8855E4     MOV W4, 0xABC
757:               			return 0;
004CDE  EB4200     CLR.B W4
004CE0  3701E0     BRA 0x50A2
758:               		case REG_SPLIT_PWM_VALUE_SPEED2:
759:               			PWMValue[3] = Value;
004CE2  90029E     MOV [W14+2], W5
004CE4  8855F5     MOV W5, 0xABE
760:               			return 0;
004CE6  EB4200     CLR.B W4
004CE8  3701DC     BRA 0x50A2
761:               		case REG_SPLIT_PWM_VALUE_SPEED3:
762:               			PWMValue[4] = Value;
004CEA  90031E     MOV [W14+2], W6
004CEC  885606     MOV W6, 0xAC0
763:               			return 0;
004CEE  EB4200     CLR.B W4
004CF0  3701D8     BRA 0x50A2
764:               		case REG_SPLIT_PWM_VALUE_SPEED4:
765:               			PWMValue[5] = Value;
004CF2  90021E     MOV [W14+2], W4
004CF4  885614     MOV W4, 0xAC2
766:               			return 0;
004CF6  EB4200     CLR.B W4
004CF8  3701D4     BRA 0x50A2
767:               		case REG_SPLIT_PWM_VALUE_SPEED5:
768:               			PWMValue[6] = Value;
004CFA  90029E     MOV [W14+2], W5
004CFC  885625     MOV W5, 0xAC4
769:               			return 0;
004CFE  EB4200     CLR.B W4
004D00  3701D0     BRA 0x50A2
770:               		case REG_SPLIT_PWM_VALUE_SPEED6:
771:               			PWMValue[7] = Value;
004D02  90031E     MOV [W14+2], W6
004D04  885636     MOV W6, 0xAC6
772:               			return 0;
004D06  EB4200     CLR.B W4
004D08  3701CC     BRA 0x50A2
773:               		case REG_SPLIT_PWM_VALUE_SPEED7:
774:               			PWMValue[8] = Value;
004D0A  90021E     MOV [W14+2], W4
004D0C  885644     MOV W4, 0xAC8
775:               			return 0;
004D0E  EB4200     CLR.B W4
004D10  3701C8     BRA 0x50A2
776:               
777:               		case REG_SPLIT_TEMP_LIMIT_NIGHT:		// gestione limiti temperatura per velocità automatiche
778:               			TempLimitSpeed[0] = Value;
004D12  90029E     MOV [W14+2], W5
004D14  885655     MOV W5, TempLimitSpeed
779:               			return 0;
004D16  EB4200     CLR.B W4
004D18  3701C4     BRA 0x50A2
780:               		case REG_SPLIT_TEMP_LIMIT_SPEED1:
781:               			TempLimitSpeed[1] = Value;
004D1A  90031E     MOV [W14+2], W6
004D1C  885666     MOV W6, 0xACC
782:               			return 0;
004D1E  EB4200     CLR.B W4
004D20  3701C0     BRA 0x50A2
783:               		case REG_SPLIT_TEMP_LIMIT_SPEED2:
784:               			TempLimitSpeed[2] = Value;
004D22  90021E     MOV [W14+2], W4
004D24  885674     MOV W4, 0xACE
785:               			return 0;
004D26  EB4200     CLR.B W4
004D28  3701BC     BRA 0x50A2
786:               		case REG_SPLIT_TEMP_LIMIT_SPEED3:
787:               			TempLimitSpeed[3] = Value;
004D2A  90029E     MOV [W14+2], W5
004D2C  885685     MOV W5, 0xAD0
788:               			return 0;
004D2E  EB4200     CLR.B W4
004D30  3701B8     BRA 0x50A2
789:               		case REG_SPLIT_TEMP_LIMIT_SPEED4:
790:               			TempLimitSpeed[4] = Value;
004D32  90031E     MOV [W14+2], W6
004D34  885696     MOV W6, 0xAD2
791:               			return 0;
004D36  EB4200     CLR.B W4
004D38  3701B4     BRA 0x50A2
792:               		case REG_SPLIT_TEMP_LIMIT_SPEED5:
793:               			TempLimitSpeed[5] = Value;
004D3A  90021E     MOV [W14+2], W4
004D3C  8856A4     MOV W4, 0xAD4
794:               			return 0;
004D3E  EB4200     CLR.B W4
004D40  3701B0     BRA 0x50A2
795:               		case REG_SPLIT_TEMP_LIMIT_SPEED6:
796:               			TempLimitSpeed[6] = Value;
004D42  90029E     MOV [W14+2], W5
004D44  8856B5     MOV W5, 0xAD6
797:               			return 0;
004D46  EB4200     CLR.B W4
004D48  3701AC     BRA 0x50A2
798:               		case REG_SPLIT_TEMP_LIMIT_SPEED7:
799:               			TempLimitSpeed[7] = Value;
004D4A  90031E     MOV [W14+2], W6
004D4C  8856C6     MOV W6, 0xAD8
800:               			return 0;
004D4E  EB4200     CLR.B W4
004D50  3701A8     BRA 0x50A2
801:               
802:               		case REG_SPLIT_AD_T1_0:					// valori AD notevoli per calibrazione temp bulbo grande
803:               			AD_T_Grande[0] = Value;
004D52  90021E     MOV [W14+2], W4
004D54  884484     MOV W4, AD_T_Grande
804:               			return 0;
004D56  EB4200     CLR.B W4
004D58  3701A4     BRA 0x50A2
805:               		case REG_SPLIT_AD_T1_1:
806:               			AD_T_Grande[1] = Value;
004D5A  90029E     MOV [W14+2], W5
004D5C  884495     MOV W5, 0x892
807:               			return 0;
004D5E  EB4200     CLR.B W4
004D60  3701A0     BRA 0x50A2
808:               		case REG_SPLIT_AD_T1_2:
809:               			AD_T_Grande[2] = Value;
004D62  90031E     MOV [W14+2], W6
004D64  8844A6     MOV W6, 0x894
810:               			return 0;
004D66  EB4200     CLR.B W4
004D68  37019C     BRA 0x50A2
811:               		case REG_SPLIT_AD_T1_3:
812:               			AD_T_Grande[3] = Value;
004D6A  90021E     MOV [W14+2], W4
004D6C  8844B4     MOV W4, 0x896
813:               			return 0;
004D6E  EB4200     CLR.B W4
004D70  370198     BRA 0x50A2
814:               		case REG_SPLIT_AD_T1_4:
815:               			AD_T_Grande[4] = Value;
004D72  90029E     MOV [W14+2], W5
004D74  8844C5     MOV W5, 0x898
816:               			return 0;
004D76  EB4200     CLR.B W4
004D78  370194     BRA 0x50A2
817:               		case REG_SPLIT_AD_T1_5:
818:               			AD_T_Grande[5] = Value;
004D7A  90031E     MOV [W14+2], W6
004D7C  8844D6     MOV W6, 0x89A
819:               			return 0;
004D7E  EB4200     CLR.B W4
004D80  370190     BRA 0x50A2
820:               		case REG_SPLIT_AD_T1_6:
821:               			AD_T_Grande[6] = Value;
004D82  90021E     MOV [W14+2], W4
004D84  8844E4     MOV W4, 0x89C
822:               			return 0;
004D86  EB4200     CLR.B W4
004D88  37018C     BRA 0x50A2
823:               		case REG_SPLIT_AD_T1_7:
824:               			AD_T_Grande[7] = Value;
004D8A  90029E     MOV [W14+2], W5
004D8C  8844F5     MOV W5, 0x89E
825:               			return 0;
004D8E  EB4200     CLR.B W4
004D90  370188     BRA 0x50A2
826:               		case REG_SPLIT_AD_T1_8:
827:               			AD_T_Grande[8] = Value;
004D92  90031E     MOV [W14+2], W6
004D94  884506     MOV W6, 0x8A0
828:               			return 0;
004D96  EB4200     CLR.B W4
004D98  370184     BRA 0x50A2
829:               		case REG_SPLIT_AD_T1_9:
830:               			AD_T_Grande[9] = Value;
004D9A  90021E     MOV [W14+2], W4
004D9C  884514     MOV W4, 0x8A2
831:               			return 0;
004D9E  EB4200     CLR.B W4
004DA0  370180     BRA 0x50A2
832:               		case REG_SPLIT_AD_T1_10:
833:               			AD_T_Grande[10] = Value;
004DA2  90029E     MOV [W14+2], W5
004DA4  884525     MOV W5, 0x8A4
834:               			return 0;
004DA6  EB4200     CLR.B W4
004DA8  37017C     BRA 0x50A2
835:               		case REG_SPLIT_AD_T1_11:
836:               			AD_T_Grande[11] = Value;
004DAA  90031E     MOV [W14+2], W6
004DAC  884536     MOV W6, 0x8A6
837:               			return 0;
004DAE  EB4200     CLR.B W4
004DB0  370178     BRA 0x50A2
838:               
839:               		case REG_SPLIT_AD_T2_0:				// gestione valori AD notevoli per calibrazione temp bulbo piccolo
840:               			AD_T_Piccolo[0] = Value;
004DB2  90021E     MOV [W14+2], W4
004DB4  8843C4     MOV W4, AD_T_Piccolo
841:               			return 0;
004DB6  EB4200     CLR.B W4
004DB8  370174     BRA 0x50A2
842:               		case REG_SPLIT_AD_T2_1:
843:               			AD_T_Piccolo[1] = Value;
004DBA  90029E     MOV [W14+2], W5
004DBC  8843D5     MOV W5, 0x87A
844:               			return 0;
004DBE  EB4200     CLR.B W4
004DC0  370170     BRA 0x50A2
845:               		case REG_SPLIT_AD_T2_2:
846:               			AD_T_Piccolo[2] = Value;
004DC2  90031E     MOV [W14+2], W6
004DC4  8843E6     MOV W6, 0x87C
847:               			return 0;
004DC6  EB4200     CLR.B W4
004DC8  37016C     BRA 0x50A2
848:               		case REG_SPLIT_AD_T2_3:
849:               			AD_T_Piccolo[3] = Value;
004DCA  90021E     MOV [W14+2], W4
004DCC  8843F4     MOV W4, 0x87E
850:               			return 0;
004DCE  EB4200     CLR.B W4
004DD0  370168     BRA 0x50A2
851:               		case REG_SPLIT_AD_T2_4:
852:               			AD_T_Piccolo[4] = Value;
004DD2  90029E     MOV [W14+2], W5
004DD4  884405     MOV W5, 0x880
853:               			return 0;
004DD6  EB4200     CLR.B W4
004DD8  370164     BRA 0x50A2
854:               		case REG_SPLIT_AD_T2_5:
855:               			AD_T_Piccolo[5] = Value;
004DDA  90031E     MOV [W14+2], W6
004DDC  884416     MOV W6, 0x882
856:               			return 0;
004DDE  EB4200     CLR.B W4
004DE0  370160     BRA 0x50A2
857:               		case REG_SPLIT_AD_T2_6:
858:               			AD_T_Piccolo[6] = Value;
004DE2  90021E     MOV [W14+2], W4
004DE4  884424     MOV W4, 0x884
859:               			return 0;
004DE6  EB4200     CLR.B W4
004DE8  37015C     BRA 0x50A2
860:               		case REG_SPLIT_AD_T2_7:
861:               			AD_T_Piccolo[7] = Value;
004DEA  90029E     MOV [W14+2], W5
004DEC  884435     MOV W5, 0x886
862:               			return 0;
004DEE  EB4200     CLR.B W4
004DF0  370158     BRA 0x50A2
863:               		case REG_SPLIT_AD_T2_8:
864:               			AD_T_Piccolo[8] = Value;
004DF2  90031E     MOV [W14+2], W6
004DF4  884446     MOV W6, 0x888
865:               			return 0;
004DF6  EB4200     CLR.B W4
004DF8  370154     BRA 0x50A2
866:               		case REG_SPLIT_AD_T2_9:
867:               			AD_T_Piccolo[9] = Value;
004DFA  90021E     MOV [W14+2], W4
004DFC  884454     MOV W4, 0x88A
868:               			return 0;
004DFE  EB4200     CLR.B W4
004E00  370150     BRA 0x50A2
869:               		case REG_SPLIT_AD_T2_10:
870:               			AD_T_Piccolo[10] = Value;
004E02  90029E     MOV [W14+2], W5
004E04  884465     MOV W5, 0x88C
871:               			return 0;
004E06  EB4200     CLR.B W4
004E08  37014C     BRA 0x50A2
872:               		case REG_SPLIT_AD_T2_11:
873:               			AD_T_Piccolo[11] = Value;
004E0A  90031E     MOV [W14+2], W6
004E0C  884476     MOV W6, 0x88E
874:               			return 0;
004E0E  EB4200     CLR.B W4
004E10  370148     BRA 0x50A2
875:               
876:               		case REG_SPLIT_AD_T3_0:					// valori AD notevoli per calibrazione temp aria uscita
877:               			AD_T_Out[0] = Value;
004E12  90021E     MOV [W14+2], W4
004E14  884544     MOV W4, AD_T_Out
878:               			return 0;
004E16  EB4200     CLR.B W4
004E18  370144     BRA 0x50A2
879:               		case REG_SPLIT_AD_T3_1:
880:               			AD_T_Out[1] = Value;
004E1A  90029E     MOV [W14+2], W5
004E1C  884555     MOV W5, 0x8AA
881:               			return 0;
004E1E  EB4200     CLR.B W4
004E20  370140     BRA 0x50A2
882:               		case REG_SPLIT_AD_T3_2:
883:               			AD_T_Out[2] = Value;
004E22  90031E     MOV [W14+2], W6
004E24  884566     MOV W6, 0x8AC
884:               			return 0;
004E26  EB4200     CLR.B W4
004E28  37013C     BRA 0x50A2
885:               		case REG_SPLIT_AD_T3_3:
886:               			AD_T_Out[3] = Value;
004E2A  90021E     MOV [W14+2], W4
004E2C  884574     MOV W4, 0x8AE
887:               			return 0;
004E2E  EB4200     CLR.B W4
004E30  370138     BRA 0x50A2
888:               		case REG_SPLIT_AD_T3_4:
889:               			AD_T_Out[4] = Value;
004E32  90029E     MOV [W14+2], W5
004E34  884585     MOV W5, 0x8B0
890:               			return 0;
004E36  EB4200     CLR.B W4
004E38  370134     BRA 0x50A2
891:               		case REG_SPLIT_AD_T3_5:
892:               			AD_T_Out[5] = Value;
004E3A  90031E     MOV [W14+2], W6
004E3C  884596     MOV W6, 0x8B2
893:               			return 0;
004E3E  EB4200     CLR.B W4
004E40  370130     BRA 0x50A2
894:               		case REG_SPLIT_AD_T3_6:
895:               			AD_T_Out[6] = Value;
004E42  90021E     MOV [W14+2], W4
004E44  8845A4     MOV W4, 0x8B4
896:               			return 0;
004E46  EB4200     CLR.B W4
004E48  37012C     BRA 0x50A2
897:               		case REG_SPLIT_AD_T3_7:
898:               			AD_T_Out[7] = Value;
004E4A  90029E     MOV [W14+2], W5
004E4C  8845B5     MOV W5, 0x8B6
899:               			return 0;
004E4E  EB4200     CLR.B W4
004E50  370128     BRA 0x50A2
900:               		case REG_SPLIT_AD_T3_8:
901:               			AD_T_Out[8] = Value;
004E52  90031E     MOV [W14+2], W6
004E54  8845C6     MOV W6, 0x8B8
902:               			return 0;
004E56  EB4200     CLR.B W4
004E58  370124     BRA 0x50A2
903:               		case REG_SPLIT_AD_T3_9:
904:               			AD_T_Out[9] = Value;
004E5A  90021E     MOV [W14+2], W4
004E5C  8845D4     MOV W4, 0x8BA
905:               			return 0;
004E5E  EB4200     CLR.B W4
004E60  370120     BRA 0x50A2
906:               		case REG_SPLIT_AD_T3_10:
907:               			AD_T_Out[10] = Value;
004E62  90029E     MOV [W14+2], W5
004E64  8845E5     MOV W5, 0x8BC
908:               			return 0;
004E66  EB4200     CLR.B W4
004E68  37011C     BRA 0x50A2
909:               		case REG_SPLIT_AD_T3_11:
910:               			AD_T_Out[11] = Value;
004E6A  90031E     MOV [W14+2], W6
004E6C  8845F6     MOV W6, 0x8BE
911:               			return 0;
004E6E  EB4200     CLR.B W4
004E70  370118     BRA 0x50A2
912:               
913:               		case REG_SPLIT_AD_T4_0:				// valori AD notevoli per calibrazione temp aria ambiente
914:               			AD_T_Amb[0] = Value;
004E72  90021E     MOV [W14+2], W4
004E74  884604     MOV W4, AD_T_Amb
915:               			return 0;
004E76  EB4200     CLR.B W4
004E78  370114     BRA 0x50A2
916:               		case REG_SPLIT_AD_T4_1:
917:               			AD_T_Amb[1] = Value;
004E7A  90029E     MOV [W14+2], W5
004E7C  884615     MOV W5, 0x8C2
918:               			return 0;
004E7E  EB4200     CLR.B W4
004E80  370110     BRA 0x50A2
919:               		case REG_SPLIT_AD_T4_2:
920:               			AD_T_Amb[2] = Value;
004E82  90031E     MOV [W14+2], W6
004E84  884626     MOV W6, 0x8C4
921:               			return 0;
004E86  EB4200     CLR.B W4
004E88  37010C     BRA 0x50A2
922:               		case REG_SPLIT_AD_T4_3:
923:               			AD_T_Amb[3] = Value;
004E8A  90021E     MOV [W14+2], W4
004E8C  884634     MOV W4, 0x8C6
924:               			return 0;
004E8E  EB4200     CLR.B W4
004E90  370108     BRA 0x50A2
925:               		case REG_SPLIT_AD_T4_4:
926:               			AD_T_Amb[4] = Value;
004E92  90029E     MOV [W14+2], W5
004E94  884645     MOV W5, 0x8C8
927:               			return 0;
004E96  EB4200     CLR.B W4
004E98  370104     BRA 0x50A2
928:               		case REG_SPLIT_AD_T4_5:
929:               			AD_T_Amb[5] = Value;
004E9A  90031E     MOV [W14+2], W6
004E9C  884656     MOV W6, 0x8CA
930:               			return 0;
004E9E  EB4200     CLR.B W4
004EA0  370100     BRA 0x50A2
931:               		case REG_SPLIT_AD_T4_6:
932:               			AD_T_Amb[6] = Value;
004EA2  90021E     MOV [W14+2], W4
004EA4  884664     MOV W4, 0x8CC
933:               			return 0;
004EA6  EB4200     CLR.B W4
004EA8  3700FC     BRA 0x50A2
934:               		case REG_SPLIT_AD_T4_7:
935:               			AD_T_Amb[7] = Value;
004EAA  90029E     MOV [W14+2], W5
004EAC  884675     MOV W5, 0x8CE
936:               			return 0;
004EAE  EB4200     CLR.B W4
004EB0  3700F8     BRA 0x50A2
937:               		case REG_SPLIT_AD_T4_8:
938:               			AD_T_Amb[8] = Value;
004EB2  90031E     MOV [W14+2], W6
004EB4  884686     MOV W6, 0x8D0
939:               			return 0;
004EB6  EB4200     CLR.B W4
004EB8  3700F4     BRA 0x50A2
940:               		case REG_SPLIT_AD_T4_9:
941:               			AD_T_Amb[9] = Value;
004EBA  90021E     MOV [W14+2], W4
004EBC  884694     MOV W4, 0x8D2
942:               			return 0;
004EBE  EB4200     CLR.B W4
004EC0  3700F0     BRA 0x50A2
943:               		case REG_SPLIT_AD_T4_10:
944:               			AD_T_Amb[10] = Value;
004EC2  90029E     MOV [W14+2], W5
004EC4  8846A5     MOV W5, 0x8D4
945:               			return 0;
004EC6  EB4200     CLR.B W4
004EC8  3700EC     BRA 0x50A2
946:               		case REG_SPLIT_AD_T4_11:
947:               			AD_T_Amb[11] = Value;
004ECA  90031E     MOV [W14+2], W6
004ECC  8846B6     MOV W6, 0x8D6
948:               			return 0;
004ECE  EB4200     CLR.B W4
004ED0  3700E8     BRA 0x50A2
949:               
950:               		case REG_SPLIT_KT_T1_0:					// fattore di crescita per calibrazione temp bulbo grande
951:               			Kt_T_Grande[0] = Value;
004ED2  90021E     MOV [W14+2], W4
004ED4  884774     MOV W4, Kt_T_Grande
952:               			return 0;
004ED6  EB4200     CLR.B W4
004ED8  3700E4     BRA 0x50A2
953:               		case REG_SPLIT_KT_T1_1:
954:               			Kt_T_Grande[1] = Value;
004EDA  90029E     MOV [W14+2], W5
004EDC  884785     MOV W5, 0x8F0
955:               			return 0;
004EDE  EB4200     CLR.B W4
004EE0  3700E0     BRA 0x50A2
956:               		case REG_SPLIT_KT_T1_2:
957:               			Kt_T_Grande[2] = Value;
004EE2  90031E     MOV [W14+2], W6
004EE4  884796     MOV W6, 0x8F2
958:               			return 0;
004EE6  EB4200     CLR.B W4
004EE8  3700DC     BRA 0x50A2
959:               		case REG_SPLIT_KT_T1_3:
960:               			Kt_T_Grande[3] = Value;
004EEA  90021E     MOV [W14+2], W4
004EEC  8847A4     MOV W4, 0x8F4
961:               			return 0;
004EEE  EB4200     CLR.B W4
004EF0  3700D8     BRA 0x50A2
962:               		case REG_SPLIT_KT_T1_4:
963:               			Kt_T_Grande[4] = Value;
004EF2  90029E     MOV [W14+2], W5
004EF4  8847B5     MOV W5, 0x8F6
964:               			return 0;
004EF6  EB4200     CLR.B W4
004EF8  3700D4     BRA 0x50A2
965:               		case REG_SPLIT_KT_T1_5:
966:               			Kt_T_Grande[5] = Value;
004EFA  90031E     MOV [W14+2], W6
004EFC  8847C6     MOV W6, 0x8F8
967:               			return 0;
004EFE  EB4200     CLR.B W4
004F00  3700D0     BRA 0x50A2
968:               		case REG_SPLIT_KT_T1_6:
969:               			Kt_T_Grande[6] = Value;
004F02  90021E     MOV [W14+2], W4
004F04  8847D4     MOV W4, 0x8FA
970:               			return 0;
004F06  EB4200     CLR.B W4
004F08  3700CC     BRA 0x50A2
971:               		case REG_SPLIT_KT_T1_7:
972:               			Kt_T_Grande[7] = Value;
004F0A  90029E     MOV [W14+2], W5
004F0C  8847E5     MOV W5, 0x8FC
973:               			return 0;
004F0E  EB4200     CLR.B W4
004F10  3700C8     BRA 0x50A2
974:               		case REG_SPLIT_KT_T1_8:
975:               			Kt_T_Grande[8] = Value;
004F12  90031E     MOV [W14+2], W6
004F14  8847F6     MOV W6, 0x8FE
976:               			return 0;
004F16  EB4200     CLR.B W4
004F18  3700C4     BRA 0x50A2
977:               		case REG_SPLIT_KT_T1_9:
978:               			Kt_T_Grande[9] = Value;
004F1A  90021E     MOV [W14+2], W4
004F1C  884804     MOV W4, 0x900
979:               			return 0;
004F1E  EB4200     CLR.B W4
004F20  3700C0     BRA 0x50A2
980:               		case REG_SPLIT_KT_T1_10:
981:               			Kt_T_Grande[10] = Value;
004F22  90029E     MOV [W14+2], W5
004F24  884815     MOV W5, 0x902
982:               			return 0;
004F26  EB4200     CLR.B W4
004F28  3700BC     BRA 0x50A2
983:               
984:               
985:               		case REG_SPLIT_KT_T2_0:					// fattore di crescita per calibrazione temp bulbo piccolo
986:               			Kt_T_Piccolo[0] = Value;
004F2A  90031E     MOV [W14+2], W6
004F2C  8846C6     MOV W6, Kt_T_Piccolo
987:               			return 0;
004F2E  EB4200     CLR.B W4
004F30  3700B8     BRA 0x50A2
988:               		case REG_SPLIT_KT_T2_1:
989:               			Kt_T_Piccolo[1] = Value;
004F32  90021E     MOV [W14+2], W4
004F34  8846D4     MOV W4, 0x8DA
990:               			return 0;
004F36  EB4200     CLR.B W4
004F38  3700B4     BRA 0x50A2
991:               		case REG_SPLIT_KT_T2_2:
992:               			Kt_T_Piccolo[2] = Value;
004F3A  90029E     MOV [W14+2], W5
004F3C  8846E5     MOV W5, 0x8DC
993:               			return 0;
004F3E  EB4200     CLR.B W4
004F40  3700B0     BRA 0x50A2
994:               		case REG_SPLIT_KT_T2_3:
995:               			Kt_T_Piccolo[3] = Value;
004F42  90031E     MOV [W14+2], W6
004F44  8846F6     MOV W6, 0x8DE
996:               			return 0;
004F46  EB4200     CLR.B W4
004F48  3700AC     BRA 0x50A2
997:               		case REG_SPLIT_KT_T2_4:
998:               			Kt_T_Piccolo[4] = Value;
004F4A  90021E     MOV [W14+2], W4
004F4C  884704     MOV W4, 0x8E0
999:               			return 0;
004F4E  EB4200     CLR.B W4
004F50  3700A8     BRA 0x50A2
1000:              		case REG_SPLIT_KT_T2_5:
1001:              			Kt_T_Piccolo[5] = Value;
004F52  90029E     MOV [W14+2], W5
004F54  884715     MOV W5, 0x8E2
1002:              			return 0;
004F56  EB4200     CLR.B W4
004F58  3700A4     BRA 0x50A2
1003:              		case REG_SPLIT_KT_T2_6:
1004:              			Kt_T_Piccolo[6] = Value;
004F5A  90031E     MOV [W14+2], W6
004F5C  884726     MOV W6, 0x8E4
1005:              			return 0;
004F5E  EB4200     CLR.B W4
004F60  3700A0     BRA 0x50A2
1006:              		case REG_SPLIT_KT_T2_7:
1007:              			Kt_T_Piccolo[7] = Value;
004F62  90021E     MOV [W14+2], W4
004F64  884734     MOV W4, 0x8E6
1008:              			return 0;
004F66  EB4200     CLR.B W4
004F68  37009C     BRA 0x50A2
1009:              		case REG_SPLIT_KT_T2_8:
1010:              			Kt_T_Piccolo[8] = Value;
004F6A  90029E     MOV [W14+2], W5
004F6C  884745     MOV W5, 0x8E8
1011:              			return 0;
004F6E  EB4200     CLR.B W4
004F70  370098     BRA 0x50A2
1012:              		case REG_SPLIT_KT_T2_9:
1013:              			Kt_T_Piccolo[9] = Value;
004F72  90031E     MOV [W14+2], W6
004F74  884756     MOV W6, 0x8EA
1014:              			return 0;
004F76  EB4200     CLR.B W4
004F78  370094     BRA 0x50A2
1015:              		case REG_SPLIT_KT_T2_10:
1016:              			Kt_T_Piccolo[10] = Value;
004F7A  90021E     MOV [W14+2], W4
004F7C  884764     MOV W4, 0x8EC
1017:              			return 0;
004F7E  EB4200     CLR.B W4
004F80  370090     BRA 0x50A2
1018:              
1019:              		case REG_SPLIT_KT_T3_0:					// fattore di crescita per calibrazione temp aria uscita
1020:              			Kt_T_Out[0] = Value;
004F82  90029E     MOV [W14+2], W5
004F84  884825     MOV W5, Kt_T_Out
1021:              			return 0;
004F86  EB4200     CLR.B W4
004F88  37008C     BRA 0x50A2
1022:              		case REG_SPLIT_KT_T3_1:
1023:              			Kt_T_Out[1] = Value;
004F8A  90031E     MOV [W14+2], W6
004F8C  884836     MOV W6, 0x906
1024:              			return 0;
004F8E  EB4200     CLR.B W4
004F90  370088     BRA 0x50A2
1025:              		case REG_SPLIT_KT_T3_2:
1026:              			Kt_T_Out[2] = Value;
004F92  90021E     MOV [W14+2], W4
004F94  884844     MOV W4, 0x908
1027:              			return 0;
004F96  EB4200     CLR.B W4
004F98  370084     BRA 0x50A2
1028:              		case REG_SPLIT_KT_T3_3:
1029:              			Kt_T_Out[3] = Value;
004F9A  90029E     MOV [W14+2], W5
004F9C  884855     MOV W5, 0x90A
1030:              			return 0;
004F9E  EB4200     CLR.B W4
004FA0  370080     BRA 0x50A2
1031:              		case REG_SPLIT_KT_T3_4:
1032:              			Kt_T_Out[4] = Value;
004FA2  90031E     MOV [W14+2], W6
004FA4  884866     MOV W6, 0x90C
1033:              			return 0;
004FA6  EB4200     CLR.B W4
004FA8  37007C     BRA 0x50A2
1034:              		case REG_SPLIT_KT_T3_5:
1035:              			Kt_T_Out[5] = Value;
004FAA  90021E     MOV [W14+2], W4
004FAC  884874     MOV W4, 0x90E
1036:              			return 0;
004FAE  EB4200     CLR.B W4
004FB0  370078     BRA 0x50A2
1037:              		case REG_SPLIT_KT_T3_6:
1038:              			Kt_T_Out[6] = Value;
004FB2  90029E     MOV [W14+2], W5
004FB4  884885     MOV W5, 0x910
1039:              			return 0;
004FB6  EB4200     CLR.B W4
004FB8  370074     BRA 0x50A2
1040:              		case REG_SPLIT_KT_T3_7:
1041:              			Kt_T_Out[7] = Value;
004FBA  90031E     MOV [W14+2], W6
004FBC  884896     MOV W6, 0x912
1042:              			return 0;
004FBE  EB4200     CLR.B W4
004FC0  370070     BRA 0x50A2
1043:              		case REG_SPLIT_KT_T3_8:
1044:              			Kt_T_Out[8] = Value;
004FC2  90021E     MOV [W14+2], W4
004FC4  8848A4     MOV W4, 0x914
1045:              			return 0;
004FC6  EB4200     CLR.B W4
004FC8  37006C     BRA 0x50A2
1046:              		case REG_SPLIT_KT_T3_9:
1047:              			Kt_T_Out[9] = Value;
004FCA  90029E     MOV [W14+2], W5
004FCC  8848B5     MOV W5, 0x916
1048:              			return 0;
004FCE  EB4200     CLR.B W4
004FD0  370068     BRA 0x50A2
1049:              		case REG_SPLIT_KT_T3_10:
1050:              			Kt_T_Out[10] = Value;
004FD2  90031E     MOV [W14+2], W6
004FD4  8848C6     MOV W6, 0x918
1051:              			return 0;
004FD6  EB4200     CLR.B W4
004FD8  370064     BRA 0x50A2
1052:              
1053:              		case REG_SPLIT_KT_T4_0:					// fattore di crescita per calibrazione temp ambiente
1054:              			Kt_T_Amb[0] = Value;
004FDA  90021E     MOV [W14+2], W4
004FDC  8848D4     MOV W4, Kt_T_Amb
1055:              			return 0;
004FDE  EB4200     CLR.B W4
004FE0  370060     BRA 0x50A2
1056:              		case REG_SPLIT_KT_T4_1:
1057:              			Kt_T_Amb[1] = Value;
004FE2  90029E     MOV [W14+2], W5
004FE4  8848E5     MOV W5, 0x91C
1058:              			return 0;
004FE6  EB4200     CLR.B W4
004FE8  37005C     BRA 0x50A2
1059:              		case REG_SPLIT_KT_T4_2:
1060:              			Kt_T_Amb[2] = Value;
004FEA  90031E     MOV [W14+2], W6
004FEC  8848F6     MOV W6, 0x91E
1061:              			return 0;
004FEE  EB4200     CLR.B W4
004FF0  370058     BRA 0x50A2
1062:              		case REG_SPLIT_KT_T4_3:
1063:              			Kt_T_Amb[3] = Value;
004FF2  90021E     MOV [W14+2], W4
004FF4  884904     MOV W4, 0x920
1064:              			return 0;
004FF6  EB4200     CLR.B W4
004FF8  370054     BRA 0x50A2
1065:              		case REG_SPLIT_KT_T4_4:
1066:              			Kt_T_Amb[4] = Value;
004FFA  90029E     MOV [W14+2], W5
004FFC  884915     MOV W5, 0x922
1067:              			return 0;
004FFE  EB4200     CLR.B W4
005000  370050     BRA 0x50A2
1068:              		case REG_SPLIT_KT_T4_5:
1069:              			Kt_T_Amb[5] = Value;
005002  90031E     MOV [W14+2], W6
005004  884926     MOV W6, 0x924
1070:              			return 0;
005006  EB4200     CLR.B W4
005008  37004C     BRA 0x50A2
1071:              		case REG_SPLIT_KT_T4_6:
1072:              			Kt_T_Amb[6] = Value;
00500A  90021E     MOV [W14+2], W4
00500C  884934     MOV W4, 0x926
1073:              			return 0;
00500E  EB4200     CLR.B W4
005010  370048     BRA 0x50A2
1074:              		case REG_SPLIT_KT_T4_7:
1075:              			Kt_T_Amb[7] = Value;
005012  90029E     MOV [W14+2], W5
005014  884945     MOV W5, 0x928
1076:              			return 0;
005016  EB4200     CLR.B W4
005018  370044     BRA 0x50A2
1077:              		case REG_SPLIT_KT_T4_8:
1078:              			Kt_T_Amb[8] = Value;
00501A  90031E     MOV [W14+2], W6
00501C  884956     MOV W6, 0x92A
1079:              			return 0;
00501E  EB4200     CLR.B W4
005020  370040     BRA 0x50A2
1080:              		case REG_SPLIT_KT_T4_9:
1081:              			Kt_T_Amb[9] = Value;
005022  90021E     MOV [W14+2], W4
005024  884964     MOV W4, 0x92C
1082:              			return 0;
005026  EB4200     CLR.B W4
005028  37003C     BRA 0x50A2
1083:              		case REG_SPLIT_KT_T4_10:
1084:              			Kt_T_Amb[10] = Value;
00502A  90029E     MOV [W14+2], W5
00502C  884975     MOV W5, 0x92E
1085:              			return 0;
00502E  EB4200     CLR.B W4
005030  370038     BRA 0x50A2
1086:              
1087:              		case REG_SPLIT_ADD_MODULO:					// info generali
1088:              			My_Address = Value;
005032  90021E     MOV [W14+2], W4
005034  784204     MOV.B W4, W4
005036  784284     MOV.B W4, W5
005038  20A916     MOV #0xA91, W6
00503A  784B05     MOV.B W5, [W6]
1089:              			return 0;
00503C  EB4200     CLR.B W4
00503E  370031     BRA 0x50A2
1090:              		case REG_SPLIT_SYSTEM_NUMBER_LO:
1091:              			SN1 = LoByte(Value);
005040  90001E     MOV [W14+2], W0
005042  070C7B     RCALL LoByte
005044  784200     MOV.B W0, W4
005046  784284     MOV.B W4, W5
005048  20AAA6     MOV #0xAAA, W6
00504A  784B05     MOV.B W5, [W6]
1092:              			SN2 = HiByte(Value);
00504C  90001E     MOV [W14+2], W0
00504E  070C6D     RCALL HiByte
005050  784200     MOV.B W0, W4
005052  784284     MOV.B W4, W5
005054  20AAB6     MOV #0xAAB, W6
005056  784B05     MOV.B W5, [W6]
1093:              			return 0;
005058  EB4200     CLR.B W4
00505A  370023     BRA 0x50A2
1094:              		case REG_SPLIT_SYSTEM_NUMBER_HI:
1095:              			SN3 = LoByte(Value);
00505C  90001E     MOV [W14+2], W0
00505E  070C6D     RCALL LoByte
005060  784200     MOV.B W0, W4
005062  784284     MOV.B W4, W5
005064  20AAC6     MOV #0xAAC, W6
005066  784B05     MOV.B W5, [W6]
1096:              			SN4 = HiByte(Value);
005068  90001E     MOV [W14+2], W0
00506A  070C5F     RCALL HiByte
00506C  784200     MOV.B W0, W4
00506E  784284     MOV.B W4, W5
005070  20AAD6     MOV #0xAAD, W6
005072  784B05     MOV.B W5, [W6]
1097:              			return 0;
005074  EB4200     CLR.B W4
005076  370015     BRA 0x50A2
1098:              		case REG_SPLIT_FABRICATION_DAY:
1099:              			GiornoFabbricazione = Value;
005078  90031E     MOV [W14+2], W6
00507A  885576     MOV W6, GiornoFabbricazione
1100:              			return 0;
00507C  EB4200     CLR.B W4
00507E  370011     BRA 0x50A2
1101:              		case REG_SPLIT_FABRICATION_MONTH:
1102:              			MeseFabbricazione = Value;
005080  90021E     MOV [W14+2], W4
005082  885584     MOV W4, MeseFabbricazione
1103:              			return 0;
005084  EB4200     CLR.B W4
005086  37000D     BRA 0x50A2
1104:              		case REG_SPLIT_FABRICATION_YEAR:
1105:              			AnnoFabbricazione = Value;
005088  90029E     MOV [W14+2], W5
00508A  885595     MOV W5, AnnoFabbricazione
1106:              			return 0;
00508C  EB4200     CLR.B W4
00508E  370009     BRA 0x50A2
1107:              		case REG_SPLIT_CRC_16:
1108:              			CRC_Flash = Value;
005090  90031E     MOV [W14+2], W6
005092  885546     MOV W6, CRC_Flash
1109:              			return 0;
005094  EB4200     CLR.B W4
005096  370005     BRA 0x50A2
1110:              		case REG_SPLIT_SAVE_2_E2:
1111:              			WriteE2Status = Value;
005098  90021E     MOV [W14+2], W4
00509A  885534     MOV W4, WriteE2Status
1112:              			return 0;
00509C  EB4200     CLR.B W4
00509E  370001     BRA 0x50A2
1113:              
1114:              		default:
1115:              			return 1;
0050A0  B3C014     MOV.B #0x1, W4
1116:              	}
1117:              }
0050A2  784004     MOV.B W4, W0
0050A4  FA8000     ULNK
0050A6  060000     RETURN
1118:              
---  D:/WORK3/Lavori/TERMODINAMICA/Work/FW/1 - Generico/Split/Split v.8.4.22 - Working/PWM.c  -----------
1:                 //----------------------------------------------------------------------------------
2:                 //	Progect name:	Triac.c
3:                 //	Device:			PIC18F4550 @ 20Mhz (PLL 96 Mhz)
4:                 //	Autor:			Emanuele
5:                 //	Date:			22/05/2011
6:                 //	Description:	Corpo delle funzioni per il modulo di gestione del triac
7:                 //----------------------------------------------------------------------------------
8:                 
9:                 //----------------------------------------------------------------------------------
10:                //	Include
11:                //----------------------------------------------------------------------------------
12:                #include "MicroModelSelection.h"
13:                #ifdef GB210
14:                	#include <p24FJ256GB210.h>
15:                #else
16:                	#include <p24FJ256GB110.h>
17:                #endif
18:                #include <stdio.h>
19:                #include "DefinePeriferiche.h"
20:                #include "PWM.h"
21:                #include "Timer.h"
22:                #include "Core.h"
23:                #include "PID.h"
24:                
25:                //----------------------------------------------------------------------------------
26:                //	Funzioni
27:                //----------------------------------------------------------------------------------
28:                // Inizializza i valori delle velocità ventialtore da costanti anziche da EEPROM
29:                void Init_PWM_Value(void)
30:                {
0050A8  FA0000     LNK #0x0
31:                	PWMValue[0] = K_FanSpeedOff;
0050AA  EB0200     CLR W4
0050AC  8855C4     MOV W4, PWMValue
32:                	PWMValue[1] = K_FanSpeedNight;
0050AE  2002D4     MOV #0x2D, W4
0050B0  8855D4     MOV W4, 0xABA
33:                	PWMValue[2] = K_FanSpeed1; 
0050B2  200374     MOV #0x37, W4
0050B4  8855E4     MOV W4, 0xABC
34:                	PWMValue[3] = K_FanSpeed2; 
0050B6  200464     MOV #0x46, W4
0050B8  8855F4     MOV W4, 0xABE
35:                	PWMValue[4] = K_FanSpeed3; 
0050BA  200554     MOV #0x55, W4
0050BC  885604     MOV W4, 0xAC0
36:                	PWMValue[5] = K_FanSpeed4; 
0050BE  2006E4     MOV #0x6E, W4
0050C0  885614     MOV W4, 0xAC2
37:                	PWMValue[6] = K_FanSpeed5; 
0050C2  2008C4     MOV #0x8C, W4
0050C4  885624     MOV W4, 0xAC4
38:                	PWMValue[7] = K_FanSpeed6; 
0050C6  200BE4     MOV #0xBE, W4
0050C8  885634     MOV W4, 0xAC6
39:                	PWMValue[8] = K_FanSpeed7;	
0050CA  200FF4     MOV #0xFF, W4
0050CC  885644     MOV W4, 0xAC8
40:                }
0050CE  FA8000     ULNK
0050D0  060000     RETURN
41:                
42:                
43:                //---------------------------------------------------------------------------
44:                // Calcola il valore della velocità della ventola (in valore PWM) rispetto al
45:                // delta temperatura dell'aria in Ingresso e uscita della batteria
46:                //---------------------------------------------------------------------------
47:                // NEW
48:                int DeltaTempInOut(void)
49:                {
0050D2  FA0006     LNK #0x6
0050D4  BE9F88     MOV.D W8, [W15++]
50:                    int ErrTemp;
51:                    int RetVal; 
52:                    int MaxTemp=1000;
0050D6  203E84     MOV #0x3E8, W4
0050D8  980724     MOV W4, [W14+4]
53:                    
54:                    if(Me.Function_Mode == CoreRaffrescamento || Me.Function_Mode == CoreSlaveFreddo)
0050DA  805C24     MOV 0xB84, W4
0050DC  520FE8     SUB W4, #0x8, [W15]
0050DE  320003     BRA Z, 0x50E6
0050E0  805C24     MOV 0xB84, W4
0050E2  520FF2     SUB W4, #0x12, [W15]
0050E4  3A0004     BRA NZ, 0x50EE
55:                    {
56:                        ErrTemp = Me.Temp_Amb - Me.Temp_AirOut;
0050E6  805B65     MOV Me, W5
0050E8  805B74     MOV 0xB6E, W4
0050EA  528F04     SUB W5, W4, [W14]
0050EC  37000F     BRA 0x510C
57:                    }
58:                    else if(Me.Function_Mode == CoreRiscaldamento || Me.Function_Mode == CoreSlaveCaldo)  
0050EE  805C24     MOV 0xB84, W4
0050F0  520FE4     SUB W4, #0x4, [W15]
0050F2  320003     BRA Z, 0x50FA
0050F4  805C24     MOV 0xB84, W4
0050F6  520FF1     SUB W4, #0x11, [W15]
0050F8  3A0004     BRA NZ, 0x5102
59:                    {
60:                        ErrTemp = Me.Temp_AirOut - Me.Temp_Amb;
0050FA  805B75     MOV 0xB6E, W5
0050FC  805B64     MOV Me, W4
0050FE  528F04     SUB W5, W4, [W14]
005100  370005     BRA 0x510C
61:                    }
62:                    else if(Me.Function_Mode == CoreVentilazione)
005102  805C24     MOV 0xB84, W4
005104  520FF0     SUB W4, #0x10, [W15]
005106  3A0002     BRA NZ, 0x510C
63:                    {
64:                		//ErrTemp = Me.Temp_Amb - Me.Temp_AirOut;
65:                		ErrTemp = MaxTemp; //Da decidere cosa deve essere!!
005108  90022E     MOV [W14+4], W4
00510A  780F04     MOV W4, [W14]
66:                    }
67:                   
68:                    if(ErrTemp < 0) ErrTemp=0; 
00510C  78021E     MOV [W14], W4
00510E  520FE0     SUB W4, #0x0, [W15]
005110  3D0002     BRA GE, 0x5116
005112  EB0200     CLR W4
005114  780F04     MOV W4, [W14]
69:                    if(ErrTemp > MaxTemp)  ErrTemp=MaxTemp; 
005116  90022E     MOV [W14+4], W4
005118  78029E     MOV [W14], W5
00511A  528F84     SUB W5, W4, [W15]
00511C  340002     BRA LE, 0x5122
00511E  90022E     MOV [W14+4], W4
005120  780F04     MOV W4, [W14]
70:                    
71:                    RetVal = (int)((float)ErrTemp / ((float)MaxTemp/255.0));	// Range 0..255
005122  78021E     MOV [W14], W4
005124  DEA2CF     ASR W4, #15, W5
005126  BE0004     MOV.D W4, W0
005128  07D9CA     RCALL ___floatsisf
00512A  BE0400     MOV.D W0, W8
00512C  90022E     MOV [W14+4], W4
00512E  DEA2CF     ASR W4, #15, W5
005130  BE0004     MOV.D W4, W0
005132  07D9C5     RCALL ___floatsisf
005134  BE0200     MOV.D W0, W4
005136  200002     MOV #0x0, W2
005138  2437F3     MOV #0x437F, W3
00513A  BE0004     MOV.D W4, W0
00513C  07D93E     RCALL ___divsf3
00513E  BE0200     MOV.D W0, W4
005140  BE0104     MOV.D W4, W2
005142  BE0008     MOV.D W8, W0
005144  07D93A     RCALL ___divsf3
005146  BE0200     MOV.D W0, W4
005148  BE0004     MOV.D W4, W0
00514A  07D97D     RCALL ___fixsfsi
00514C  BE0200     MOV.D W0, W4
00514E  980714     MOV W4, [W14+2]
72:                    
73:                    if(RetVal < PWMValue[1]) RetVal = PWMValue[1];
005150  8055D5     MOV 0xABA, W5
005152  90021E     MOV [W14+2], W4
005154  528F84     SUB W5, W4, [W15]
005156  340002     BRA LE, 0x515C
005158  8055D4     MOV 0xABA, W4
00515A  980714     MOV W4, [W14+2]
74:                			
75:                    return RetVal;
00515C  90021E     MOV [W14+2], W4
76:                }
00515E  780004     MOV W4, W0
005160  BE044F     MOV.D [--W15], W8
005162  FA8000     ULNK
005164  060000     RETURN
77:                
78:                
79:                //---------------------------------------------------------------------------
80:                // Calcola il valore della velocità della ventola (in valore PWM) rispetto al
81:                // delta temperatura dell'aria in uscita dalla batteria e quella richiesta di evaporazione
82:                //---------------------------------------------------------------------------
83:                // NEW
84:                int DeltaTempReqOut(void)
85:                {
005166  FA0008     LNK #0x8
005168  BE9F88     MOV.D W8, [W15++]
86:                    int ErrTemp;
87:                    int RetVal; 
88:                    int MaxTemp=1500;
00516A  205DC4     MOV #0x5DC, W4
00516C  980724     MOV W4, [W14+4]
89:                    int TempOffs=500;
00516E  201F44     MOV #0x1F4, W4
005170  980734     MOV W4, [W14+6]
90:                    
91:                    if(Me.Function_Mode == CoreRaffrescamento || Me.Function_Mode == CoreSlaveFreddo)
005172  805C24     MOV 0xB84, W4
005174  520FE8     SUB W4, #0x8, [W15]
005176  320003     BRA Z, 0x517E
005178  805C24     MOV 0xB84, W4
00517A  520FF2     SUB W4, #0x12, [W15]
00517C  3A0006     BRA NZ, 0x518A
92:                    {
93:                        ErrTemp = Me.Temp_AirOut - (Me.Evap_Temp + TempOffs);
00517E  805B75     MOV 0xB6E, W5
005180  805BF6     MOV 0xB7E, W6
005182  90023E     MOV [W14+6], W4
005184  430204     ADD W6, W4, W4
005186  528F04     SUB W5, W4, [W14]
005188  370011     BRA 0x51AC
94:                    }
95:                    else if(Me.Function_Mode == CoreRiscaldamento || Me.Function_Mode == CoreSlaveCaldo)  
00518A  805C24     MOV 0xB84, W4
00518C  520FE4     SUB W4, #0x4, [W15]
00518E  320003     BRA Z, 0x5196
005190  805C24     MOV 0xB84, W4
005192  520FF1     SUB W4, #0x11, [W15]
005194  3A0006     BRA NZ, 0x51A2
96:                    {
97:                        ErrTemp = (Me.Evap_Temp + TempOffs) - Me.Temp_AirOut;
005196  805BF5     MOV 0xB7E, W5
005198  90023E     MOV [W14+6], W4
00519A  428284     ADD W5, W4, W5
00519C  805B74     MOV 0xB6E, W4
00519E  528F04     SUB W5, W4, [W14]
0051A0  370005     BRA 0x51AC
98:                    }
99:                    else if(Me.Function_Mode == CoreVentilazione)
0051A2  805C24     MOV 0xB84, W4
0051A4  520FF0     SUB W4, #0x10, [W15]
0051A6  3A0002     BRA NZ, 0x51AC
100:                   {
101:               		//ErrTemp = Me.Temp_AirOut - (Me.Evap_Temp + TempOffs);
102:               		ErrTemp = 0; //Da decidere cosa deve essere!!
0051A8  EB0200     CLR W4
0051AA  780F04     MOV W4, [W14]
103:                   }
104:                  
105:                   if(ErrTemp < 0) ErrTemp=0; 
0051AC  78021E     MOV [W14], W4
0051AE  520FE0     SUB W4, #0x0, [W15]
0051B0  3D0002     BRA GE, 0x51B6
0051B2  EB0200     CLR W4
0051B4  780F04     MOV W4, [W14]
106:                   if(ErrTemp > MaxTemp)  ErrTemp=MaxTemp; 
0051B6  90022E     MOV [W14+4], W4
0051B8  78029E     MOV [W14], W5
0051BA  528F84     SUB W5, W4, [W15]
0051BC  340002     BRA LE, 0x51C2
0051BE  90022E     MOV [W14+4], W4
0051C0  780F04     MOV W4, [W14]
107:                   
108:                   RetVal = 255 - (int)((float)ErrTemp / ((float)MaxTemp/255.0));
0051C2  78021E     MOV [W14], W4
0051C4  DEA2CF     ASR W4, #15, W5
0051C6  BE0004     MOV.D W4, W0
0051C8  07D97A     RCALL ___floatsisf
0051CA  BE0400     MOV.D W0, W8
0051CC  90022E     MOV [W14+4], W4
0051CE  DEA2CF     ASR W4, #15, W5
0051D0  BE0004     MOV.D W4, W0
0051D2  07D975     RCALL ___floatsisf
0051D4  BE0200     MOV.D W0, W4
0051D6  200002     MOV #0x0, W2
0051D8  2437F3     MOV #0x437F, W3
0051DA  BE0004     MOV.D W4, W0
0051DC  07D8EE     RCALL ___divsf3
0051DE  BE0200     MOV.D W0, W4
0051E0  BE0104     MOV.D W4, W2
0051E2  BE0008     MOV.D W8, W0
0051E4  07D8EA     RCALL ___divsf3
0051E6  BE0200     MOV.D W0, W4
0051E8  BE0004     MOV.D W4, W0
0051EA  07D92D     RCALL ___fixsfsi
0051EC  BE0200     MOV.D W0, W4
0051EE  780204     MOV W4, W4
0051F0  200FF5     MOV #0xFF, W5
0051F2  528204     SUB W5, W4, W4
0051F4  980714     MOV W4, [W14+2]
109:                   
110:                   if(RetVal < PWMValue[1]) RetVal = PWMValue[1];
0051F6  8055D5     MOV 0xABA, W5
0051F8  90021E     MOV [W14+2], W4
0051FA  528F84     SUB W5, W4, [W15]
0051FC  340002     BRA LE, 0x5202
0051FE  8055D4     MOV 0xABA, W4
005200  980714     MOV W4, [W14+2]
111:                           
112:                   return RetVal;
005202  90021E     MOV [W14+2], W4
113:               }
005204  780004     MOV W4, W0
005206  BE044F     MOV.D [--W15], W8
005208  FA8000     ULNK
00520A  060000     RETURN
114:               
115:               
116:               
117:               
118:               void Init_PWM_Module(void)		// timer TMR2
119:               {
00520C  FA0000     LNK #0x0
120:               	// Reset PWM 
121:               	OC1CON1 = 0x0000;
00520E  EB0200     CLR W4
005210  880C84     MOV W4, OC1CON1
122:               	OC1CON2 = 0x0000;
005212  EB0200     CLR W4
005214  880C94     MOV W4, OC1CON2
123:               
124:               	OC1CON2bits.FLTMD = 0;			// fault mode is maintened until the new perio starts
005216  A9E193     BCLR 0x193, #7
125:               	OC1CON2bits.FLTOUT = 0;			// output is driven high on a fault condition
005218  A9C193     BCLR 0x193, #6
126:               	OC1CON2bits.FLTTRIEN = 0;		// out is forced to fault condition
00521A  A9A193     BCLR 0x193, #5
127:               	OC1CON2bits.OCINV = 1;			// bit out is inverted
00521C  A88193     BSET 0x193, #4
128:               	OC1CON2bits.OC32 = 0;			// cascade mode is disable
00521E  A90193     BCLR 0x193, #0
129:               	OC1CON2bits.OCTRIG = 0;			// sync whit source
005220  A9E192     BCLR OC1CON2, #7
130:               	OC1CON2bits.TRIGSTAT = 0;		// Timesource has not been triggered
005222  A9C192     BCLR OC1CON2, #6
131:               	OC1CON2bits.OCTRIS = 0;			// Output compare connected to OCx pin
005224  A9A192     BCLR OC1CON2, #5
132:               	OC1CON2bits.SYNCSEL = 0x1F;		// sync source this module
005226  800C94     MOV OC1CON2, W4
005228  B301F4     IOR #0x1F, W4
00522A  880C94     MOV W4, OC1CON2
133:               
134:               	OC1RS = 0x0FFF;					// valore di reset del cnt
00522C  20FFF4     MOV #0xFFF, W4
00522E  880CA4     MOV W4, OC1RS
135:               	OC1R = 0x0000;					// valore di commutazione dell'output
005230  EB0200     CLR W4
005232  880CB4     MOV W4, OC1R
136:               	OC1CON1bits.OCSIDL = 0;			// sempre on anche in idle
005234  A9A191     BCLR 0x191, #5
137:               	OC1CON1bits.OCTSEL = 7;			// clock source is sytem clock
005236  800C84     MOV OC1CON1, W4
005238  A0A004     BSET W4, #10
00523A  A0B004     BSET W4, #11
00523C  A0C004     BSET W4, #12
00523E  880C84     MOV W4, OC1CON1
138:               	OC1CON1bits.ENFLT0 = 0;			// disable fault bit
005240  A9E190     BCLR OC1CON1, #7
139:               	OC1CON1bits.TRIGMODE = 0;		// trig modo is auto reset
005242  A96190     BCLR OC1CON1, #3
140:               	OC1CON1bits.OCM = 6;			// Edge-alining PWM mode
005244  800C84     MOV OC1CON1, W4
005246  A10004     BCLR W4, #0
005248  A01004     BSET W4, #1
00524A  A02004     BSET W4, #2
00524C  880C84     MOV W4, OC1CON1
141:               }
00524E  FA8000     ULNK
005250  060000     RETURN
142:               
143:               void VariazionePWM(void)
144:               {
005252  FA0000     LNK #0x0
145:               	if(RefreshVentil.TimeOut)	// controllo se devo aggiornare il ventil
005254  805714     MOV 0xAE2, W4
005256  620262     AND W4, #0x2, W4
005258  520FE0     SUB W4, #0x0, [W15]
00525A  32003B     BRA Z, 0x52D2
146:               	{	if(Me.Pwm_Req != Me.Pwm_Value)
00525C  805C75     MOV 0xB8E, W5
00525E  805C84     MOV 0xB90, W4
005260  528F84     SUB W5, W4, [W15]
005262  320034     BRA Z, 0x52CC
147:               		{
148:               			if((Me.Pwm_Value < (PWMValue[1]-20)) & (Me.Pwm_Req < Me.Pwm_Value))	// si sta spegnendo
005264  805C86     MOV 0xB90, W6
005266  8055D4     MOV 0xABA, W4
005268  520274     SUB W4, #0x14, W4
00526A  B3C015     MOV.B #0x1, W5
00526C  530F84     SUB W6, W4, [W15]
00526E  350001     BRA LT, 0x5272
005270  EB4280     CLR.B W5
005272  805C77     MOV 0xB8E, W7
005274  805C86     MOV 0xB90, W6
005276  B3C014     MOV.B #0x1, W4
005278  538F86     SUB W7, W6, [W15]
00527A  350001     BRA LT, 0x527E
00527C  EB4200     CLR.B W4
00527E  62C204     AND.B W5, W4, W4
005280  524FE0     SUB.B W4, #0x0, [W15]
005282  320002     BRA Z, 0x5288
149:               				Me.Pwm_Value = PWMValue[0];
005284  8055C4     MOV PWMValue, W4
005286  885C84     MOV W4, 0xB90
150:               			if((Me.Pwm_Value < (PWMValue[1]-10)) & (Me.Pwm_Req > Me.Pwm_Value))	// si sta accendendo
005288  805C86     MOV 0xB90, W6
00528A  8055D4     MOV 0xABA, W4
00528C  52026A     SUB W4, #0xA, W4
00528E  B3C015     MOV.B #0x1, W5
005290  530F84     SUB W6, W4, [W15]
005292  350001     BRA LT, 0x5296
005294  EB4280     CLR.B W5
005296  805C77     MOV 0xB8E, W7
005298  805C86     MOV 0xB90, W6
00529A  B3C014     MOV.B #0x1, W4
00529C  538F86     SUB W7, W6, [W15]
00529E  3C0001     BRA GT, 0x52A2
0052A0  EB4200     CLR.B W4
0052A2  62C204     AND.B W5, W4, W4
0052A4  524FE0     SUB.B W4, #0x0, [W15]
0052A6  320003     BRA Z, 0x52AE
151:               				Me.Pwm_Value = PWMValue[1]-10;
0052A8  8055D4     MOV 0xABA, W4
0052AA  52026A     SUB W4, #0xA, W4
0052AC  885C84     MOV W4, 0xB90
152:               			if(Me.Pwm_Req > Me.Pwm_Value)
0052AE  805C75     MOV 0xB8E, W5
0052B0  805C84     MOV 0xB90, W4
0052B2  528F84     SUB W5, W4, [W15]
0052B4  340006     BRA LE, 0x52C2
153:               				Incrementa(&(Me.Pwm_Value), 1, PWMValue[8]);
0052B6  805644     MOV 0xAC8, W4
0052B8  780104     MOV W4, W2
0052BA  200011     MOV #0x1, W1
0052BC  20B900     MOV #0xB90, W0
0052BE  0703E4     RCALL Incrementa
0052C0  370005     BRA 0x52CC
154:               			else
155:               				Decrementa(&(Me.Pwm_Value), 1, PWMValue[0]);
0052C2  8055C4     MOV PWMValue, W4
0052C4  780104     MOV W4, W2
0052C6  200011     MOV #0x1, W1
0052C8  20B900     MOV #0xB90, W0
0052CA  07040C     RCALL Decrementa
156:               		}
157:               		RefreshVentil.Value = 0;
0052CC  EB0200     CLR W4
0052CE  8856F4     MOV W4, RefreshVentil
158:               		RefreshVentil.TimeOut = 0;
0052D0  A92AE2     BCLR 0xAE2, #1
159:               	}
160:               
161:               	OC1R = ((Me.Pwm_Value & 0x00FF) <<4);		// aggiorno il modulo OC
0052D2  805C85     MOV 0xB90, W5
0052D4  200FF4     MOV #0xFF, W4
0052D6  628204     AND W5, W4, W4
0052D8  DD2244     SL W4, #4, W4
0052DA  880CB4     MOV W4, OC1R
162:               }
0052DC  FA8000     ULNK
0052DE  060000     RETURN
163:               
164:               
165:               // NEW sostituisce -> FineRegVentil(int SpeedLimit)
166:               int FanSpeedLimit(int SpeedReq)
167:               {
0052E0  FA0012     LNK #0x12
0052E2  781F88     MOV W8, [W15++]
0052E4  980F00     MOV W0, [W14+16]
168:               	/**/
169:               	int TempErr;
170:               	float DeltaV;
171:               	float DeltaT;
172:               	float KDiv;
173:               	int RetVal;
174:               	
175:               	Me.Fan_MaxSpeed = Filter(&FilterFan_MaxSpeed, ((DeltaTempReqOut() + DeltaTempInOut()) / 2), K_Campioni_FilterFanSpeed);
0052E6  07FF3F     RCALL DeltaTempReqOut
0052E8  780400     MOV W0, W8
0052EA  07FEF3     RCALL DeltaTempInOut
0052EC  780200     MOV W0, W4
0052EE  440284     ADD W8, W4, W5
0052F0  200024     MOV #0x2, W4
0052F2  090011     REPEAT #0x11
0052F4  D80284     DIV.SW W5, W4
0052F6  780200     MOV W0, W4
0052F8  200142     MOV #0x14, W2
0052FA  780084     MOV W4, W1
0052FC  20EB80     MOV #0xEB8, W0
0052FE  071698     RCALL Filter
005300  780200     MOV W0, W4
005302  885C64     MOV W4, 0xB8C
176:               	if(SpeedReq==K_FanSpeedAuto)
005304  900A8E     MOV [W14+16], W5
005306  201004     MOV #0x100, W4
005308  528F84     SUB W5, W4, [W15]
00530A  3A0060     BRA NZ, 0x53CC
177:               	{
178:               
179:               		if((Me.Function_Mode == CoreRiscaldamento) | (Me.Function_Mode == CoreSlaveCaldo))	// Se deve riscaldare
00530C  805C24     MOV 0xB84, W4
00530E  A22004     BTG W4, #2
005310  A7F004     BTSC W4, #15
005312  EA0204     NEG W4, W4
005314  E90204     DEC W4, W4
005316  DE224F     LSR W4, #15, W4
005318  784284     MOV.B W4, W5
00531A  805C24     MOV 0xB84, W4
00531C  6A0271     XOR W4, #0x11, W4
00531E  A7F004     BTSC W4, #15
005320  EA0204     NEG W4, W4
005322  E90204     DEC W4, W4
005324  DE224F     LSR W4, #15, W4
005326  784204     MOV.B W4, W4
005328  72C204     IOR.B W5, W4, W4
00532A  524FE0     SUB.B W4, #0x0, [W15]
00532C  320004     BRA Z, 0x5336
180:               			TempErr = (Me.SP - Me.Temp_Amb);
00532E  805BC5     MOV 0xB78, W5
005330  805B64     MOV Me, W4
005332  528F04     SUB W5, W4, [W14]
005334  37001A     BRA 0x536A
181:               		else if((Me.Function_Mode == CoreRaffrescamento) | (Me.Function_Mode == CoreSlaveFreddo))	// Se deve raffrescare										// Se deve raffrescare
005336  805C24     MOV 0xB84, W4
005338  A23004     BTG W4, #3
00533A  A7F004     BTSC W4, #15
00533C  EA0204     NEG W4, W4
00533E  E90204     DEC W4, W4
005340  DE224F     LSR W4, #15, W4
005342  784284     MOV.B W4, W5
005344  805C24     MOV 0xB84, W4
005346  6A0272     XOR W4, #0x12, W4
005348  A7F004     BTSC W4, #15
00534A  EA0204     NEG W4, W4
00534C  E90204     DEC W4, W4
00534E  DE224F     LSR W4, #15, W4
005350  784204     MOV.B W4, W4
005352  72C204     IOR.B W5, W4, W4
005354  524FE0     SUB.B W4, #0x0, [W15]
005356  320004     BRA Z, 0x5360
182:               			TempErr = (Me.Temp_Amb - Me.SP);		
005358  805B65     MOV Me, W5
00535A  805BC4     MOV 0xB78, W4
00535C  528F04     SUB W5, W4, [W14]
00535E  370005     BRA 0x536A
183:               		else if(Me.Function_Mode == CoreVentilazione)	// Se deve ventilare										// Se deve raffrescare
005360  805C24     MOV 0xB84, W4
005362  520FF0     SUB W4, #0x10, [W15]
005364  3A0002     BRA NZ, 0x536A
184:               			TempErr = 25;	//(Me.Temp_Amb - Me.SP);		
005366  200194     MOV #0x19, W4
005368  780F04     MOV W4, [W14]
185:               
186:               
187:               		if(TempErr < K_Lim_Temp_Auto_FanSpeed_Min) TempErr = K_Lim_Temp_Auto_FanSpeed_Min;
00536A  2FF9C4     MOV #0xFF9C, W4
00536C  78029E     MOV [W14], W5
00536E  528F84     SUB W5, W4, [W15]
005370  3D0002     BRA GE, 0x5376
005372  2FF9C4     MOV #0xFF9C, W4
005374  780F04     MOV W4, [W14]
188:               		if(TempErr > K_Lim_Temp_Auto_FanSpeed_Max) TempErr = K_Lim_Temp_Auto_FanSpeed_Max;
005376  200964     MOV #0x96, W4
005378  78029E     MOV [W14], W5
00537A  528F84     SUB W5, W4, [W15]
00537C  340002     BRA LE, 0x5382
00537E  200964     MOV #0x96, W4
005380  780F04     MOV W4, [W14]
189:               
190:               
191:               		DeltaT = (float)K_Lim_Temp_Auto_FanSpeed_Max-(float)K_Lim_Temp_Auto_FanSpeed_Min;		
005382  200004     MOV #0x0, W4
005384  2437A5     MOV #0x437A, W5
005386  980724     MOV W4, [W14+4]
005388  980735     MOV W5, [W14+6]
192:               		DeltaV = (float)K_Lim_VelPwm_Auto_FanSpeed_Max - (float)K_Lim_VelPwm_Auto_FanSpeed_Min;
00538A  200004     MOV #0x0, W4
00538C  243525     MOV #0x4352, W5
00538E  980744     MOV W4, [W14+8]
005390  980755     MOV W5, [W14+10]
193:               		KDiv = DeltaT / DeltaV;			
005392  90014E     MOV [W14+8], W2
005394  9001DE     MOV [W14+10], W3
005396  90002E     MOV [W14+4], W0
005398  9000BE     MOV [W14+6], W1
00539A  07D80F     RCALL ___divsf3
00539C  BE0200     MOV.D W0, W4
00539E  980764     MOV W4, [W14+12]
0053A0  980775     MOV W5, [W14+14]
194:               
195:               
196:               		RetVal = (int)(((float)(TempErr-K_Lim_Temp_Auto_FanSpeed_Min) / KDiv) + (float)K_Lim_VelPwm_Auto_FanSpeed_Min);	
0053A2  200645     MOV #0x64, W5
0053A4  42821E     ADD W5, [W14], W4
0053A6  DEA2CF     ASR W4, #15, W5
0053A8  BE0004     MOV.D W4, W0
0053AA  07D889     RCALL ___floatsisf
0053AC  BE0200     MOV.D W0, W4
0053AE  90016E     MOV [W14+12], W2
0053B0  9001FE     MOV [W14+14], W3
0053B2  BE0004     MOV.D W4, W0
0053B4  07D802     RCALL ___divsf3
0053B6  BE0200     MOV.D W0, W4
0053B8  200002     MOV #0x0, W2
0053BA  242343     MOV #0x4234, W3
0053BC  BE0004     MOV.D W4, W0
0053BE  07D7A0     RCALL ___addsf3
0053C0  BE0200     MOV.D W0, W4
0053C2  BE0004     MOV.D W4, W0
0053C4  07D840     RCALL ___fixsfsi
0053C6  BE0200     MOV.D W0, W4
0053C8  980714     MOV W4, [W14+2]
0053CA  370002     BRA 0x53D0
197:               	}
198:               	else
199:               	{
200:               		RetVal = SpeedReq;
0053CC  90080E     MOV [W14+16], W0
0053CE  980710     MOV W0, [W14+2]
201:               	}
202:               	
203:               	if(RetVal < K_FanSpeedNight)		// Se velocità ventil calcolata è inferiore a Night .... limito
0053D0  90029E     MOV [W14+2], W5
0053D2  2002C4     MOV #0x2C, W4
0053D4  528F84     SUB W5, W4, [W15]
0053D6  3C0002     BRA GT, 0x53DC
204:               		RetVal = K_FanSpeedNight;
0053D8  2002D4     MOV #0x2D, W4
0053DA  980714     MOV W4, [W14+2]
205:               	
206:               	if(RetVal>Me.Fan_MaxSpeed)			// Se velocità ventil calcolata è superiore a massimo consentito da calcoli precedenti... limito
0053DC  805C65     MOV 0xB8C, W5
0053DE  90021E     MOV [W14+2], W4
0053E0  528F84     SUB W5, W4, [W15]
0053E2  3D0002     BRA GE, 0x53E8
207:               		RetVal=Me.Fan_MaxSpeed;
0053E4  805C61     MOV 0xB8C, W1
0053E6  980711     MOV W1, [W14+2]
208:               	
209:               	
210:               	
211:               	return RetVal;
0053E8  90021E     MOV [W14+2], W4
212:               }
0053EA  780004     MOV W4, W0
0053EC  78044F     MOV [--W15], W8
0053EE  FA8000     ULNK
0053F0  060000     RETURN
213:               
214:               // NEW sostituisce -> AggiornaVentil(void)
215:               void UpdateFanSpeed(void)
216:               {
0053F2  FA0000     LNK #0x0
217:               	
218:               	Me.Error.Battery_Defrost = 0;
0053F4  A92BAC     BCLR 0xBAC, #1
219:               	if(Me.Error.BatteriaGhiacciata)
0053F6  805D64     MOV 0xBAC, W4
0053F8  620270     AND W4, #0x10, W4
0053FA  520FE0     SUB W4, #0x0, [W15]
0053FC  320004     BRA Z, 0x5406
220:               	{	Me.Pwm_Req= PWMValue[4];
0053FE  805604     MOV 0xAC0, W4
005400  885C74     MOV W4, 0xB8E
221:               		Me.Error.Battery_Defrost = 1;
005402  A82BAC     BSET 0xBAC, #1
005404  370120     BRA 0x5646
222:               	}
223:               	else if((Me.Temp_Big < SogliVent2_BatteriaGhiacciata) & (Me.Function_Mode == CoreOff))
005406  805B86     MOV 0xB70, W6
005408  B3C014     MOV.B #0x1, W4
00540A  2FE705     MOV #0xFE70, W5
00540C  530F85     SUB W6, W5, [W15]
00540E  350001     BRA LT, 0x5412
005410  EB4200     CLR.B W4
005412  805C25     MOV 0xB84, W5
005414  A7F005     BTSC W5, #15
005416  EA0285     NEG W5, W5
005418  E90285     DEC W5, W5
00541A  DE2ACF     LSR W5, #15, W5
00541C  784285     MOV.B W5, W5
00541E  624205     AND.B W4, W5, W4
005420  524FE0     SUB.B W4, #0x0, [W15]
005422  320004     BRA Z, 0x542C
224:               	{	Me.Pwm_Req= PWMValue[3];
005424  8055F4     MOV 0xABE, W4
005426  885C74     MOV W4, 0xB8E
225:               		Me.Error.Battery_Defrost = 1;
005428  A82BAC     BSET 0xBAC, #1
00542A  37010D     BRA 0x5646
226:               	}
227:               	else if((Me.Temp_Big < SogliVent1_BatteriaGhiacciata) & (Me.Function_Mode == CoreOff))
00542C  805B86     MOV 0xB70, W6
00542E  B3C014     MOV.B #0x1, W4
005430  2FED45     MOV #0xFED4, W5
005432  530F85     SUB W6, W5, [W15]
005434  350001     BRA LT, 0x5438
005436  EB4200     CLR.B W4
005438  805C25     MOV 0xB84, W5
00543A  A7F005     BTSC W5, #15
00543C  EA0285     NEG W5, W5
00543E  E90285     DEC W5, W5
005440  DE2ACF     LSR W5, #15, W5
005442  784285     MOV.B W5, W5
005444  624205     AND.B W4, W5, W4
005446  524FE0     SUB.B W4, #0x0, [W15]
005448  320004     BRA Z, 0x5452
228:               	{	Me.Pwm_Req= PWMValue[2];
00544A  8055E4     MOV 0xABC, W4
00544C  885C74     MOV W4, 0xB8E
229:               		Me.Error.Battery_Defrost = 1;
00544E  A82BAC     BSET 0xBAC, #1
005450  3700FA     BRA 0x5646
230:               	}
231:               	else if((Me.Temp_Big < SogliVentNightBatteriaGhiacciata) & (Me.Function_Mode == CoreOff))
005452  805B86     MOV 0xB70, W6
005454  B3C014     MOV.B #0x1, W4
005456  2FF385     MOV #0xFF38, W5
005458  530F85     SUB W6, W5, [W15]
00545A  350001     BRA LT, 0x545E
00545C  EB4200     CLR.B W4
00545E  805C25     MOV 0xB84, W5
005460  A7F005     BTSC W5, #15
005462  EA0285     NEG W5, W5
005464  E90285     DEC W5, W5
005466  DE2ACF     LSR W5, #15, W5
005468  784285     MOV.B W5, W5
00546A  624205     AND.B W4, W5, W4
00546C  524FE0     SUB.B W4, #0x0, [W15]
00546E  320004     BRA Z, 0x5478
232:               	{	Me.Pwm_Req= PWMValue[1];
005470  8055D4     MOV 0xABA, W4
005472  885C74     MOV W4, 0xB8E
233:               		Me.Error.Battery_Defrost = 1;
005474  A82BAC     BSET 0xBAC, #1
005476  3700E7     BRA 0x5646
234:               	}
235:               	else if((Me.Function_Mode != 0) & ((EngineBox.Error.CompressorLo & EngineBox.InverterRiscaldamento) | 
005478  805C24     MOV 0xB84, W4
00547A  A7F004     BTSC W4, #15
00547C  EA0204     NEG W4, W4
00547E  EA0204     NEG W4, W4
005480  DE224F     LSR W4, #15, W4
005482  805A85     MOV 0xB50, W5
005484  D10285     LSR W5, W5
005486  62C2E1     AND.B W5, #0x1, W5
005488  FB8305     ZE W5, W6
00548A  805A75     MOV 0xB4E, W5
00548C  D10285     LSR W5, W5
00548E  62C2E1     AND.B W5, #0x1, W5
005490  FB8285     ZE W5, W5
005492  630305     AND W6, W5, W6
00549A  FB8285     ZE W5, W5
00549C  728306     IOR W5, W6, W6
0054A8  620205     AND W4, W5, W4
0054AA  520FE0     SUB W4, #0x0, [W15]
0054AC  320003     BRA Z, 0x54B4
236:               		(EngineBox.Error.CondensatoreLo) | (EngineBox.Error.Gas_Recovery)))
005494  805A85     MOV 0xB50, W5
005496  DE2AC3     LSR W5, #3, W5
005498  62C2E1     AND.B W5, #0x1, W5
00549E  805A85     MOV 0xB50, W5
0054A0  DE2AC4     LSR W5, #4, W5
0054A2  62C2E1     AND.B W5, #0x1, W5
0054A4  FB8285     ZE W5, W5
0054A6  728286     IOR W5, W6, W5
237:               		Me.Pwm_Req= PWMValue[2];														// faccio girare a 2 il ventilatore
0054AE  8055E4     MOV 0xABC, W4
0054B0  885C74     MOV W4, 0xB8E
0054B2  3700C9     BRA 0x5646
238:               	else if(EngineBox.Test.FluxReq | EngineBox.Test.EEV_Req | EngineBox.Test.EEV_Go)	// se ho un test
0054B4  805AA4     MOV 0xB54, W4
0054B6  784204     MOV.B W4, W4
0054B8  624261     AND.B W4, #0x1, W4
0054BA  FB8284     ZE W4, W5
0054BC  805AA4     MOV 0xB54, W4
0054BE  D10204     LSR W4, W4
0054C0  624261     AND.B W4, #0x1, W4
0054C2  FB8204     ZE W4, W4
0054C4  720285     IOR W4, W5, W5
0054C6  805AA4     MOV 0xB54, W4
0054C8  DE2242     LSR W4, #2, W4
0054CA  624261     AND.B W4, #0x1, W4
0054CC  FB8204     ZE W4, W4
0054CE  720205     IOR W4, W5, W4
0054D0  520FE0     SUB W4, #0x0, [W15]
0054D2  320003     BRA Z, 0x54DA
239:               		Me.Pwm_Req= PWMValue[0];														// fermo il ventilatore
0054D4  8055C4     MOV PWMValue, W4
0054D6  885C74     MOV W4, 0xB8E
0054D8  3700B6     BRA 0x5646
240:               	else
241:               	{	switch(Me.Function_Mode)
0054DA  805C24     MOV 0xB84, W4
0054DC  DEA2CF     ASR W4, #15, W5
0054DE  200126     MOV #0x12, W6
0054E0  200007     MOV #0x0, W7
0054E2  520F86     SUB W4, W6, [W15]
0054E4  5A8F87     SUBB W5, W7, [W15]
0054E6  3E00AB     BRA GTU, 0x563E
0054E8  016004     BRA W4
0054EA  37006B     BRA 0x55C2
0054EC  3700A8     BRA 0x563E
0054EE  3700A7     BRA 0x563E
0054F0  3700A6     BRA 0x563E
0054F2  37000E     BRA 0x5510
0054F4  3700A4     BRA 0x563E
0054F6  3700A3     BRA 0x563E
0054F8  3700A2     BRA 0x563E
0054FA  37000A     BRA 0x5510
0054FC  3700A0     BRA 0x563E
0054FE  37009F     BRA 0x563E
005500  37009E     BRA 0x563E
005502  37009D     BRA 0x563E
005504  37009C     BRA 0x563E
005506  37009B     BRA 0x563E
005508  37009A     BRA 0x563E
00550A  370002     BRA 0x5510
00550C  370001     BRA 0x5510
00550E  370000     BRA 0x5510
242:               		{	case CoreRaffrescamento:
243:               			case CoreRiscaldamento:
244:               			case CoreVentilazione:
245:               			case CoreSlaveCaldo:
246:               			case CoreSlaveFreddo:
247:               				if(Me.Ventil_Mode==Ventil_Auto)
005510  805C54     MOV 0xB8A, W4
005512  520FE9     SUB W4, #0x9, [W15]
005514  3A0005     BRA NZ, 0x5520
248:               				{
249:               					Me.Pwm_Req = FanSpeedLimit(K_FanSpeedAuto);
005516  201000     MOV #0x100, W0
005518  07FEE3     RCALL FanSpeedLimit
00551A  780200     MOV W0, W4
00551C  885C74     MOV W4, 0xB8E
250:               				}		
251:               				else if(Me.Ventil_Mode==Ventil_Off)		Me.Pwm_Req = FanSpeedLimit(PWMValue[0]);
005520  805C54     MOV 0xB8A, W4
005522  520FE0     SUB W4, #0x0, [W15]
005524  3A0006     BRA NZ, 0x5532
005526  8055C4     MOV PWMValue, W4
005528  780004     MOV W4, W0
00552A  07FEDA     RCALL FanSpeedLimit
00552C  780200     MOV W0, W4
00552E  885C74     MOV W4, 0xB8E
252:               				else if(Me.Ventil_Mode==Ventil_Night)	Me.Pwm_Req = FanSpeedLimit(PWMValue[1]);
005532  805C54     MOV 0xB8A, W4
005534  520FE1     SUB W4, #0x1, [W15]
005536  3A0006     BRA NZ, 0x5544
005538  8055D4     MOV 0xABA, W4
00553A  780004     MOV W4, W0
00553C  07FED1     RCALL FanSpeedLimit
00553E  780200     MOV W0, W4
005540  885C74     MOV W4, 0xB8E
253:               				else if(Me.Ventil_Mode==Ventil_1) Me.Pwm_Req = FanSpeedLimit(PWMValue[2]);
005544  805C54     MOV 0xB8A, W4
005546  520FE2     SUB W4, #0x2, [W15]
005548  3A0006     BRA NZ, 0x5556
00554A  8055E4     MOV 0xABC, W4
00554C  780004     MOV W4, W0
00554E  07FEC8     RCALL FanSpeedLimit
005550  780200     MOV W0, W4
005552  885C74     MOV W4, 0xB8E
254:               				else if(Me.Ventil_Mode==Ventil_2) Me.Pwm_Req = FanSpeedLimit(PWMValue[3]);
005556  805C54     MOV 0xB8A, W4
005558  520FE3     SUB W4, #0x3, [W15]
00555A  3A0006     BRA NZ, 0x5568
00555C  8055F4     MOV 0xABE, W4
00555E  780004     MOV W4, W0
005560  07FEBF     RCALL FanSpeedLimit
005562  780200     MOV W0, W4
005564  885C74     MOV W4, 0xB8E
255:               				else if(Me.Ventil_Mode==Ventil_3) Me.Pwm_Req = FanSpeedLimit(PWMValue[4]);
005568  805C54     MOV 0xB8A, W4
00556A  520FE4     SUB W4, #0x4, [W15]
00556C  3A0006     BRA NZ, 0x557A
00556E  805604     MOV 0xAC0, W4
005570  780004     MOV W4, W0
005572  07FEB6     RCALL FanSpeedLimit
005574  780200     MOV W0, W4
005576  885C74     MOV W4, 0xB8E
256:               				else if(Me.Ventil_Mode==Ventil_4) Me.Pwm_Req = FanSpeedLimit(PWMValue[5]);
00557A  805C54     MOV 0xB8A, W4
00557C  520FE5     SUB W4, #0x5, [W15]
00557E  3A0006     BRA NZ, 0x558C
005580  805614     MOV 0xAC2, W4
005582  780004     MOV W4, W0
005584  07FEAD     RCALL FanSpeedLimit
005586  780200     MOV W0, W4
005588  885C74     MOV W4, 0xB8E
257:               				else if(Me.Ventil_Mode==Ventil_5) Me.Pwm_Req = FanSpeedLimit(PWMValue[6]);
00558C  805C54     MOV 0xB8A, W4
00558E  520FE6     SUB W4, #0x6, [W15]
005590  3A0006     BRA NZ, 0x559E
005592  805624     MOV 0xAC4, W4
005594  780004     MOV W4, W0
005596  07FEA4     RCALL FanSpeedLimit
005598  780200     MOV W0, W4
00559A  885C74     MOV W4, 0xB8E
258:               				else if(Me.Ventil_Mode==Ventil_6) Me.Pwm_Req = FanSpeedLimit(PWMValue[7]);
00559E  805C54     MOV 0xB8A, W4
0055A0  520FE7     SUB W4, #0x7, [W15]
0055A2  3A0006     BRA NZ, 0x55B0
0055A4  805634     MOV 0xAC6, W4
0055A6  780004     MOV W4, W0
0055A8  07FE9B     RCALL FanSpeedLimit
0055AA  780200     MOV W0, W4
0055AC  885C74     MOV W4, 0xB8E
259:               				else if(Me.Ventil_Mode==Ventil_7) Me.Pwm_Req = FanSpeedLimit(PWMValue[8]);
0055B0  805C54     MOV 0xB8A, W4
0055B2  520FE8     SUB W4, #0x8, [W15]
0055B4  3A0047     BRA NZ, 0x5644
0055B6  805644     MOV 0xAC8, W4
0055B8  780004     MOV W4, W0
0055BA  07FE92     RCALL FanSpeedLimit
0055BC  780200     MOV W0, W4
0055BE  885C74     MOV W4, 0xB8E
260:               					
261:               				break;
00551E  370093     BRA 0x5646
005530  37008A     BRA 0x5646
005542  370081     BRA 0x5646
005554  370078     BRA 0x5646
005566  37006F     BRA 0x5646
005578  370066     BRA 0x5646
00558A  37005D     BRA 0x5646
00559C  370054     BRA 0x5646
0055AE  37004B     BRA 0x5646
0055C0  370042     BRA 0x5646
005644  000000     NOP
262:               
263:               			case CoreOff:					// lo split richiede lo spegnimento
264:               					if((Touch[0].FunctionMode == CoreRiscaldamento) |
0055C2  805D84     MOV 0xBB0, W4
0055C4  A22004     BTG W4, #2
0055C6  A7F004     BTSC W4, #15
0055C8  EA0204     NEG W4, W4
0055CA  E90204     DEC W4, W4
0055CC  DE224F     LSR W4, #15, W4
0055CE  784284     MOV.B W4, W5
0055DE  72C204     IOR.B W5, W4, W4
0055E0  FB8284     ZE W4, W5
0055F0  520FE0     SUB W4, #0x0, [W15]
0055F2  32000D     BRA Z, 0x560E
265:               						(Touch[0].FunctionMode == CoreRaffrescamento) |
0055D0  805D84     MOV 0xBB0, W4
0055D2  A23004     BTG W4, #3
0055D4  A7F004     BTSC W4, #15
0055D6  EA0204     NEG W4, W4
0055D8  E90204     DEC W4, W4
0055DA  DE224F     LSR W4, #15, W4
0055DC  784204     MOV.B W4, W4
0055EE  720205     IOR W4, W5, W4
266:               						(Touch[0].FunctionMode == CoreAuto))		// se comunque è acceso
0055E2  805D84     MOV 0xBB0, W4
0055E4  A21004     BTG W4, #1
0055E6  A7F004     BTSC W4, #15
0055E8  EA0204     NEG W4, W4
0055EA  E90204     DEC W4, W4
0055EC  DE224F     LSR W4, #15, W4
267:               					{	if(Me.Ventil_Mode > 8)
0055F4  805C54     MOV 0xB8A, W4
0055F6  520FE8     SUB W4, #0x8, [W15]
0055F8  340003     BRA LE, 0x5600
268:               							Me.Pwm_Req = PWMValue[2];				// speed 1
0055FA  8055E4     MOV 0xABC, W4
0055FC  885C74     MOV W4, 0xB8E
269:               						else
270:               							Me.Pwm_Req = PWMValue[Me.Ventil_Mode];	// actual speed
005600  805C54     MOV 0xB8A, W4
005602  420284     ADD W4, W4, W5
005604  20AB84     MOV #0xAB8, W4
005606  428204     ADD W5, W4, W4
005608  780214     MOV [W4], W4
00560A  885C74     MOV W4, 0xB8E
271:               					}
272:               					else if(EngineBox.IdMasterSplit == Me.My_Address)
00560E  20B4D4     MOV #0xB4D, W4
005610  784214     MOV.B [W4], W4
005612  FB0284     SE W4, W5
005614  20BA44     MOV #0xBA4, W4
005616  784214     MOV.B [W4], W4
005618  FB8204     ZE W4, W4
00561A  528F84     SUB W5, W4, [W15]
00561C  3A000B     BRA NZ, 0x5634
273:               					{	if(EngineBox.FunctionMode == EngineBox_GoOff)
00561E  805A54     MOV 0xB4A, W4
005620  520FE1     SUB W4, #0x1, [W15]
005622  3A0003     BRA NZ, 0x562A
274:               							Me.Pwm_Req = PWMValue[2];	// speed 1
005624  8055E4     MOV 0xABC, W4
005626  885C74     MOV W4, 0xB8E
275:               						else
276:               						{	Me.Old_Function_Mode = CoreOff;
00562A  EB0200     CLR W4
00562C  885C44     MOV W4, 0xB88
277:               							Me.Pwm_Req = PWMValue[0];
00562E  8055C4     MOV PWMValue, W4
005630  885C74     MOV W4, 0xB8E
278:               						}
279:               					}
280:               					else
281:               					{	Me.Old_Function_Mode = CoreOff;
005634  EB0200     CLR W4
005636  885C44     MOV W4, 0xB88
282:               						Me.Pwm_Req = PWMValue[0];
005638  8055C4     MOV PWMValue, W4
00563A  885C74     MOV W4, 0xB8E
283:               					}
284:               				break;
0055FE  370023     BRA 0x5646
00560C  37001C     BRA 0x5646
005628  37000E     BRA 0x5646
005632  370009     BRA 0x5646
00563C  370004     BRA 0x5646
285:               	
286:               			default:
287:               				Me.Pwm_Req = PWMValue[0];
00563E  8055C4     MOV PWMValue, W4
005640  885C74     MOV W4, 0xB8E
288:               				break;
005642  370001     BRA 0x5646
289:               		}
290:               	}
291:               	if(EngineBox.FunctionMode == EngineBox_CriticalFault)
005646  805A54     MOV 0xB4A, W4
005648  520FE6     SUB W4, #0x6, [W15]
00564A  3A0002     BRA NZ, 0x5650
292:               		Me.Pwm_Req = PWMValue[0];
00564C  8055C4     MOV PWMValue, W4
00564E  885C74     MOV W4, 0xB8E
293:               	VariazionePWM();	
005650  07FE00     RCALL VariazionePWM
294:               	
295:               }
005652  FA8000     ULNK
005654  060000     RETURN
296:               
297:               
298:               void AggiornaVentil(void)
299:               {	
005656  FA0000     LNK #0x0
300:               	Me.Error.Battery_Defrost = 0;
005658  A92BAC     BCLR 0xBAC, #1
301:               	if(Me.Error.BatteriaGhiacciata)
00565A  805D64     MOV 0xBAC, W4
00565C  620270     AND W4, #0x10, W4
00565E  520FE0     SUB W4, #0x0, [W15]
005660  320004     BRA Z, 0x566A
302:               	{	Me.Pwm_Req= PWMValue[4];
005662  805604     MOV 0xAC0, W4
005664  885C74     MOV W4, 0xB8E
303:               		Me.Error.Battery_Defrost = 1;
005666  A82BAC     BSET 0xBAC, #1
005668  370102     BRA 0x586E
304:               	}
305:               	else if((Me.Temp_Big < SogliVent2_BatteriaGhiacciata) & (Me.Function_Mode == CoreOff))
00566A  805B86     MOV 0xB70, W6
00566C  B3C014     MOV.B #0x1, W4
00566E  2FE705     MOV #0xFE70, W5
005670  530F85     SUB W6, W5, [W15]
005672  350001     BRA LT, 0x5676
005674  EB4200     CLR.B W4
005676  805C25     MOV 0xB84, W5
005678  A7F005     BTSC W5, #15
00567A  EA0285     NEG W5, W5
00567C  E90285     DEC W5, W5
00567E  DE2ACF     LSR W5, #15, W5
005680  784285     MOV.B W5, W5
005682  624205     AND.B W4, W5, W4
005684  524FE0     SUB.B W4, #0x0, [W15]
005686  320004     BRA Z, 0x5690
306:               	{	Me.Pwm_Req= PWMValue[3];
005688  8055F4     MOV 0xABE, W4
00568A  885C74     MOV W4, 0xB8E
307:               		Me.Error.Battery_Defrost = 1;
00568C  A82BAC     BSET 0xBAC, #1
00568E  3700EF     BRA 0x586E
308:               	}
309:               	else if((Me.Temp_Big < SogliVent1_BatteriaGhiacciata) & (Me.Function_Mode == CoreOff))
005690  805B86     MOV 0xB70, W6
005692  B3C014     MOV.B #0x1, W4
005694  2FED45     MOV #0xFED4, W5
005696  530F85     SUB W6, W5, [W15]
005698  350001     BRA LT, 0x569C
00569A  EB4200     CLR.B W4
00569C  805C25     MOV 0xB84, W5
00569E  A7F005     BTSC W5, #15
0056A0  EA0285     NEG W5, W5
0056A2  E90285     DEC W5, W5
0056A4  DE2ACF     LSR W5, #15, W5
0056A6  784285     MOV.B W5, W5
0056A8  624205     AND.B W4, W5, W4
0056AA  524FE0     SUB.B W4, #0x0, [W15]
0056AC  320004     BRA Z, 0x56B6
310:               	{	Me.Pwm_Req= PWMValue[2];
0056AE  8055E4     MOV 0xABC, W4
0056B0  885C74     MOV W4, 0xB8E
311:               		Me.Error.Battery_Defrost = 1;
0056B2  A82BAC     BSET 0xBAC, #1
0056B4  3700DC     BRA 0x586E
312:               	}
313:               	else if((Me.Temp_Big < SogliVentNightBatteriaGhiacciata) & (Me.Function_Mode == CoreOff))
0056B6  805B86     MOV 0xB70, W6
0056B8  B3C014     MOV.B #0x1, W4
0056BA  2FF385     MOV #0xFF38, W5
0056BC  530F85     SUB W6, W5, [W15]
0056BE  350001     BRA LT, 0x56C2
0056C0  EB4200     CLR.B W4
0056C2  805C25     MOV 0xB84, W5
0056C4  A7F005     BTSC W5, #15
0056C6  EA0285     NEG W5, W5
0056C8  E90285     DEC W5, W5
0056CA  DE2ACF     LSR W5, #15, W5
0056CC  784285     MOV.B W5, W5
0056CE  624205     AND.B W4, W5, W4
0056D0  524FE0     SUB.B W4, #0x0, [W15]
0056D2  320004     BRA Z, 0x56DC
314:               	{	Me.Pwm_Req= PWMValue[1];
0056D4  8055D4     MOV 0xABA, W4
0056D6  885C74     MOV W4, 0xB8E
315:               		Me.Error.Battery_Defrost = 1;
0056D8  A82BAC     BSET 0xBAC, #1
0056DA  3700C9     BRA 0x586E
316:               	}
317:               	else if((Me.Function_Mode != 0) & ((EngineBox.Error.CompressorLo & EngineBox.InverterRiscaldamento) | 
0056DC  805C24     MOV 0xB84, W4
0056DE  A7F004     BTSC W4, #15
0056E0  EA0204     NEG W4, W4
0056E2  EA0204     NEG W4, W4
0056E4  DE224F     LSR W4, #15, W4
0056E6  805A85     MOV 0xB50, W5
0056E8  D10285     LSR W5, W5
0056EA  62C2E1     AND.B W5, #0x1, W5
0056EC  FB8305     ZE W5, W6
0056EE  805A75     MOV 0xB4E, W5
0056F0  D10285     LSR W5, W5
0056F2  62C2E1     AND.B W5, #0x1, W5
0056F4  FB8285     ZE W5, W5
0056F6  630305     AND W6, W5, W6
0056FE  FB8285     ZE W5, W5
005700  728306     IOR W5, W6, W6
00570C  620205     AND W4, W5, W4
00570E  520FE0     SUB W4, #0x0, [W15]
005710  320003     BRA Z, 0x5718
318:               		(EngineBox.Error.CondensatoreLo) | (EngineBox.Error.Gas_Recovery)))
0056F8  805A85     MOV 0xB50, W5
0056FA  DE2AC3     LSR W5, #3, W5
0056FC  62C2E1     AND.B W5, #0x1, W5
005702  805A85     MOV 0xB50, W5
005704  DE2AC4     LSR W5, #4, W5
005706  62C2E1     AND.B W5, #0x1, W5
005708  FB8285     ZE W5, W5
00570A  728286     IOR W5, W6, W5
319:               		Me.Pwm_Req= PWMValue[2];														// faccio girare a 2 il ventilatore
005712  8055E4     MOV 0xABC, W4
005714  885C74     MOV W4, 0xB8E
005716  3700AB     BRA 0x586E
320:               	else if(EngineBox.Test.FluxReq | EngineBox.Test.EEV_Req | EngineBox.Test.EEV_Go)	// se ho un test
005718  805AA4     MOV 0xB54, W4
00571A  784204     MOV.B W4, W4
00571C  624261     AND.B W4, #0x1, W4
00571E  FB8284     ZE W4, W5
005720  805AA4     MOV 0xB54, W4
005722  D10204     LSR W4, W4
005724  624261     AND.B W4, #0x1, W4
005726  FB8204     ZE W4, W4
005728  720285     IOR W4, W5, W5
00572A  805AA4     MOV 0xB54, W4
00572C  DE2242     LSR W4, #2, W4
00572E  624261     AND.B W4, #0x1, W4
005730  FB8204     ZE W4, W4
005732  720205     IOR W4, W5, W4
005734  520FE0     SUB W4, #0x0, [W15]
005736  320003     BRA Z, 0x573E
321:               		Me.Pwm_Req= PWMValue[0];														// fermo il ventilatore
005738  8055C4     MOV PWMValue, W4
00573A  885C74     MOV W4, 0xB8E
00573C  370098     BRA 0x586E
322:               	else
323:               	{	switch(Me.Function_Mode)
00573E  805C24     MOV 0xB84, W4
005740  DEA2CF     ASR W4, #15, W5
005742  200126     MOV #0x12, W6
005744  200007     MOV #0x0, W7
005746  520F86     SUB W4, W6, [W15]
005748  5A8F87     SUBB W5, W7, [W15]
00574A  3E008D     BRA GTU, 0x5866
00574C  016004     BRA W4
00574E  37004D     BRA 0x57EA
005750  37008A     BRA 0x5866
005752  370089     BRA 0x5866
005754  370088     BRA 0x5866
005756  37000E     BRA 0x5774
005758  370086     BRA 0x5866
00575A  370085     BRA 0x5866
00575C  370084     BRA 0x5866
00575E  37000A     BRA 0x5774
005760  370082     BRA 0x5866
005762  370081     BRA 0x5866
005764  370080     BRA 0x5866
005766  37007F     BRA 0x5866
005768  37007E     BRA 0x5866
00576A  37007D     BRA 0x5866
00576C  37007C     BRA 0x5866
00576E  370002     BRA 0x5774
005770  370001     BRA 0x5774
005772  370000     BRA 0x5774
324:               		{	case CoreRaffrescamento:
325:               			case CoreRiscaldamento:
326:               			case CoreVentilazione:
327:               			case CoreSlaveCaldo:
328:               			case CoreSlaveFreddo:
329:               				switch(Me.Ventil_Mode)	
005774  805C54     MOV 0xB8A, W4
005776  DEA2CF     ASR W4, #15, W5
005778  200096     MOV #0x9, W6
00577A  200007     MOV #0x0, W7
00577C  520F86     SUB W4, W6, [W15]
00577E  5A8F87     SUBB W5, W7, [W15]
005780  3E0075     BRA GTU, 0x586C
005782  016004     BRA W4
005784  370009     BRA 0x5798
005786  37000B     BRA 0x579E
005788  37000E     BRA 0x57A6
00578A  370011     BRA 0x57AE
00578C  370014     BRA 0x57B6
00578E  370017     BRA 0x57BE
005790  37001A     BRA 0x57C6
005792  37001D     BRA 0x57CE
005794  370020     BRA 0x57D6
005796  370023     BRA 0x57DE
330:               				{
331:               					case 0:		// Off
332:               						Me.Pwm_Req= PWMValue[0];
005798  8055C4     MOV PWMValue, W4
00579A  885C74     MOV W4, 0xB8E
333:               						break;
00579C  370025     BRA 0x57E8
334:               					case 1:		// Night
335:               						FineRegVentil(PWMValue[1]);
00579E  8055D4     MOV 0xABA, W4
0057A0  780004     MOV W4, W0
0057A2  0700AD     RCALL FineRegVentil
336:               						break;
0057A4  370021     BRA 0x57E8
337:               					case 2:		// Speed 1
338:               						FineRegVentil(PWMValue[2]);
0057A6  8055E4     MOV 0xABC, W4
0057A8  780004     MOV W4, W0
0057AA  0700A9     RCALL FineRegVentil
339:               						break;
0057AC  37001D     BRA 0x57E8
340:               					case 3:		// Speed 2
341:               						FineRegVentil(PWMValue[3]);
0057AE  8055F4     MOV 0xABE, W4
0057B0  780004     MOV W4, W0
0057B2  0700A5     RCALL FineRegVentil
342:               						break;
0057B4  370019     BRA 0x57E8
343:               					case 4:		// Speed 3
344:               						FineRegVentil(PWMValue[4]);
0057B6  805604     MOV 0xAC0, W4
0057B8  780004     MOV W4, W0
0057BA  0700A1     RCALL FineRegVentil
345:               						break;
0057BC  370015     BRA 0x57E8
346:               					case 5:		// Speed 4
347:               						FineRegVentil(PWMValue[5]);
0057BE  805614     MOV 0xAC2, W4
0057C0  780004     MOV W4, W0
0057C2  07009D     RCALL FineRegVentil
348:               						break;
0057C4  370011     BRA 0x57E8
349:               					case 6:		// Speed 5
350:               						FineRegVentil(PWMValue[6]);
0057C6  805624     MOV 0xAC4, W4
0057C8  780004     MOV W4, W0
0057CA  070099     RCALL FineRegVentil
351:               						break;
0057CC  37000D     BRA 0x57E8
352:               					case 7:		// Speed 6
353:               						FineRegVentil(PWMValue[7]);
0057CE  805634     MOV 0xAC6, W4
0057D0  780004     MOV W4, W0
0057D2  070095     RCALL FineRegVentil
354:               						break;
0057D4  370009     BRA 0x57E8
355:               					case 8:		// Speed 7
356:               						FineRegVentil(PWMValue[8]);
0057D6  805644     MOV 0xAC8, W4
0057D8  780004     MOV W4, W0
0057DA  070091     RCALL FineRegVentil
357:               						break;
0057DC  370005     BRA 0x57E8
358:               					case 9:		// Auto
359:               						//Me.Pwm_Req = AutoSpeed();
360:               						FineRegVentil(AutoSpeed());
0057DE  07004F     RCALL AutoSpeed
0057E0  780200     MOV W0, W4
0057E2  780004     MOV W4, W0
0057E4  07008C     RCALL FineRegVentil
361:               						break;
0057E6  000000     NOP
362:               				}
363:               				break;
0057E8  370042     BRA 0x586E
00586C  000000     NOP
364:               
365:               			case CoreOff:					// lo split richiede lo spegnimento
366:               					if((Touch[0].FunctionMode == CoreRiscaldamento) |
0057EA  805D84     MOV 0xBB0, W4
0057EC  A22004     BTG W4, #2
0057EE  A7F004     BTSC W4, #15
0057F0  EA0204     NEG W4, W4
0057F2  E90204     DEC W4, W4
0057F4  DE224F     LSR W4, #15, W4
0057F6  784284     MOV.B W4, W5
005806  72C204     IOR.B W5, W4, W4
005808  FB8284     ZE W4, W5
005818  520FE0     SUB W4, #0x0, [W15]
00581A  32000D     BRA Z, 0x5836
367:               						(Touch[0].FunctionMode == CoreRaffrescamento) |
0057F8  805D84     MOV 0xBB0, W4
0057FA  A23004     BTG W4, #3
0057FC  A7F004     BTSC W4, #15
0057FE  EA0204     NEG W4, W4
005800  E90204     DEC W4, W4
005802  DE224F     LSR W4, #15, W4
005804  784204     MOV.B W4, W4
005816  720205     IOR W4, W5, W4
368:               						(Touch[0].FunctionMode == CoreAuto))		// se comunque è acceso
00580A  805D84     MOV 0xBB0, W4
00580C  A21004     BTG W4, #1
00580E  A7F004     BTSC W4, #15
005810  EA0204     NEG W4, W4
005812  E90204     DEC W4, W4
005814  DE224F     LSR W4, #15, W4
369:               					{	if(Me.Ventil_Mode > 8)
00581C  805C54     MOV 0xB8A, W4
00581E  520FE8     SUB W4, #0x8, [W15]
005820  340003     BRA LE, 0x5828
370:               							Me.Pwm_Req = PWMValue[2];				// speed 1
005822  8055E4     MOV 0xABC, W4
005824  885C74     MOV W4, 0xB8E
371:               						else
372:               							Me.Pwm_Req = PWMValue[Me.Ventil_Mode];	// actual speed
005828  805C54     MOV 0xB8A, W4
00582A  420284     ADD W4, W4, W5
00582C  20AB84     MOV #0xAB8, W4
00582E  428204     ADD W5, W4, W4
005830  780214     MOV [W4], W4
005832  885C74     MOV W4, 0xB8E
373:               					}
374:               					else if(EngineBox.IdMasterSplit == Me.My_Address)
005836  20B4D4     MOV #0xB4D, W4
005838  784214     MOV.B [W4], W4
00583A  FB0284     SE W4, W5
00583C  20BA44     MOV #0xBA4, W4
00583E  784214     MOV.B [W4], W4
005840  FB8204     ZE W4, W4
005842  528F84     SUB W5, W4, [W15]
005844  3A000B     BRA NZ, 0x585C
375:               					{	if(EngineBox.FunctionMode == EngineBox_GoOff)
005846  805A54     MOV 0xB4A, W4
005848  520FE1     SUB W4, #0x1, [W15]
00584A  3A0003     BRA NZ, 0x5852
376:               							Me.Pwm_Req = PWMValue[2];	// speed 1
00584C  8055E4     MOV 0xABC, W4
00584E  885C74     MOV W4, 0xB8E
377:               						else
378:               						{	Me.Old_Function_Mode = CoreOff;
005852  EB0200     CLR W4
005854  885C44     MOV W4, 0xB88
379:               							Me.Pwm_Req = PWMValue[0];
005856  8055C4     MOV PWMValue, W4
005858  885C74     MOV W4, 0xB8E
380:               						}
381:               					}
382:               					else
383:               					{	Me.Old_Function_Mode = CoreOff;
00585C  EB0200     CLR W4
00585E  885C44     MOV W4, 0xB88
384:               						Me.Pwm_Req = PWMValue[0];
005860  8055C4     MOV PWMValue, W4
005862  885C74     MOV W4, 0xB8E
385:               					}
386:               				break;
005826  370023     BRA 0x586E
005834  37001C     BRA 0x586E
005850  37000E     BRA 0x586E
00585A  370009     BRA 0x586E
005864  370004     BRA 0x586E
387:               	
388:               			default:
389:               				Me.Pwm_Req = PWMValue[0];
005866  8055C4     MOV PWMValue, W4
005868  885C74     MOV W4, 0xB8E
390:               				break;
00586A  370001     BRA 0x586E
391:               		}
392:               	}
393:               	if(EngineBox.FunctionMode == EngineBox_CriticalFault)
00586E  805A54     MOV 0xB4A, W4
005870  520FE6     SUB W4, #0x6, [W15]
005872  3A0002     BRA NZ, 0x5878
394:               		Me.Pwm_Req = PWMValue[0];
005874  8055C4     MOV PWMValue, W4
005876  885C74     MOV W4, 0xB8E
395:               	VariazionePWM();
005878  07FCEC     RCALL VariazionePWM
396:               }
00587A  FA8000     ULNK
00587C  060000     RETURN
397:               
398:               int	 AutoSpeed(void)
399:               {	int TempErr = 0;
00587E  FA0004     LNK #0x4
005880  EB0200     CLR W4
005882  780F04     MOV W4, [W14]
400:               	char i = 0;
005884  EB4200     CLR.B W4
005886  984724     MOV.B W4, [W14+2]
401:               
402:               	if((Me.Function_Mode == CoreRiscaldamento) | (Me.Function_Mode == CoreSlaveCaldo))	// Se deve riscaldare
005888  805C24     MOV 0xB84, W4
00588A  A22004     BTG W4, #2
00588C  A7F004     BTSC W4, #15
00588E  EA0204     NEG W4, W4
005890  E90204     DEC W4, W4
005892  DE224F     LSR W4, #15, W4
005894  784284     MOV.B W4, W5
005896  805C24     MOV 0xB84, W4
005898  6A0271     XOR W4, #0x11, W4
00589A  A7F004     BTSC W4, #15
00589C  EA0204     NEG W4, W4
00589E  E90204     DEC W4, W4
0058A0  DE224F     LSR W4, #15, W4
0058A2  784204     MOV.B W4, W4
0058A4  72C204     IOR.B W5, W4, W4
0058A6  524FE0     SUB.B W4, #0x0, [W15]
0058A8  320004     BRA Z, 0x58B2
403:               		TempErr = (Me.SP - Me.Temp_Amb);
0058AA  805BC5     MOV 0xB78, W5
0058AC  805B64     MOV Me, W4
0058AE  528F04     SUB W5, W4, [W14]
0058B0  370003     BRA 0x58B8
404:               	else										// Se deve raffrescare
405:               		TempErr = (Me.Temp_Amb - Me.SP);
0058B2  805B65     MOV Me, W5
0058B4  805BC4     MOV 0xB78, W4
0058B6  528F04     SUB W5, W4, [W14]
406:               
407:               	if(TempErr < (TempLimitSpeed[0]-100))
0058B8  805654     MOV TempLimitSpeed, W4
0058BA  B10644     SUB #0x64, W4
0058BC  520F9E     SUB W4, [W14], [W15]
0058BE  340002     BRA LE, 0x58C4
408:               		return PWMValue[0];						// Spento
0058C0  8055C4     MOV PWMValue, W4
0058C2  37001A     BRA 0x58F8
409:               
410:               	for(i=0; i<8; i++)
0058C4  EB4200     CLR.B W4
0058C6  984724     MOV.B W4, [W14+2]
0058C8  370013     BRA 0x58F0
0058EA  90422E     MOV.B [W14+2], W4
0058EC  E84204     INC.B W4, W4
0058EE  984724     MOV.B W4, [W14+2]
0058F0  90422E     MOV.B [W14+2], W4
0058F2  524FE7     SUB.B W4, #0x7, [W15]
0058F4  34FFEA     BRA LE, 0x58CA
411:               	{	if(TempErr < TempLimitSpeed[i])
0058CA  90422E     MOV.B [W14+2], W4
0058CC  FB0204     SE W4, W4
0058CE  420284     ADD W4, W4, W5
0058D0  20ACA4     MOV #0xACA, W4
0058D2  428204     ADD W5, W4, W4
0058D4  780214     MOV [W4], W4
0058D6  520F9E     SUB W4, [W14], [W15]
0058D8  340008     BRA LE, 0x58EA
412:               			return PWMValue[i+1];
0058DA  90422E     MOV.B [W14+2], W4
0058DC  FB0204     SE W4, W4
0058DE  E80204     INC W4, W4
0058E0  420284     ADD W4, W4, W5
0058E2  20AB84     MOV #0xAB8, W4
0058E4  428204     ADD W5, W4, W4
0058E6  780214     MOV [W4], W4
0058E8  370007     BRA 0x58F8
413:               	}
414:               	return PWMValue[8];
0058F6  805644     MOV 0xAC8, W4
415:               }
0058F8  780004     MOV W4, W0
0058FA  FA8000     ULNK
0058FC  060000     RETURN
416:               
417:               void FineRegVentil(int SpeedLimit)
418:               {	int EvapErr = 0;
0058FE  FA0004     LNK #0x4
005900  980710     MOV W0, [W14+2]
005902  EB0200     CLR W4
005904  780F04     MOV W4, [W14]
419:               	static int AbilCambioVentola =0;
420:               
421:               
422:               	if(Me.Pwm_Req == PWMValue[0])
005906  805C75     MOV 0xB8E, W5
005908  8055C4     MOV PWMValue, W4
00590A  528F84     SUB W5, W4, [W15]
00590C  3A0002     BRA NZ, 0x5912
423:               		Me.Pwm_Req = PWMValue[1];
00590E  8055D4     MOV 0xABA, W4
005910  885C74     MOV W4, 0xB8E
424:               
425:               	if(RefreshFineVentil.TimeOut)
005912  805744     MOV 0xAE8, W4
005914  620262     AND W4, #0x2, W4
005916  520FE0     SUB W4, #0x0, [W15]
005918  320071     BRA Z, 0x59FC
426:               	{
427:               		RefreshFineVentil.TimeOut =0;
00591A  A92AE8     BCLR 0xAE8, #1
428:               		RefreshFineVentil.Value = 0;
00591C  EB0200     CLR W4
00591E  885724     MOV W4, RefreshFineVentil
429:               
430:               		if((Me.Function_Mode == CoreRiscaldamento) | (Me.Function_Mode == CoreSlaveCaldo))		// Se deve riscaldare
005920  805C24     MOV 0xB84, W4
005922  A22004     BTG W4, #2
005924  A7F004     BTSC W4, #15
005926  EA0204     NEG W4, W4
005928  E90204     DEC W4, W4
00592A  DE224F     LSR W4, #15, W4
00592C  784284     MOV.B W4, W5
00592E  805C24     MOV 0xB84, W4
005930  6A0271     XOR W4, #0x11, W4
005932  A7F004     BTSC W4, #15
005934  EA0204     NEG W4, W4
005936  E90204     DEC W4, W4
005938  DE224F     LSR W4, #15, W4
00593A  784204     MOV.B W4, W4
00593C  72C204     IOR.B W5, W4, W4
00593E  524FE0     SUB.B W4, #0x0, [W15]
005940  320006     BRA Z, 0x594E
431:               			{
432:               			EvapErr = (Me.Evap_Temp - Me.Temp_AirOut);
005942  805BF5     MOV 0xB7E, W5
005944  805B74     MOV 0xB6E, W4
005946  528F04     SUB W5, W4, [W14]
433:               			AbilCambioVentola = 1;
005948  200014     MOV #0x1, W4
00594A  887B24     MOV W4, AbilCambioVentola
00594C  37001B     BRA 0x5984
434:               			}
435:               		else if((Me.Function_Mode == CoreRaffrescamento) | (Me.Function_Mode == CoreSlaveFreddo))	// Se deve raffrescare
00594E  805C24     MOV 0xB84, W4
005950  A23004     BTG W4, #3
005952  A7F004     BTSC W4, #15
005954  EA0204     NEG W4, W4
005956  E90204     DEC W4, W4
005958  DE224F     LSR W4, #15, W4
00595A  784284     MOV.B W4, W5
00595C  805C24     MOV 0xB84, W4
00595E  6A0272     XOR W4, #0x12, W4
005960  A7F004     BTSC W4, #15
005962  EA0204     NEG W4, W4
005964  E90204     DEC W4, W4
005966  DE224F     LSR W4, #15, W4
005968  784204     MOV.B W4, W4
00596A  72C204     IOR.B W5, W4, W4
00596C  524FE0     SUB.B W4, #0x0, [W15]
00596E  320006     BRA Z, 0x597C
436:               			{
437:               			EvapErr = (Me.Temp_AirOut - Me.Evap_Temp);//(Me.Evap_Temp + 500));
005970  805B75     MOV 0xB6E, W5
005972  805BF4     MOV 0xB7E, W4
005974  528F04     SUB W5, W4, [W14]
438:                           /*
439:               			if(Me.Temp_Big > (Me.Temp_Small+1000))
440:               				AbilCambioVentola = 0;
441:               			else
442:               				AbilCambioVentola = 1;
443:                           */
444:                           AbilCambioVentola = 1;
005976  200014     MOV #0x1, W4
005978  887B24     MOV W4, AbilCambioVentola
00597A  370004     BRA 0x5984
445:               			}
446:               		else											// se sono in altre condizioni (ventilazione)
447:               			{
448:               			EvapErr = -300;
00597C  2FED44     MOV #0xFED4, W4
00597E  780F04     MOV W4, [W14]
449:               			AbilCambioVentola = 1;
005980  200014     MOV #0x1, W4
005982  887B24     MOV W4, AbilCambioVentola
450:               			}
451:               			
452:               			if(EvapErr > 1600)				// 1600
005984  206404     MOV #0x640, W4
005986  78029E     MOV [W14], W5
005988  528F84     SUB W5, W4, [W15]
00598A  340003     BRA LE, 0x5992
453:               				Me.Pwm_Req = PWMValue[1];
00598C  8055D4     MOV 0xABA, W4
00598E  885C74     MOV W4, 0xB8E
005990  37002F     BRA 0x59F0
454:               			else
455:               			if(AbilCambioVentola == 1)
005992  807B24     MOV AbilCambioVentola, W4
005994  520FE1     SUB W4, #0x1, [W15]
005996  3A002C     BRA NZ, 0x59F0
456:               			{
457:               				if(EvapErr > 2000)               	// 1200
005998  207D04     MOV #0x7D0, W4
00599A  78029E     MOV [W14], W5
00599C  528F84     SUB W5, W4, [W15]
00599E  340003     BRA LE, 0x59A6
458:               					Me.Pwm_Req = PWMValue[2];
0059A0  8055E4     MOV 0xABC, W4
0059A2  885C74     MOV W4, 0xB8E
0059A4  370025     BRA 0x59F0
459:               				else if(EvapErr > 1800)          	// 1200
0059A6  207084     MOV #0x708, W4
0059A8  78029E     MOV [W14], W5
0059AA  528F84     SUB W5, W4, [W15]
0059AC  340003     BRA LE, 0x59B4
460:               					Me.Pwm_Req = PWMValue[3];
0059AE  8055F4     MOV 0xABE, W4
0059B0  885C74     MOV W4, 0xB8E
0059B2  37001E     BRA 0x59F0
461:               				else if(EvapErr > 1600)          	// 1000
0059B4  206404     MOV #0x640, W4
0059B6  78029E     MOV [W14], W5
0059B8  528F84     SUB W5, W4, [W15]
0059BA  340003     BRA LE, 0x59C2
462:               					Me.Pwm_Req = PWMValue[4];
0059BC  805604     MOV 0xAC0, W4
0059BE  885C74     MOV W4, 0xB8E
0059C0  370017     BRA 0x59F0
463:               				else if(EvapErr > 1400)          	// 800
0059C2  205784     MOV #0x578, W4
0059C4  78029E     MOV [W14], W5
0059C6  528F84     SUB W5, W4, [W15]
0059C8  340003     BRA LE, 0x59D0
464:               					Me.Pwm_Req = PWMValue[5];
0059CA  805614     MOV 0xAC2, W4
0059CC  885C74     MOV W4, 0xB8E
0059CE  370010     BRA 0x59F0
465:               				else if(EvapErr > 1200)              // 600
0059D0  204B04     MOV #0x4B0, W4
0059D2  78029E     MOV [W14], W5
0059D4  528F84     SUB W5, W4, [W15]
0059D6  340003     BRA LE, 0x59DE
466:               					Me.Pwm_Req = PWMValue[6];
0059D8  805624     MOV 0xAC4, W4
0059DA  885C74     MOV W4, 0xB8E
0059DC  370009     BRA 0x59F0
467:               				else if(EvapErr > 1000)              // 400
0059DE  203E84     MOV #0x3E8, W4
0059E0  78029E     MOV [W14], W5
0059E2  528F84     SUB W5, W4, [W15]
0059E4  340003     BRA LE, 0x59EC
468:               					Me.Pwm_Req = PWMValue[7];
0059E6  805634     MOV 0xAC6, W4
0059E8  885C74     MOV W4, 0xB8E
0059EA  370002     BRA 0x59F0
469:               				else
470:               					Me.Pwm_Req = PWMValue[8];
0059EC  805644     MOV 0xAC8, W4
0059EE  885C74     MOV W4, 0xB8E
471:               			}
472:               /*		if(EvapErr > 200)
473:               			Decrementa(&(Me.Pwm_Req), 5, PWMValue[1]);
474:               		else if(EvapErr < -200)
475:               			Incrementa(&(Me.Pwm_Req), 5, SpeedLimit);	*/
476:               	
477:               
478:               		if(Me.Pwm_Req > SpeedLimit)
0059F0  805C75     MOV 0xB8E, W5
0059F2  90021E     MOV [W14+2], W4
0059F4  528F84     SUB W5, W4, [W15]
0059F6  340002     BRA LE, 0x59FC
479:               			Me.Pwm_Req = SpeedLimit;
0059F8  90021E     MOV [W14+2], W4
0059FA  885C74     MOV W4, 0xB8E
480:               	}
481:               }
0059FC  FA8000     ULNK
0059FE  060000     RETURN
482:               
483:               void ControlloVentil(void)
484:               {	if(Me.Pwm_Value >= PWMValue[1])
005A00  FA0000     LNK #0x0
005A02  805C85     MOV 0xB90, W5
005A04  8055D4     MOV 0xABA, W4
005A06  528F84     SUB W5, W4, [W15]
005A08  35000E     BRA LT, 0x5A26
485:               		Me.Error.Fan_Fault = (Me.Fan_Tacho == 0);
005A0A  805C94     MOV 0xB92, W4
005A0C  A7F004     BTSC W4, #15
005A0E  EA0204     NEG W4, W4
005A10  E90204     DEC W4, W4
005A12  DE224F     LSR W4, #15, W4
005A14  784204     MOV.B W4, W4
005A16  FB8204     ZE W4, W4
005A18  620261     AND W4, #0x1, W4
005A1A  DD2245     SL W4, #5, W4
005A1C  805D66     MOV 0xBAC, W6
005A1E  2FFDF5     MOV #0xFFDF, W5
005A20  630285     AND W6, W5, W5
005A22  720205     IOR W4, W5, W4
005A24  885D64     MOV W4, 0xBAC
486:               }
005A26  FA8000     ULNK
005A28  060000     RETURN
487:               
488:               void Tacho_Init(void)
489:               {
005A2A  FA0000     LNK #0x0
490:               	T3CON = 0;				// Resetto il registro di controllo		
005A2C  EB0200     CLR W4
005A2E  880894     MOV W4, T3CON
491:               	T3CONbits.TSIDL = 0;	// Setto il modulo per lavorare anche in idle mode
005A30  A9A113     BCLR 0x113, #5
492:               	T3CONbits.TCKPS = 0;	// Setto il prescaler 0=>1; 1=>8; 2=>64; 3=>256
005A32  800894     MOV T3CON, W4
005A34  A14004     BCLR W4, #4
005A36  A15004     BCLR W4, #5
005A38  880894     MOV W4, T3CON
493:               	T3CONbits.TCS = 1;		// seto la sorgente del clock esterna
005A3A  A82112     BSET T3CON, #1
494:               	T3CONbits.TON = 1;		// Setto a modalita di lettura e scrittura @ 16bit
005A3C  A8E113     BSET 0x113, #7
495:               
496:               	IFS0bits.T3IF = 0;		// resetto il flag del TMR2
005A3E  A90085     BCLR 0x85, #0
497:               	IPC2bits.T3IP = 2;		// imposto la priorità al massimo
005A40  800544     MOV IPC2, W4
005A42  A10004     BCLR W4, #0
005A44  A01004     BSET W4, #1
005A46  A12004     BCLR W4, #2
005A48  880544     MOV W4, IPC2
498:               	IEC0bits.T3IE = 0;		// siabilito l'interrupt
005A4A  A90095     BCLR 0x95, #0
499:               }
005A4C  FA8000     ULNK
005A4E  060000     RETURN
500:               
501:               void TachoInterrupt(void)
502:               {
005A50  FA0000     LNK #0x0
503:               	TimerTacho +=1;	// incremento il contatore
005A52  8056E4     MOV TimerTacho, W4
005A54  E80204     INC W4, W4
005A56  8856E4     MOV W4, TimerTacho
504:               	if(TimerTacho > 999)
005A58  8056E5     MOV TimerTacho, W5
005A5A  203E74     MOV #0x3E7, W4
005A5C  528F84     SUB W5, W4, [W15]
005A5E  360008     BRA LEU, 0x5A70
505:               	{
506:               		TachoTMR = TMR3;
005A60  800854     MOV TMR3, W4
005A62  8856D4     MOV W4, TachoTMR
507:               		TMR3 = 0;
005A64  EB0200     CLR W4
005A66  880854     MOV W4, TMR3
508:               		TimerTacho = 0;
005A68  EB0200     CLR W4
005A6A  8856E4     MOV W4, TimerTacho
509:               		FlagTachoUpdateRequest = 1;
005A6C  200014     MOV #0x1, W4
005A6E  885754     MOV W4, FlagTachoUpdateRequest
510:               	}
511:               }
005A70  FA8000     ULNK
005A72  060000     RETURN
512:               
513:               void RefreshTacho(void)
514:               {
005A74  FA0000     LNK #0x0
515:               	if(FlagTachoUpdateRequest)
005A76  805754     MOV FlagTachoUpdateRequest, W4
005A78  520FE0     SUB W4, #0x0, [W15]
005A7A  320004     BRA Z, 0x5A84
516:               		Me.Fan_Tacho = TachoTMR *30;
005A7C  8056D4     MOV TachoTMR, W4
005A7E  B9227E     MUL.SU W4, #30, W4
005A80  780204     MOV W4, W4
005A82  885C94     MOV W4, 0xB92
517:               }
005A84  FA8000     ULNK
005A86  060000     RETURN
518:               
519:               /*  *****************************************************************************************************************************
520:               	Gestico l'incremento di una variabile
521:               	***************************************************************************************************************************** */
522:               unsigned char Incrementa(int * Variabile, int Value, int Max)
523:               {
005A88  FA0006     LNK #0x6
005A8A  780F00     MOV W0, [W14]
005A8C  980711     MOV W1, [W14+2]
005A8E  980722     MOV W2, [W14+4]
524:               	if(((*Variabile) + Value) <  Max)	// verifico se posso incrementare senza sfondare il limite massimo
005A90  78021E     MOV [W14], W4
005A92  780294     MOV [W4], W5
005A94  90021E     MOV [W14+2], W4
005A96  428284     ADD W5, W4, W5
005A98  90022E     MOV [W14+4], W4
005A9A  528F84     SUB W5, W4, [W15]
005A9C  3D0008     BRA GE, 0x5AAE
525:               	{	
526:               		(*Variabile) += Value;			// incremento
005A9E  78021E     MOV [W14], W4
005AA0  780294     MOV [W4], W5
005AA2  90021E     MOV [W14+2], W4
005AA4  428284     ADD W5, W4, W5
005AA6  78021E     MOV [W14], W4
005AA8  780A05     MOV W5, [W4]
527:               		return 1;						// ritorno che ho modificato il valore
005AAA  B3C014     MOV.B #0x1, W4
005AAC  370018     BRA 0x5ADE
528:               	}
529:               	else								// altrimenti se non sono nelle condizioni ideali
530:               	{
531:               		if((*Variabile) < Max)			// verifico se la variabile è m inore del massimo
005AAE  78021E     MOV [W14], W4
005AB0  780294     MOV [W4], W5
005AB2  90022E     MOV [W14+4], W4
005AB4  528F84     SUB W5, W4, [W15]
005AB6  3D0005     BRA GE, 0x5AC2
532:               		{
533:               			(*Variabile) = Max;			// quindi la setto al massimo
005AB8  78021E     MOV [W14], W4
005ABA  9002AE     MOV [W14+4], W5
005ABC  780A05     MOV W5, [W4]
534:               			return 1;					// e ritorno la modifica del valore
005ABE  B3C014     MOV.B #0x1, W4
005AC0  37000E     BRA 0x5ADE
535:               		}
536:               		else if((*Variabile) > Max)		// altrimenti controllo se è già al di sopra del valore massimo
005AC2  78021E     MOV [W14], W4
005AC4  780294     MOV [W4], W5
005AC6  90022E     MOV [W14+4], W4
005AC8  528F84     SUB W5, W4, [W15]
005ACA  340008     BRA LE, 0x5ADC
537:               		{
538:               			(*Variabile) -= Value;		// e gli sottraggo il valore di variazione
005ACC  78021E     MOV [W14], W4
005ACE  780294     MOV [W4], W5
005AD0  90021E     MOV [W14+2], W4
005AD2  528284     SUB W5, W4, W5
005AD4  78021E     MOV [W14], W4
005AD6  780A05     MOV W5, [W4]
539:               			return 1;
005AD8  B3C014     MOV.B #0x1, W4
005ADA  370001     BRA 0x5ADE
540:               		}
541:               		else
542:               			return 0;					// altrimenti sono esattamente a minimo e non modifico nulla
005ADC  EB4200     CLR.B W4
543:               	}
544:               }
005ADE  784004     MOV.B W4, W0
005AE0  FA8000     ULNK
005AE2  060000     RETURN
545:               
546:               /*  *****************************************************************************************************************************
547:               	Gestico il decremento di una variabile
548:               	***************************************************************************************************************************** */
549:               unsigned char Decrementa(int * Variabile, int Value, int Min)
550:               {
005AE4  FA0006     LNK #0x6
005AE6  780F00     MOV W0, [W14]
005AE8  980711     MOV W1, [W14+2]
005AEA  980722     MOV W2, [W14+4]
551:               	if(((*Variabile) - Value) > Min)	// verifico se posso decrementare senza sfondare il limite minimo
005AEC  78021E     MOV [W14], W4
005AEE  780294     MOV [W4], W5
005AF0  90021E     MOV [W14+2], W4
005AF2  528284     SUB W5, W4, W5
005AF4  90022E     MOV [W14+4], W4
005AF6  528F84     SUB W5, W4, [W15]
005AF8  340008     BRA LE, 0x5B0A
552:               	{	
553:               		(*Variabile) -= Value;			// decremento 
005AFA  78021E     MOV [W14], W4
005AFC  780294     MOV [W4], W5
005AFE  90021E     MOV [W14+2], W4
005B00  528284     SUB W5, W4, W5
005B02  78021E     MOV [W14], W4
005B04  780A05     MOV W5, [W4]
554:               		return 1;						// ritorno che ho modificato il valore
005B06  B3C014     MOV.B #0x1, W4
005B08  370018     BRA 0x5B3A
555:               	}
556:               	else								// altrimenti se non sono nelle condizioni ideali
557:               	{
558:               		if((*Variabile) > Min)			// verifico se la variabile è maggiore del minimo
005B0A  78021E     MOV [W14], W4
005B0C  780294     MOV [W4], W5
005B0E  90022E     MOV [W14+4], W4
005B10  528F84     SUB W5, W4, [W15]
005B12  340005     BRA LE, 0x5B1E
559:               		{
560:               			(*Variabile) = Min;			// quindi la setto al minimo
005B14  78021E     MOV [W14], W4
005B16  9002AE     MOV [W14+4], W5
005B18  780A05     MOV W5, [W4]
561:               			return 1;					// e ritorno la modifica del valore
005B1A  B3C014     MOV.B #0x1, W4
005B1C  37000E     BRA 0x5B3A
562:               		}
563:               		else if((*Variabile) < Min)		// altrimenti controllo se è già al di sotto del valore minimo
005B1E  78021E     MOV [W14], W4
005B20  780294     MOV [W4], W5
005B22  90022E     MOV [W14+4], W4
005B24  528F84     SUB W5, W4, [W15]
005B26  3D0008     BRA GE, 0x5B38
564:               		{
565:               			(*Variabile) += Value;		// e gli sommo il valore di variazione
005B28  78021E     MOV [W14], W4
005B2A  780294     MOV [W4], W5
005B2C  90021E     MOV [W14+2], W4
005B2E  428284     ADD W5, W4, W5
005B30  78021E     MOV [W14], W4
005B32  780A05     MOV W5, [W4]
566:               			return 1;
005B34  B3C014     MOV.B #0x1, W4
005B36  370001     BRA 0x5B3A
567:               		}
568:               		else
569:               			return 0;					// altrimenti sono esattamente a minimo e non modifico nulla
005B38  EB4200     CLR.B W4
570:               	}
571:               }
005B3A  784004     MOV.B W4, W0
005B3C  FA8000     ULNK
005B3E  060000     RETURN
---  D:/WORK3/Lavori/TERMODINAMICA/Work/FW/1 - Generico/Split/Split v.8.4.22 - Working/PID.c  -----------
1:                 
2:                 #include "PID.h"
3:                 #include "Core.h"
4:                 
5:                 /*********************************************************************************************************************
6:                 
7:                 		PPPP	IIIII	DDDD
8:                 		P   P	  I		D   D
9:                 		PPPP	  I		D   D
10:                		P		  I 	D   D
11:                		P		IIIII	DDDD						 
12:                
13:                **********************************************************************************************************************
14:                										 ___  
15:                										|	| 
16:                									.-->|Pp |---------. 
17:                									|	|___|		  |	
18:                									|				+ |	
19:                							 ___	|	 ___		 _|_	
20:                						    /   \	|	|	|	    /   \	
21:                		----SetPoint------>| SUM |--|-->|Pi |----->| SUM |------PVal----->Process (Valve step)
22:                						+	\___/	|	|___|	+	\___/					 |
23:                							  ^		|				  ^						 |
24:                							- | 	|	 ___  		+ | 					 |
25:                							  |		|	|	|		  |						 |
26:                							  |		'-->|Pd |---------'					 	 |
27:                							  |			|___|							.---\_/---.
28:                							  |											| Process |
29:                							  '-------RetVal----------------------------|  Effect |	
30:                																		'---------'
31:                
32:                
33:                PID => controllo Proporzionale-Integrale-Derivativo:
34:                
35:                k = campione ingresso attuale
36:                k-1 = campione ingresso precedente
37:                Pp = parte proporzionale
38:                Pi = parte integrale
39:                Pd = parte derivativa
40:                Kp = Guadagno parte proporzionale
41:                Ki = Guadagno parte integrale
42:                Kd = Guadagno parte derivativa
43:                SetP = SetPoint							(Calcolo superheat??? = Temperatura aria uscita - temperatura convertita da pressione)
44:                RetVal = Valore Retroazione di Processo (??? Cosa utilizzare)
45:                Err = errore 
46:                PVal = uscita PID						(Pilotaggio Valvola espansione)
47:                
48:                
49:                Err = SetP - RetVal;
50:                
51:                Pp(k) = Kp * Err(k)						=> Uscita Parte proporzionale = Guadagno proporzionale * Errore attuale
52:                Pi(k) = Ki * Err(k) + Pi(k-1)			=> Uscita Parte integrale = Guadagno integrale * Errore attuale + Parte integrale precedente
53:                Pd(k) = Kd * [Err(k) - Err(k-1)]		=> Uscita Parte derivativa = Guadagno derivativo * (Errore attuale - Errore precedente)
54:                
55:                PVal(k) = Pp(k) + Pi(k) + Pd(k)			=> Uscita PID = Parte proporzionale + Parte integrale + Parte derivativa
56:                
57:                
58:                Metodo Ziegler?Nichols per la determinazione dei parametri PID:
59:                
60:                Iniziare la taratura impostando Ki e Kd = 0
61:                Aumentare gradualmente Kp (partendo da un valore relativamente basso es. 0.1).
62:                Simulare un transitorio a gradino in ingresso (relativamente sostenuto es. MinIn..MaxIn).
63:                Aumentare il valore di Kp fino ad ottenere un'oscillazione dell'uscita sostenuta ma non instabile (non devono sparire dopo un transitorio).
64:                Una volta deterninato il valore di Kp, ricavare i valori di Ki e Kd dalla seguente tabella (Ziegler?Nichols).
65:                
66:                Tipo		Kp				Ki					Kd
67:                P			0.50 * Ku		-					-
68:                PI			0.45 * Ku		1.2 * Kp / Pu		-
69:                PID			0.60 * Ku		2 * Kp / Pu			Kp * Pu / 8
70:                
71:                Nota:
72:                Ku = è il valore del guadagno per cui la variabile controllata presenta oscillazioni sostenute.
73:                Pu = è il periodo critico delle oscillazioni sostenute;
74:                
75:                                | Pu  |
76:                        _       |     |
77:                       | |      _     _     _
78:                      |   |    | |   | |   | |   _   ______________
79:                     |     |__|   |_|   |_|   |_| |_|
80:                    |
81:                   |		
82:                  |	
83:                 |
84:                ----------------------------------------------------------
85:                
86:                **********************************************************************************************************************/
87:                //---------------------------------------------------------------------------------------------
88:                // Trasforma l'uscita del PID nella scala e con la direzione corretta per la gestione della 
89:                // valvola di espansione
90:                //---------------------------------------------------------------------------------------------
91:                int PIDOut2Valve(int OutPID, int ValMinIn, int ValMaxIn, int ValMinOut, int ValMaxOut)
92:                {
007D3E  FA000E     LNK #0xE
007D40  BE9F88     MOV.D W8, [W15++]
007D42  980720     MOV W0, [W14+4]
007D44  980731     MOV W1, [W14+6]
007D46  980742     MOV W2, [W14+8]
007D48  980753     MOV W3, [W14+10]
007D4A  980764     MOV W4, [W14+12]
93:                	float div;
94:                	
95:                	div = (float)(ValMaxIn-ValMinIn) / (float)(ValMaxOut-ValMinOut);
007D4C  9002CE     MOV [W14+8], W5
007D4E  90023E     MOV [W14+6], W4
007D50  528204     SUB W5, W4, W4
007D52  DEA2CF     ASR W4, #15, W5
007D54  BE0004     MOV.D W4, W0
007D56  07C3B3     RCALL ___floatsisf
007D58  BE0400     MOV.D W0, W8
007D5A  9002EE     MOV [W14+12], W5
007D5C  90025E     MOV [W14+10], W4
007D5E  528204     SUB W5, W4, W4
007D60  DEA2CF     ASR W4, #15, W5
007D62  BE0004     MOV.D W4, W0
007D64  07C3AC     RCALL ___floatsisf
007D66  BE0200     MOV.D W0, W4
007D68  BE0104     MOV.D W4, W2
007D6A  BE0008     MOV.D W8, W0
007D6C  07C326     RCALL ___divsf3
007D6E  BE0200     MOV.D W0, W4
007D70  BE8F04     MOV.D W4, [W14]
96:                  
97:                	return ValMaxOut-((int)((float)OutPID / div));
007D72  90022E     MOV [W14+4], W4
007D74  DEA2CF     ASR W4, #15, W5
007D76  BE0004     MOV.D W4, W0
007D78  07C3A2     RCALL ___floatsisf
007D7A  BE0200     MOV.D W0, W4
007D7C  BE011E     MOV.D [W14], W2
007D7E  BE0004     MOV.D W4, W0
007D80  07C31C     RCALL ___divsf3
007D82  BE0200     MOV.D W0, W4
007D84  BE0004     MOV.D W4, W0
007D86  07C35F     RCALL ___fixsfsi
007D88  BE0200     MOV.D W0, W4
007D8A  780204     MOV W4, W4
007D8C  9002EE     MOV [W14+12], W5
007D8E  528204     SUB W5, W4, W4
98:                
99:                }
007D90  780004     MOV W4, W0
007D92  BE044F     MOV.D [--W15], W8
007D94  FA8000     ULNK
007D96  060000     RETURN
100:               
101:               //---------------------------------------------------------------------------------------------
102:               // Calcola l'uscita del PID partendo dal valore di regoalzione della valvola
103:               //---------------------------------------------------------------------------------------------
104:               int Valve2PIDOut(int OutValve, int ValMinIn, int ValMaxIn, int ValMinOut, int ValMaxOut)
105:               {
007D98  FA000E     LNK #0xE
007D9A  BE9F88     MOV.D W8, [W15++]
007D9C  980720     MOV W0, [W14+4]
007D9E  980731     MOV W1, [W14+6]
007DA0  980742     MOV W2, [W14+8]
007DA2  980753     MOV W3, [W14+10]
007DA4  980764     MOV W4, [W14+12]
106:               	float mul;
107:               	
108:               	mul = (float)(ValMaxIn-ValMinIn) / (float)(ValMaxOut-ValMinOut);
007DA6  9002CE     MOV [W14+8], W5
007DA8  90023E     MOV [W14+6], W4
007DAA  528204     SUB W5, W4, W4
007DAC  DEA2CF     ASR W4, #15, W5
007DAE  BE0004     MOV.D W4, W0
007DB0  07C386     RCALL ___floatsisf
007DB2  BE0400     MOV.D W0, W8
007DB4  9002EE     MOV [W14+12], W5
007DB6  90025E     MOV [W14+10], W4
007DB8  528204     SUB W5, W4, W4
007DBA  DEA2CF     ASR W4, #15, W5
007DBC  BE0004     MOV.D W4, W0
007DBE  07C37F     RCALL ___floatsisf
007DC0  BE0200     MOV.D W0, W4
007DC2  BE0104     MOV.D W4, W2
007DC4  BE0008     MOV.D W8, W0
007DC6  07C2F9     RCALL ___divsf3
007DC8  BE0200     MOV.D W0, W4
007DCA  BE8F04     MOV.D W4, [W14]
109:                 
110:               	return ValMaxIn-((int)((float)OutValve * mul));
007DCC  90022E     MOV [W14+4], W4
007DCE  DEA2CF     ASR W4, #15, W5
007DD0  BE0004     MOV.D W4, W0
007DD2  07C375     RCALL ___floatsisf
007DD4  BE0200     MOV.D W0, W4
007DD6  BE011E     MOV.D [W14], W2
007DD8  BE0004     MOV.D W4, W0
007DDA  07C420     RCALL ___mulsf3
007DDC  BE0200     MOV.D W0, W4
007DDE  BE0004     MOV.D W4, W0
007DE0  07C332     RCALL ___fixsfsi
007DE2  BE0200     MOV.D W0, W4
007DE4  780204     MOV W4, W4
007DE6  9002CE     MOV [W14+8], W5
007DE8  528204     SUB W5, W4, W4
111:               
112:               }
007DEA  780004     MOV W4, W0
007DEC  BE044F     MOV.D [--W15], W8
007DEE  FA8000     ULNK
007DF0  060000     RETURN
113:               
114:               //---------------------------------------------------------------------------------------------
115:               // Imposta il valore di uscita iniziale del PID per avere un pilotaggio valvola di partenza
116:               // Valore in ingresso: valore posizione valvola
117:               //--------------------------------------------------------------------------------------------- 
118:               void PID_SetOut(TypPID * pid, int SetValveOut) 
119:               { 
007DF2  FA0004     LNK #0x4
007DF4  780F00     MOV W0, [W14]
007DF6  980711     MOV W1, [W14+2]
120:               	pid->iState = Valve2PIDOut(SetValveOut, K_PoMin, K_PoMax, K_ValveMin, K_ValveMax);	// Inizializza la memoria integrale PID con il valore di partenza 
007DF8  203C04     MOV #0x3C0, W4
007DFA  200143     MOV #0x14, W3
007DFC  2251C2     MOV #0x251C, W2
007DFE  EB0080     CLR W1
007E00  90001E     MOV [W14+2], W0
007E02  07FFCA     RCALL Valve2PIDOut
007E04  780200     MOV W0, W4
007E06  DEA2CF     ASR W4, #15, W5
007E08  BE0004     MOV.D W4, W0
007E0A  07C359     RCALL ___floatsisf
007E0C  BE0200     MOV.D W0, W4
007E0E  78031E     MOV [W14], W6
007E10  980374     MOV W4, [W6+14]
007E12  980B05     MOV W5, [W6+16]
121:               }
007E14  FA8000     ULNK
007E16  060000     RETURN
122:               
123:               void PID_init(TypPID * pid, float p_gain, float i_gain, float d_gain, float i_Min, float i_Max, float Po_Min, float Po_Max, int dead_zone) 
124:               { 
007E18  FA0010     LNK #0x10
007E1A  780F00     MOV W0, [W14]
007E1C  980712     MOV W2, [W14+2]
007E1E  980723     MOV W3, [W14+4]
007E20  980734     MOV W4, [W14+6]
007E22  980745     MOV W5, [W14+8]
007E24  980756     MOV W6, [W14+10]
007E26  980767     MOV W7, [W14+12]
007E28  980771     MOV W1, [W14+14]
125:               	pid->iMax = i_Max;				// Maximum and minimum allowable integrator state
007E2A  78021E     MOV [W14], W4
007E2C  97BB1E     MOV [W14-14], W6
007E2E  97BBAE     MOV [W14-12], W7
007E30  980A36     MOV W6, [W4+22]
007E32  980A47     MOV W7, [W4+24]
126:               	pid->iMin = i_Min;  		
007E34  78021E     MOV [W14], W4
007E36  97BB3E     MOV [W14-10], W6
007E38  97BBCE     MOV [W14-8], W7
007E3A  980A56     MOV W6, [W4+26]
007E3C  980A67     MOV W7, [W4+28]
127:               	pid->PoMax = Po_Max;			// Maximum and minimum allowable integrator state
007E3E  78021E     MOV [W14], W4
007E40  97B35E     MOV [W14-22], W6
007E42  97B3EE     MOV [W14-20], W7
007E44  980A76     MOV W6, [W4+30]
007E46  981207     MOV W7, [W4+32]
128:               	pid->PoMin = Po_Min;  
007E48  78021E     MOV [W14], W4
007E4A  97B37E     MOV [W14-18], W6
007E4C  97BB8E     MOV [W14-16], W7
007E4E  981216     MOV W6, [W4+34]
007E50  981227     MOV W7, [W4+36]
129:               
130:               	pid->pGain = p_gain;    		// proportional gain
007E52  78021E     MOV [W14], W4
007E54  90031E     MOV [W14+2], W6
007E56  9003AE     MOV [W14+4], W7
007E58  981256     MOV W6, [W4+42]
007E5A  981267     MOV W7, [W4+44]
131:               	pid->iGain = i_gain;			// integral gain
007E5C  78021E     MOV [W14], W4
007E5E  90033E     MOV [W14+6], W6
007E60  9003CE     MOV [W14+8], W7
007E62  981236     MOV W6, [W4+38]
007E64  981247     MOV W7, [W4+40]
132:               	pid->dGain = d_gain;     		// derivative gain
007E66  78021E     MOV [W14], W4
007E68  90035E     MOV [W14+10], W6
007E6A  9003EE     MOV [W14+12], W7
007E6C  981276     MOV W6, [W4+46]
007E6E  981A07     MOV W7, [W4+48]
133:               	pid->iState = 0;				// reset integral memory
007E70  78031E     MOV [W14], W6
007E72  B82260     MUL.UU W4, #0, W4
007E74  980374     MOV W4, [W6+14]
007E76  980B05     MOV W5, [W6+16]
134:               
135:               	pid->Error = 0;
007E78  78031E     MOV [W14], W6
007E7A  B82260     MUL.UU W4, #0, W4
007E7C  981B14     MOV W4, [W6+50]
007E7E  981B25     MOV W5, [W6+52]
136:               	pid->LastError = 0;
007E80  78031E     MOV [W14], W6
007E82  B82260     MUL.UU W4, #0, W4
007E84  981B34     MOV W4, [W6+54]
007E86  981B45     MOV W5, [W6+56]
137:               
138:               	pid->DeadZone = dead_zone;		// Dead zone
007E88  78021E     MOV [W14], W4
007E8A  9003FE     MOV [W14+14], W7
007E8C  980247     MOV W7, [W4+8]
139:               
140:               }      
007E8E  FA8000     ULNK
007E90  060000     RETURN
141:               
142:               
143:               void UpdatePID(TypPID * pid)
144:               {
007E92  FA0002     LNK #0x2
007E94  BE9F88     MOV.D W8, [W15++]
007E96  780F00     MOV W0, [W14]
145:                   
146:                   //DEBUG
147:                  // pid->iGain = pid->VKiPID;			// integral gain
148:               	//pid->pGain = pid->VKdPID;         
149:                   //DEBUG
150:               
151:                 pid->Error = pid->SetP - pid->RetVal;
007E98  78021E     MOV [W14], W4
007E9A  780294     MOV [W4], W5
007E9C  78021E     MOV [W14], W4
007E9E  900214     MOV [W4+2], W4
007EA0  528204     SUB W5, W4, W4
007EA2  DEA2CF     ASR W4, #15, W5
007EA4  BE0004     MOV.D W4, W0
007EA6  07C30B     RCALL ___floatsisf
007EA8  BE0200     MOV.D W0, W4
007EAA  78031E     MOV [W14], W6
007EAC  981B14     MOV W4, [W6+50]
007EAE  981B25     MOV W5, [W6+52]
152:               
153:               
154:                 pid->pState = pid->pGain * pid->Error;					// Calcolo la parte proporzionale						->	Pp(k) = Kp * Err(k)
007EB0  78021E     MOV [W14], W4
007EB2  901354     MOV [W4+42], W6
007EB4  9013E4     MOV [W4+44], W7
007EB6  78021E     MOV [W14], W4
007EB8  901AA4     MOV [W4+52], W5
007EBA  901A14     MOV [W4+50], W4
007EBC  BE0104     MOV.D W4, W2
007EBE  BE0006     MOV.D W6, W0
007EC0  07C3AD     RCALL ___mulsf3
007EC2  BE0200     MOV.D W0, W4
007EC4  78031E     MOV [W14], W6
007EC6  980354     MOV W4, [W6+10]
007EC8  980365     MOV W5, [W6+12]
155:               
156:                 pid->iState += pid->iGain * pid->Error;					// Calcolo la parte integrale e controllo limiti		->	Pi(k) = Ki * Err(k) + Pi(k-1)						
007ECA  78021E     MOV [W14], W4
007ECC  900474     MOV [W4+14], W8
007ECE  900C84     MOV [W4+16], W9
007ED0  78021E     MOV [W14], W4
007ED2  901334     MOV [W4+38], W6
007ED4  9013C4     MOV [W4+40], W7
007ED6  78021E     MOV [W14], W4
007ED8  901AA4     MOV [W4+52], W5
007EDA  901A14     MOV [W4+50], W4
007EDC  BE0104     MOV.D W4, W2
007EDE  BE0006     MOV.D W6, W0
007EE0  07C39D     RCALL ___mulsf3
007EE2  BE0200     MOV.D W0, W4
007EE4  BE0104     MOV.D W4, W2
007EE6  BE0008     MOV.D W8, W0
007EE8  07C20B     RCALL ___addsf3
007EEA  BE0200     MOV.D W0, W4
007EEC  78031E     MOV [W14], W6
007EEE  980374     MOV W4, [W6+14]
007EF0  980B05     MOV W5, [W6+16]
157:                
158:                 if (pid->iState > pid->iMax) 
007EF2  78021E     MOV [W14], W4
007EF4  900374     MOV [W4+14], W6
007EF6  900B84     MOV [W4+16], W7
007EF8  78021E     MOV [W14], W4
007EFA  900AC4     MOV [W4+24], W5
007EFC  900A34     MOV [W4+22], W4
007EFE  B3C018     MOV.B #0x1, W8
007F00  BE0104     MOV.D W4, W2
007F02  BE0006     MOV.D W6, W0
007F04  07C29E     RCALL ___gtsf2
007F06  780200     MOV W0, W4
007F08  520FE0     SUB W4, #0x0, [W15]
007F0A  3C0001     BRA GT, 0x7F0E
007F0C  EB4400     CLR.B W8
007F0E  544FE0     SUB.B W8, #0x0, [W15]
007F10  320007     BRA Z, 0x7F20
159:               	  pid->iState = pid->iMax;
007F12  78021E     MOV [W14], W4
007F14  900AC4     MOV [W4+24], W5
007F16  900A34     MOV [W4+22], W4
007F18  78031E     MOV [W14], W6
007F1A  980374     MOV W4, [W6+14]
007F1C  980B05     MOV W5, [W6+16]
007F1E  370016     BRA 0x7F4C
160:                 else if (pid->iState < pid->iMin) 
007F20  78021E     MOV [W14], W4
007F22  900374     MOV [W4+14], W6
007F24  900B84     MOV [W4+16], W7
007F26  78021E     MOV [W14], W4
007F28  900AE4     MOV [W4+28], W5
007F2A  900A54     MOV [W4+26], W4
007F2C  B3C018     MOV.B #0x1, W8
007F2E  BE0104     MOV.D W4, W2
007F30  BE0006     MOV.D W6, W0
007F32  07C285     RCALL ___lesf2
007F34  780200     MOV W0, W4
007F36  520FE0     SUB W4, #0x0, [W15]
007F38  350001     BRA LT, 0x7F3C
007F3A  EB4400     CLR.B W8
007F3C  544FE0     SUB.B W8, #0x0, [W15]
007F3E  320006     BRA Z, 0x7F4C
161:               	  pid->iState = pid->iMin;
007F40  78021E     MOV [W14], W4
007F42  900AE4     MOV [W4+28], W5
007F44  900A54     MOV [W4+26], W4
007F46  78031E     MOV [W14], W6
007F48  980374     MOV W4, [W6+14]
007F4A  980B05     MOV W5, [W6+16]
162:               
163:                 pid->dState = pid->dGain * (pid->Error - pid->LastError);	// Calcolo la parte derivativa							->	Pd(k) = Kd * [Err(k) - Err(k-1)]
007F4C  78021E     MOV [W14], W4
007F4E  901474     MOV [W4+46], W8
007F50  901C84     MOV [W4+48], W9
007F52  78021E     MOV [W14], W4
007F54  901B14     MOV [W4+50], W6
007F56  901BA4     MOV [W4+52], W7
007F58  78021E     MOV [W14], W4
007F5A  901AC4     MOV [W4+56], W5
007F5C  901A34     MOV [W4+54], W4
007F5E  BE0104     MOV.D W4, W2
007F60  BE0006     MOV.D W6, W0
007F62  07C1CD     RCALL ___subsf3
007F64  BE0200     MOV.D W0, W4
007F66  BE0104     MOV.D W4, W2
007F68  BE0008     MOV.D W8, W0
007F6A  07C358     RCALL ___mulsf3
007F6C  BE0200     MOV.D W0, W4
007F6E  78031E     MOV [W14], W6
007F70  980B14     MOV W4, [W6+18]
007F72  980B25     MOV W5, [W6+20]
164:               
165:                 pid->LastError = pid->Error;
007F74  78021E     MOV [W14], W4
007F76  901AA4     MOV [W4+52], W5
007F78  901A14     MOV [W4+50], W4
007F7A  78031E     MOV [W14], W6
007F7C  981B34     MOV W4, [W6+54]
007F7E  981B45     MOV W5, [W6+56]
166:               
167:                 pid->PVal = pid->pState + pid->iState + pid->dState;		// Calcolo uscita PID e controllo limiti				->	 PVal(k) = Pp(k) + Pi(k) + Pd(k)
007F80  78021E     MOV [W14], W4
007F82  900354     MOV [W4+10], W6
007F84  9003E4     MOV [W4+12], W7
007F86  78021E     MOV [W14], W4
007F88  900A84     MOV [W4+16], W5
007F8A  900274     MOV [W4+14], W4
007F8C  BE0104     MOV.D W4, W2
007F8E  BE0006     MOV.D W6, W0
007F90  07C1B7     RCALL ___addsf3
007F92  BE0200     MOV.D W0, W4
007F94  BE0304     MOV.D W4, W6
007F96  78021E     MOV [W14], W4
007F98  900AA4     MOV [W4+20], W5
007F9A  900A14     MOV [W4+18], W4
007F9C  BE0104     MOV.D W4, W2
007F9E  BE0006     MOV.D W6, W0
007FA0  07C1AF     RCALL ___addsf3
007FA2  BE0200     MOV.D W0, W4
007FA4  BE0004     MOV.D W4, W0
007FA6  07C24F     RCALL ___fixsfsi
007FA8  BE0200     MOV.D W0, W4
007FAA  780284     MOV W4, W5
007FAC  78021E     MOV [W14], W4
007FAE  980225     MOV W5, [W4+4]
168:               
169:                 pid->PValNoLim = pid->PVal;
007FB0  78021E     MOV [W14], W4
007FB2  9002A4     MOV [W4+4], W5
007FB4  78021E     MOV [W14], W4
007FB6  980235     MOV W5, [W4+6]
170:                 
171:                 if (pid->PVal > pid->PoMax) 
007FB8  78021E     MOV [W14], W4
007FBA  900224     MOV [W4+4], W4
007FBC  DEA2CF     ASR W4, #15, W5
007FBE  BE0004     MOV.D W4, W0
007FC0  07C27E     RCALL ___floatsisf
007FC2  BE0300     MOV.D W0, W6
007FC4  78021E     MOV [W14], W4
007FC6  901284     MOV [W4+32], W5
007FC8  900A74     MOV [W4+30], W4
007FCA  B3C018     MOV.B #0x1, W8
007FCC  BE0104     MOV.D W4, W2
007FCE  BE0006     MOV.D W6, W0
007FD0  07C238     RCALL ___gtsf2
007FD2  780200     MOV W0, W4
007FD4  520FE0     SUB W4, #0x0, [W15]
007FD6  3C0001     BRA GT, 0x7FDA
007FD8  EB4400     CLR.B W8
007FDA  544FE0     SUB.B W8, #0x0, [W15]
007FDC  32000A     BRA Z, 0x7FF2
172:               	  pid->PVal = pid->PoMax;
007FDE  78021E     MOV [W14], W4
007FE0  901284     MOV [W4+32], W5
007FE2  900A74     MOV [W4+30], W4
007FE4  BE0004     MOV.D W4, W0
007FE6  07C22F     RCALL ___fixsfsi
007FE8  BE0200     MOV.D W0, W4
007FEA  780284     MOV W4, W5
007FEC  78021E     MOV [W14], W4
007FEE  980225     MOV W5, [W4+4]
007FF0  37001C     BRA 0x802A
173:                 else if (pid->PVal < pid->PoMin) 
007FF2  78021E     MOV [W14], W4
007FF4  900224     MOV [W4+4], W4
007FF6  DEA2CF     ASR W4, #15, W5
007FF8  BE0004     MOV.D W4, W0
007FFA  07C261     RCALL ___floatsisf
007FFC  BE0300     MOV.D W0, W6
007FFE  78021E     MOV [W14], W4
008000  9012A4     MOV [W4+36], W5
008002  901214     MOV [W4+34], W4
008004  B3C018     MOV.B #0x1, W8
008006  BE0104     MOV.D W4, W2
008008  BE0006     MOV.D W6, W0
00800A  07C219     RCALL ___lesf2
00800C  780200     MOV W0, W4
00800E  520FE0     SUB W4, #0x0, [W15]
008010  350001     BRA LT, 0x8014
008012  EB4400     CLR.B W8
008014  544FE0     SUB.B W8, #0x0, [W15]
008016  320009     BRA Z, 0x802A
174:               	  pid->PVal = pid->PoMin;
008018  78021E     MOV [W14], W4
00801A  9012A4     MOV [W4+36], W5
00801C  901214     MOV [W4+34], W4
00801E  BE0004     MOV.D W4, W0
008020  07C212     RCALL ___fixsfsi
008022  BE0200     MOV.D W0, W4
008024  780284     MOV W4, W5
008026  78021E     MOV [W14], W4
008028  980225     MOV W5, [W4+4]
175:               }
00802A  BE044F     MOV.D [--W15], W8
00802C  FA8000     ULNK
00802E  060000     RETURN
176:               
177:               
178:               int Filter(TypFilter * fil, int Var2fil, int nsamples) 
179:               { 
008030  FA0006     LNK #0x6
008032  BE9F88     MOV.D W8, [W15++]
008034  780F00     MOV W0, [W14]
008036  980711     MOV W1, [W14+2]
008038  980722     MOV W2, [W14+4]
180:               	if(fil->SampleCounter==0) fil->SumVar=0;	// Se è il primo "giro" inizializzo la memoria dei campioni
00803A  78021E     MOV [W14], W4
00803C  780214     MOV [W4], W4
00803E  520FE0     SUB W4, #0x0, [W15]
008040  3A0004     BRA NZ, 0x804A
008042  78031E     MOV [W14], W6
008044  B82260     MUL.UU W4, #0, W4
008046  980314     MOV W4, [W6+2]
008048  980325     MOV W5, [W6+4]
181:               	
182:               	fil->SumVar += Var2fil;						// Sommo il campione attuale ai precedenti
00804A  78021E     MOV [W14], W4
00804C  900414     MOV [W4+2], W8
00804E  9004A4     MOV [W4+4], W9
008050  90021E     MOV [W14+2], W4
008052  DEA2CF     ASR W4, #15, W5
008054  BE0004     MOV.D W4, W0
008056  07C233     RCALL ___floatsisf
008058  BE0200     MOV.D W0, W4
00805A  BE0104     MOV.D W4, W2
00805C  BE0008     MOV.D W8, W0
00805E  07C150     RCALL ___addsf3
008060  BE0200     MOV.D W0, W4
008062  78031E     MOV [W14], W6
008064  980314     MOV W4, [W6+2]
008066  980325     MOV W5, [W6+4]
183:               	
184:               	fil->SampleCounter +=1;						// incremento il cnt dei campioni
008068  78021E     MOV [W14], W4
00806A  780214     MOV [W4], W4
00806C  E80284     INC W4, W5
00806E  78021E     MOV [W14], W4
008070  780A05     MOV W5, [W4]
185:               
186:               	if(fil->SampleCounter > nsamples)			// se ho oltrepassato la soglia dei campioni
008072  78021E     MOV [W14], W4
008074  780294     MOV [W4], W5
008076  90022E     MOV [W14+4], W4
008078  528F84     SUB W5, W4, [W15]
00807A  340013     BRA LE, 0x80A2
187:               	{	
188:               		fil->SampleCounter = nsamples;			// riscalo il numero dei campioni
00807C  78021E     MOV [W14], W4
00807E  9002AE     MOV [W14+4], W5
008080  780A05     MOV W5, [W4]
189:               		fil->SumVar -= fil->VarFiltered;		// sottraggo il campione medio dalla somma cumulativa
008082  78021E     MOV [W14], W4
008084  900414     MOV [W4+2], W8
008086  9004A4     MOV [W4+4], W9
008088  78021E     MOV [W14], W4
00808A  900234     MOV [W4+6], W4
00808C  DEA2CF     ASR W4, #15, W5
00808E  BE0004     MOV.D W4, W0
008090  07C216     RCALL ___floatsisf
008092  BE0200     MOV.D W0, W4
008094  BE0104     MOV.D W4, W2
008096  BE0008     MOV.D W8, W0
008098  07C132     RCALL ___subsf3
00809A  BE0200     MOV.D W0, W4
00809C  78031E     MOV [W14], W6
00809E  980314     MOV W4, [W6+2]
0080A0  980325     MOV W5, [W6+4]
190:               	}
191:               
192:               	if(fil->SampleCounter != 0)
0080A2  78021E     MOV [W14], W4
0080A4  780214     MOV [W4], W4
0080A6  520FE0     SUB W4, #0x0, [W15]
0080A8  320013     BRA Z, 0x80D0
193:               	{	
194:               		fil->VarFiltered = fil->SumVar / fil->SampleCounter; 
0080AA  78021E     MOV [W14], W4
0080AC  900414     MOV [W4+2], W8
0080AE  9004A4     MOV [W4+4], W9
0080B0  78021E     MOV [W14], W4
0080B2  780214     MOV [W4], W4
0080B4  DEA2CF     ASR W4, #15, W5
0080B6  BE0004     MOV.D W4, W0
0080B8  07C202     RCALL ___floatsisf
0080BA  BE0200     MOV.D W0, W4
0080BC  BE0104     MOV.D W4, W2
0080BE  BE0008     MOV.D W8, W0
0080C0  07C17C     RCALL ___divsf3
0080C2  BE0200     MOV.D W0, W4
0080C4  BE0004     MOV.D W4, W0
0080C6  07C1BF     RCALL ___fixsfsi
0080C8  BE0200     MOV.D W0, W4
0080CA  780284     MOV W4, W5
0080CC  78021E     MOV [W14], W4
0080CE  980235     MOV W5, [W4+6]
195:               	}		
196:               
197:               	return fil->VarFiltered;
0080D0  78021E     MOV [W14], W4
0080D2  900234     MOV [W4+6], W4
198:               }
0080D4  780004     MOV W4, W0
0080D6  BE044F     MOV.D [--W15], W8
0080D8  FA8000     ULNK
0080DA  060000     RETURN
199:               
200:               
201:               
---  D:/WORK3/Lavori/TERMODINAMICA/Work/FW/1 - Generico/Split/Split v.8.4.22 - Working/Main.c  ----------
1:                 //----------------------------------------------------------------------------------
2:                 //	Progect name:	Test 24FJ64A002
3:                 //	Device:			PIC24FJ64A002 @ 20Mhz
4:                 //	Auitor:			Emanuele
5:                 //	Date:			23/01/2011
6:                 //	Description:	Test del pic 24FJ64A002
7:                 //----------------------------------------------------------------------------------
8:                 
9:                 //----------------------------------------------------------------------------------
10:                //	Include
11:                //----------------------------------------------------------------------------------
12:                #include "MicroModelSelection.h"
13:                #ifdef GB210
14:                	#include <p24FJ256GB210.h>
15:                #else
16:                	#include <p24FJ256GB110.h>
17:                #endif
18:                #include <stdio.h>
19:                #include "ConfigDevice.h"
20:                #include "DefinePeriferiche.h"
21:                #include "ADC.h"
22:                #include "Timer.h"
23:                #include "Usart.h"
24:                #include "delay.h"
25:                #include "I2C.h"
26:                #include "EEPROM.h"
27:                #include "PWM.h"
28:                #include "Valvola_PassoPasso.h"
29:                #include "Driver_Comunicazione.h"
30:                #include "Driver_ComunicazioneSec.h"
31:                #include "Driver_ModBus.h"
32:                #include "ProtocolloComunicazione.h"
33:                #include "ProtocolloComunicazioneSec.h"
34:                #include "ProtocolloModBus.h"
35:                #include "Core.h"
36:                #include "PID.h"
37:                
38:                //----------------------------------------------------------------------------------
39:                //	DEFINE
40:                //----------------------------------------------------------------------------------
41:                //    #define     DEBUGSERIAL        1	// inserire questo define per escludere altre comunicazioni 
42:                
43:                //----------------------------------------------------------------------------------
44:                //	Variabili globali
45:                //----------------------------------------------------------------------------------
46:                VariabiliGlobaliADC();
47:                VariabiliGlobaliDriverComunicazione();
48:                VariabiliGlobaliDriverComunicazioneSec();
49:                VariabiliGlobaliDriverModBus();
50:                VariabiliGlobaliProtocolloComunicazione();
51:                VariabiliGlobaliProtocolloComunicazioneSec();
52:                VariabiliGlobaliProtocolloModBus();
53:                VariabiliGlobaliEEPROM();
54:                VariabiliGlobaliPWM();
55:                VariabiliGlobaliValvolaExp();
56:                VariabiliGlobaliCore();
57:                VariabiliGlobaliPID();
58:                
59:                // timer	
60:                volatile TypTimer TmrLastRequest;
61:                volatile TypTimer TimerStartUp;					// Timer StartUp
62:                volatile TypTimer RefreshPanelRead;
63:                volatile TypTimer TimerSystemCycle;			// Timer per il calcolo del tempo di ciclo programma
64:                //TypRTC	MyRTC;
65:                
66:                unsigned RTC_Flag = 1;
67:                volatile int SecDivider = 0;						// divisore per base tempo di 1 secondo
68:                //volatile int Elapsed = 0;						// divisore per base tempo di 1 secondo
69:                int Led_Divider = 0;					// divisore per il lampeggio del led
70:                char CntResumeTouch = 0;				// contatore per il resume dei touch
71:                char CntResumePanel = 0;				// contatore per il resume dei Panel
72:                char CntResumeSplit_Sec = 0;			// contatore per il resume degli split sul sec bus
73:                unsigned ComunicationLost;				// flag di comunicazione persa
74:                unsigned char CurUsedProtocolId = 0;	// Id del protocollo correntemente utilizzato
75:                
76:                //----------------------------------------------------------------------------------
77:                //	Prototipi 
78:                //----------------------------------------------------------------------------------
79:                void Init(void);
80:                
81:                
82:                float AD2Kpid(int Adc, float min, float max)
83:                {
006334  FA000E     LNK #0xE
006336  980720     MOV W0, [W14+4]
006338  980732     MOV W2, [W14+6]
00633A  980743     MOV W3, [W14+8]
00633C  980754     MOV W4, [W14+10]
00633E  980765     MOV W5, [W14+12]
84:                    float Kconv;
85:                    
86:                    Kconv = 700.0 / (max-min);
006340  90013E     MOV [W14+6], W2
006342  9001CE     MOV [W14+8], W3
006344  90005E     MOV [W14+10], W0
006346  9000EE     MOV [W14+12], W1
006348  07CFDA     RCALL ___subsf3
00634A  BE0200     MOV.D W0, W4
00634C  BE0104     MOV.D W4, W2
00634E  200000     MOV #0x0, W0
006350  2442F1     MOV #0x442F, W1
006352  07D033     RCALL ___divsf3
006354  BE0200     MOV.D W0, W4
006356  BE8F04     MOV.D W4, [W14]
87:                    
88:                    return (float)Adc / Kconv;
006358  90022E     MOV [W14+4], W4
00635A  DEA2CF     ASR W4, #15, W5
00635C  BE0004     MOV.D W4, W0
00635E  07D0AF     RCALL ___floatsisf
006360  BE0200     MOV.D W0, W4
006362  BE011E     MOV.D [W14], W2
006364  BE0004     MOV.D W4, W0
006366  07D029     RCALL ___divsf3
006368  BE0200     MOV.D W0, W4
89:                }
00636A  BE0004     MOV.D W4, W0
00636C  FA8000     ULNK
00636E  060000     RETURN
90:                
91:                //----------------------------------------------------------------------------------
92:                //	Main
93:                //----------------------------------------------------------------------------------
94:                int main(void)
95:                {
006370  FA0002     LNK #0x2
006372  781F88     MOV W8, [W15++]
96:                	int media = 0;
006374  EB0200     CLR W4
006376  780F04     MOV W4, [W14]
97:                	
98:                	oPwrLed = 0;
006378  A902F4     BCLR LATG, #0
99:                	Init();
00637A  0700C8     RCALL Init
100:               
101:               	TimerSystemCycle.Enable = 1;			// Parto con il calcolo del Cycle time  v8.4.16
00637C  A80ED6     BSET 0xED6, #0
102:               
103:               	/*
104:               //DEBUG
105:               	Me.ExpValve_Req=0;
106:               	Enable_Run();
107:               	while(1)
108:               	{
109:               		if(Me.ExpValve_Req==0) 
110:               			oDir = OpenValve;
111:               		if(Me.ExpValve_Req==400)
112:               			oDir = CloseValve;
113:               	
114:               		if(oDir == OpenValve)
115:               			Me.ExpValve_Req++;
116:               		if(oDir == CloseValve)
117:               			Me.ExpValve_Req--;		
118:               		
119:               		//RefreshValue();			// aggiorna la valvola
120:               		
121:               		Refresh_MotSt();
122:               		//Free_Run();
123:               		DelaymSec(2);
124:               	}
125:               //DEBUG	
126:               	*/	
127:               
128:               /*
129:               	//DEBUG
130:               	int temp;
131:               	int temp2;
132:               	int MaxStep;
133:               	
134:               	Me.ExpValve_Act=0;
135:               	Me.ExpValve_Req=0;
136:               	Adc_P_Grande = 5;//20;
137:               	
138:               	temp=0;
139:               	
140:               // Ago tutto fuori = Valvola chiusa (Me.ExpValve_Req = 0)
141:               // Ago tutto dentro = Valvola aperta (Me.ExpValve_Req > 1000 con 1/2 step)
142:               
143:               	
144:               	Me.ExpValve_Req=1800;	// apre tutto
145:               	RefreshValue();			// aggiorna la valvola
146:               	
147:               	Me.ExpValve_Req=1000;	// reset puntatore valvola aperta	
148:               	Me.ExpValve_Act=Me.ExpValve_Req;	// Act = Req
149:               	MaxStep= 1000;//800;
150:               	
151:               	while(1)
152:               	{
153:               	
154:               		//Adc_P_Grande = AD_ReadSingle(0);
155:               		//Adc_P_Grande = Adc_P_Grande/20;
156:               		Me.ExpValve_Req=MaxStep;
157:               		RefreshValue();			// aggiorna la valvola
158:               		DelaymSec(500);
159:               		Me.ExpValve_Req=0;
160:               		RefreshValue();			// aggiorna la valvola
161:               		//DelaymSec(500);
162:               		
163:               		
164:               		for(temp=0; temp<400; temp++)
165:               		{
166:               			temp++;
167:               			StoreInt(temp, E2_Free_1);			
168:               
169:               			temp2 = LoadInt(E2_Free_1);
170:               			if(temp != temp2)
171:               			{
172:               				oErrLed=0;		// accendo LED
173:               				while(1);
174:               			}
175:               			else oErrLed=1;	// spengo LED
176:               
177:               			// DEBUG Solo x accedere frequentemente alla E2
178:               			RefreshE2_Data();							// aggiorno i dati in E2
179:               		}
180:               	}
181:               //DEBUG		
182:               */
183:               	
184:               	
185:               	while (1)
186:               	{
187:                       //DEBUG
188:                       if (!iDigiIn2)			// DEBUG
00637E  8016D5     MOV PORTD, W5
006380  208004     MOV #0x800, W4
006382  628204     AND W5, W4, W4
006384  520FE0     SUB W4, #0x0, [W15]
006386  3A0001     BRA NZ, 0x638A
189:                       	InitValvola();			// Init Valvola        
006388  07130B     RCALL InitValvola
190:                       //DEBUG		
191:               		
192:               		// leggo le sonde
193:               		AD_Read();
00638A  07FBDA     RCALL AD_Read
194:               
195:               		// elaboro le letture
196:               
197:               		Me.Temp_Small = Temp_Read(Adc_T_Piccolo, &AD_T_Piccolo, &Kt_T_Piccolo);
00638C  804284     MOV Adc_T_Piccolo, W4
00638E  208D82     MOV #0x8D8, W2
006390  208781     MOV #0x878, W1
006392  780004     MOV W4, W0
006394  07FD33     RCALL Temp_Read
006396  780200     MOV W0, W4
006398  885B94     MOV W4, 0xB72
198:                		Me.Temp_Big = Temp_Read(Adc_T_Grande, &AD_T_Grande, &Kt_T_Grande);
00639A  804294     MOV Adc_T_Grande, W4
00639C  208EE2     MOV #0x8EE, W2
00639E  208901     MOV #0x890, W1
0063A0  780004     MOV W4, W0
0063A2  07FD2C     RCALL Temp_Read
0063A4  780200     MOV W0, W4
0063A6  885B84     MOV W4, 0xB70
199:               		Me.Temp_AirOut = Temp_Read(Adc_T_Out, &AD_T_Out, &Kt_T_Out);
0063A8  8042A4     MOV Adc_T_Out, W4
0063AA  209042     MOV #0x904, W2
0063AC  208A81     MOV #0x8A8, W1
0063AE  780004     MOV W4, W0
0063B0  07FD25     RCALL Temp_Read
0063B2  780200     MOV W0, W4
0063B4  885B74     MOV W4, 0xB6E
200:               		Me.Temp_Amb = T_Amb_Read(Adc_T_Amb, &AD_T_Amb, &Kt_T_Amb);
0063B6  8042B4     MOV Adc_T_Amb, W4
0063B8  2091A2     MOV #0x91A, W2
0063BA  208C01     MOV #0x8C0, W1
0063BC  780004     MOV W4, W0
0063BE  07FDE9     RCALL T_Amb_Read
0063C0  780200     MOV W0, W4
0063C2  885B64     MOV W4, Me
201:               	/*
202:               		Me.Temp_Small = Steinhart(Adc_T_Piccolo, 1); 
203:                		Me.Temp_Big = Steinhart(Adc_T_Grande, 1);
204:               		Me.Temp_AirOut = Steinhart(Adc_T_Out, 1);
205:               		Me.Temp_Amb = Steinhart(Adc_T_Amb, 2); 	
206:               	*/
207:               		//Me.Pres_Big = Adc_P_Grande;
208:               		//Me.Pres_Small = Adc_P_Piccolo;
209:                   /*  DEBUG
210:               		Me.Pres_Big = Pressure_Read_45(Adc_P_Grande);			//Adc_P_Grande;    
211:               		Me.Pres_Small = Pressure_Read_34(Adc_P_Piccolo);		//Adc_P_Piccolo;	
212:                    */  	 
213:                    /* x taratura PID
214:                       ValvePID.VKiPID = AD2Kpid(Adc_P_Grande, 0.0, 0.1);			//Adc_P_Grande;   Range Ki = 0.01 .. 1.0 
215:               		ValvePID.VKdPID = AD2Kpid(Adc_P_Piccolo, 0.0, 2.5);		//Adc_P_Piccolo;
216:                    */     
217:                       
218:               		Me.Fan_Power = Adc_I_Fan;	
0063C4  8042E4     MOV Adc_I_Fan, W4
0063C6  885CA4     MOV W4, 0xB94
219:               
220:               		//Me.Superheat = Me.Temp_Big - PressureGasToTempR410A(EngineBox.Pressione_Gas_G);		// Superheat in °C	//DEBUG
221:               		//Me.Superheat = Me.Temp_Big - Me.Evap_Temp;
222:               		media = Me.Temp_Big - PressureGasToTempR410A(EngineBox.Pressione_Gas_G);
0063C8  805B84     MOV 0xB70, W4
0063CA  780404     MOV W4, W8
0063CC  8059A4     MOV 0xB34, W4
0063CE  780004     MOV W4, W0
0063D0  07E59B     RCALL PressureGasToTempR410A
0063D2  780200     MOV W0, W4
0063D4  540204     SUB W8, W4, W4
0063D6  780F04     MOV W4, [W14]
223:               		Me.Superheat = ((Me.Temp_Big - Me.Evap_Temp)+media)/2;
0063D8  805B85     MOV 0xB70, W5
0063DA  805BF4     MOV 0xB7E, W4
0063DC  528204     SUB W5, W4, W4
0063DE  42029E     ADD W4, [W14], W5
0063E0  200024     MOV #0x2, W4
0063E2  090011     REPEAT #0x11
0063E4  D80284     DIV.SW W5, W4
0063E6  780200     MOV W0, W4
0063E8  885D44     MOV W4, 0xBA8
224:               		
225:                       Me.Superheat = Filter(&FilterSuperHeat, Me.Superheat, K_Campioni_Filter);
0063EA  805D44     MOV 0xBA8, W4
0063EC  200142     MOV #0x14, W2
0063EE  780084     MOV W4, W1
0063F0  20EA00     MOV #0xEA0, W0
0063F2  070E1E     RCALL Filter
0063F4  780200     MOV W0, W4
0063F6  885D44     MOV W4, 0xBA8
226:               		if(Me.Superheat<0) 
0063F8  805D44     MOV 0xBA8, W4
0063FA  520FE0     SUB W4, #0x0, [W15]
0063FC  3D0002     BRA GE, 0x6402
227:               			Me.Superheat = 0;
0063FE  EB0200     CLR W4
006400  885D44     MOV W4, 0xBA8
228:                       
229:                       //Calcolo valore che deve raggiungere Temp_Big
230:                       //Me.T_Big_Request = PressureGasToTempR410A(EngineBox.Pressione_Gas_G) + ValvePID.SetP;	//DEBUG
231:                       //Me.T_Big_Request = Filter(&FilterBig_Request, Me.T_Big_Request, K_Campioni_Filter);	//DEBUG
232:               		//Me.T_Big_Request = Me.Evap_Temp + K_SetPoint;
233:               		media = PressureGasToTempR410A(EngineBox.Pressione_Gas_G) + ValvePID.SetP;
006402  8059A4     MOV 0xB34, W4
006404  780004     MOV W4, W0
006406  07E580     RCALL PressureGasToTempR410A
006408  780200     MOV W0, W4
00640A  8072F5     MOV ValvePID, W5
00640C  420205     ADD W4, W5, W4
00640E  780F04     MOV W4, [W14]
234:               		Me.T_Big_Request = ((Me.Evap_Temp + K_SetPoint)+media)/2;
006410  805BF4     MOV 0xB7E, W4
006412  B02584     ADD #0x258, W4
006414  42029E     ADD W4, [W14], W5
006416  200024     MOV #0x2, W4
006418  090011     REPEAT #0x11
00641A  D80284     DIV.SW W5, W4
00641C  780200     MOV W0, W4
00641E  885D54     MOV W4, 0xBAA
235:               		Me.T_Big_Request = Filter(&FilterBig_Request, Me.T_Big_Request, K_Campioni_Filter);	//DEBUG
006420  805D54     MOV 0xBAA, W4
006422  200142     MOV #0x14, W2
006424  780084     MOV W4, W1
006426  20EA80     MOV #0xEA8, W0
006428  070E03     RCALL Filter
00642A  780200     MOV W0, W4
00642C  885D54     MOV W4, 0xBAA
236:               		
237:               		Me.Subcooling = PressureGasToTempR410A(EngineBox.Pressione_Liq_P) - Me.Temp_Small;	// Subcooling in °C		
00642E  8059B4     MOV 0xB36, W4
006430  780004     MOV W4, W0
006432  07E56A     RCALL PressureGasToTempR410A
006434  780200     MOV W0, W4
006436  805B95     MOV 0xB72, W5
006438  520205     SUB W4, W5, W4
00643A  885D34     MOV W4, 0xBA6
238:               		
239:               		
240:               		// Leggo l'input delle schede split sul secondo bus
241:               		CurUsedProtocolId = FlagMyBusProt;
00643C  EB4200     CLR.B W4
00643E  784304     MOV.B W4, W6
006440  20EE25     MOV #0xEE2, W5
006442  784A86     MOV.B W6, [W5]
242:               #ifndef	DEBUGSERIAL		
243:               		if (iDigiIn1)			// DEBUG
006444  8016D5     MOV PORTD, W5
006446  204004     MOV #0x400, W4
006448  628204     AND W5, W4, W4
00644A  520FE0     SUB W4, #0x0, [W15]
00644C  320001     BRA Z, 0x6450
244:               		RefreshAllInPut_Sec();					// Controllo se le eventuali schede Split sul BUS secondario sono abilitate e OnLine
00644E  070A08     RCALL RefreshAllInPut_Sec
245:               #endif		
246:               		// Leggo l'imput dei Touch/Panel
247:               		CurUsedProtocolId = FlagModBusProt;
006450  B3C014     MOV.B #0x1, W4
006452  784084     MOV.B W4, W1
006454  20EE20     MOV #0xEE2, W0
006456  784801     MOV.B W1, [W0]
248:               #ifndef	DEBUGSERIAL				
249:               		if(Me.NetPanelActive)
006458  20BA54     MOV #0xBA5, W4
00645A  784214     MOV.B [W4], W4
00645C  524FE0     SUB.B W4, #0x0, [W15]
00645E  320008     BRA Z, 0x6470
250:               		{
251:               			if(RefreshPanelRead.TimeOut)		// Leggo Panel ogni 100mS
006460  807684     MOV 0xED0, W4
006462  620262     AND W4, #0x2, W4
006464  520FE0     SUB W4, #0x0, [W15]
006466  32000A     BRA Z, 0x647C
252:               			{
253:               				RefreshPanelRead.TimeOut=0;				
006468  A92ED0     BCLR 0xED0, #1
254:               				RefreshAllPanelInPut();			// Leggo i dati provenienti dal Panel
00646A  07E1E0     RCALL RefreshAllPanelInPut
255:               				Panel2Touch();					// e li "travaso" in struct Touch[] per mantenere inalterata le funzioni in Core.C che usano Touch[]...
00646C  07E200     RCALL Panel2Touch
00646E  370006     BRA 0x647C
256:               			}
257:               		}
258:               		else
259:               			if (iDigiIn1)			// DEBUG
006470  8016D5     MOV PORTD, W5
006472  204004     MOV #0x400, W4
006474  628204     AND W5, W4, W4
006476  520FE0     SUB W4, #0x0, [W15]
006478  320001     BRA Z, 0x647C
260:               			RefreshAllTouchInPut();				// Leggo i dati provenienti dal Touch
00647A  07DC51     RCALL RefreshAllTouchInPut
261:               #endif
262:               		
263:               		// Elaborazione
264:               		FunctionMode();			// aggiorno la modalità di funzionamento
00647C  07E231     RCALL FunctionMode
265:               		TempEvaporazione();		// aggiorno la temperatura di evaporazione
00647E  07E937     RCALL TempEvaporazione
266:               		RegolaValvola();		// aggiorno la regolazione della valvola
006480  07EA85     RCALL RegolaValvola
267:               		ControlloVentil();		// aggiorno gli errori del ventilatore
006482  07FABE     RCALL ControlloVentil
268:               
269:               		// aggiornamento periferiche
270:               		UpdateFanSpeed(); //AggiornaVentil();		// aggiorno i ventil
006484  07F7B6     RCALL UpdateFanSpeed
271:               		RefreshValue();			// aggiorna la valvola
006486  0712C4     RCALL RefreshValue
272:               		RefreshTacho();			// elaboro il segnalo tacho
006488  07FAF5     RCALL RefreshTacho
273:               
274:               		// Scrivo l'out delle schede split sul secondo bus
275:               		CurUsedProtocolId = FlagMyBusProt;
00648A  EB4200     CLR.B W4
00648C  784304     MOV.B W4, W6
00648E  20EE25     MOV #0xEE2, W5
006490  784A86     MOV.B W6, [W5]
276:               #ifndef	DEBUGSERIAL		
277:               		if (iDigiIn1)			// DEBUG
006492  8016D5     MOV PORTD, W5
006494  204004     MOV #0x400, W4
006496  628204     AND W5, W4, W4
006498  520FE0     SUB W4, #0x0, [W15]
00649A  320001     BRA Z, 0x649E
278:               		RefreshAllOutPut_Sec();
00649C  070A35     RCALL RefreshAllOutPut_Sec
279:               #endif
280:               		// Scrivo l'output dei touch
281:               		CurUsedProtocolId = FlagModBusProt;
00649E  B3C014     MOV.B #0x1, W4
0064A0  784084     MOV.B W4, W1
0064A2  20EE20     MOV #0xEE2, W0
0064A4  784801     MOV.B W1, [W0]
282:               #ifndef	DEBUGSERIAL
283:               		if(Me.NetPanelActive)
0064A6  20BA54     MOV #0xBA5, W4
0064A8  784214     MOV.B [W4], W4
0064AA  524FE0     SUB.B W4, #0x0, [W15]
0064AC  320002     BRA Z, 0x64B2
284:               			RefreshAllPanelOutPut();		// Scrivo i dati verso il Panel
0064AE  07E1D9     RCALL RefreshAllPanelOutPut
0064B0  370006     BRA 0x64BE
285:               		else
286:               		{
287:               			if (iDigiIn1)			// DEBUG
0064B2  8016D5     MOV PORTD, W5
0064B4  204004     MOV #0x400, W4
0064B6  628204     AND W5, W4, W4
0064B8  520FE0     SUB W4, #0x0, [W15]
0064BA  320001     BRA Z, 0x64BE
288:               			RefreshAllTouchOutPut();		// Scrivo i dati verso il Touch
0064BC  07DF9F     RCALL RefreshAllTouchOutPut
289:               		}
290:               			
291:               #endif
292:               		
293:               		// Funzioni di servizio
294:               		RefreshE2_Data();							// aggiorno i dati in E2
0064BE  070351     RCALL RefreshE2_Data
295:               		CurUsedProtocolId = FlagMyBusProt;
0064C0  EB4200     CLR.B W4
0064C2  784304     MOV.B W4, W6
0064C4  20EE25     MOV #0xEE2, W5
0064C6  784A86     MOV.B W6, [W5]
296:               #ifndef	DEBUGSERIAL		
297:               		if (iDigiIn1)			// DEBUG
0064C8  8016D5     MOV PORTD, W5
0064CA  204004     MOV #0x400, W4
0064CC  628204     AND W5, W4, W4
0064CE  520FE0     SUB W4, #0x0, [W15]
0064D0  320002     BRA Z, 0x64D6
298:               		ResumeOffLine_Sec(&CntResumeSplit_Sec);
0064D2  20EDE0     MOV #0xEDE, W0
0064D4  070950     RCALL ResumeOffLine_Sec
299:               #endif		
300:               		CurUsedProtocolId = FlagModBusProt;
0064D6  B3C014     MOV.B #0x1, W4
0064D8  784084     MOV.B W4, W1
0064DA  20EE20     MOV #0xEE2, W0
0064DC  784801     MOV.B W1, [W0]
301:               #ifndef	DEBUGSERIAL
302:               		if(Me.NetPanelActive)
0064DE  20BA54     MOV #0xBA5, W4
0064E0  784214     MOV.B [W4], W4
0064E2  524FE0     SUB.B W4, #0x0, [W15]
0064E4  320003     BRA Z, 0x64EC
303:               			Resume_PanelOffLine(&CntResumePanel);	// tento di ripescare eventuali panel off line
0064E6  20EDD0     MOV #0xEDD, W0
0064E8  07E077     RCALL Resume_PanelOffLine
0064EA  370007     BRA 0x64FA
304:               		else
305:               		{
306:               			if (iDigiIn1)			// DEBUG
0064EC  8016D5     MOV PORTD, W5
0064EE  204004     MOV #0x400, W4
0064F0  628204     AND W5, W4, W4
0064F2  520FE0     SUB W4, #0x0, [W15]
0064F4  320002     BRA Z, 0x64FA
307:               			Resume_TouchOffLine(&CntResumeTouch);	// tento di ripescare eventuali touch off line	
0064F6  20EDC0     MOV #0xEDC, W0
0064F8  07D9BE     RCALL Resume_TouchOffLine
308:               		}
309:               			
310:               #endif
311:               		
312:               		// eseguo il controllo degli errori di over run sulle seriali
313:               		ClearUart1Err();
0064FA  0713CA     RCALL ClearUart1Err
314:               		ClearUart2Err();
0064FC  0713D2     RCALL ClearUart2Err
315:               
316:               		RefreshE2_TouchValue();						// Aggiorna in EEPROM eventuali variazioni di parametri provenienti dal Touch (Velocità, SetPoint, Modalità....)
0064FE  07044E     RCALL RefreshE2_TouchValue
317:               
318:               		Me.CycleTime = TimerSystemCycle.Value;		// Memorizzo valore timer tempo di ciclo per successivo invio sul Touch x diagnostica
006500  807694     MOV TimerSystemCycle, W4
006502  885D04     MOV W4, 0xBA0
319:               		TimerSystemCycle.TimeOut = 0;				// resetto il time out del timer Elapsed
006504  A92ED6     BCLR 0xED6, #1
320:               		TimerSystemCycle.Value = 0;					// resetto il time value del timer Elapsed
006506  EB0200     CLR W4
006508  887694     MOV W4, TimerSystemCycle
321:               
322:               	}
00650A  37FF39     BRA 0x637E
323:               }
324:               
325:               //----------------------------------------------------------------------------------
326:               //	function and procedure
327:               //----------------------------------------------------------------------------------
328:               void Init(void)
329:               {
00650C  FA0000     LNK #0x0
330:               	RCON = 0;				// Reset control
00650E  EB0200     CLR W4
006510  883A04     MOV W4, RCON
331:               
332:               	LATA = 0;				// resetto il portA
006512  EB0200     CLR W4
006514  881624     MOV W4, LATA
333:               	TRISA = 0x07FF;			// setto gli i/o del PortA
006516  207FF4     MOV #0x7FF, W4
006518  881604     MOV W4, TRISA
334:               	LATB = 0;				// resetto il portB
00651A  EB0200     CLR W4
00651C  881664     MOV W4, LATB
335:               	TRISB = 0x01FF;			// setto gli i/o del PortB
00651E  201FF4     MOV #0x1FF, W4
006520  881644     MOV W4, TRISB
336:               	LATC = 0;				// resetto il portC
006522  EB0200     CLR W4
006524  8816A4     MOV W4, LATC
337:               	TRISC = 0x0010;			// setto gli i/o del PortC
006526  200104     MOV #0x10, W4
006528  881684     MOV W4, TRISC
338:               	LATD = 0;				// resetto il portD
00652A  EB0200     CLR W4
00652C  8816E4     MOV W4, LATD
339:               	TRISD = 0x8C03;			// setto gli i/o del PortD
00652E  28C034     MOV #0x8C03, W4
006530  8816C4     MOV W4, TRISD
340:               	LATE = 0;				// resetto il portE
006532  EB0200     CLR W4
006534  881724     MOV W4, LATE
341:               	TRISE = 0x00C0;			// setto gli i/o del PortE
006536  200C04     MOV #0xC0, W4
006538  881704     MOV W4, TRISE
342:               	LATF = 0;				// resetto il portF
00653A  EB0200     CLR W4
00653C  881764     MOV W4, LATF
343:               	TRISF = 0x0114;			// setto gli i/o del PortF
00653E  201144     MOV #0x114, W4
006540  881744     MOV W4, TRISF
344:               	LATG = 0;				// resetto il portG
006542  EB0200     CLR W4
006544  8817A4     MOV W4, LATG
345:               	TRISG = 0x0000;			// setto gli i/o del PortG 0040
006546  EB0200     CLR W4
006548  881784     MOV W4, TRISG
346:               
347:               	oPWM_Fan1 = 1;
00654A  A882DD     BSET 0x2DD, #4
348:               	oPWM_Fan2 = 1;
00654C  A8C2F4     BSET LATG, #6
349:               
350:               	Remap_RP();				// rimappo le periferiche
00654E  070DC6     RCALL Remap_RP
351:               
352:               	// abilito i pull up
353:               	CNPU3bits.CN33PUE = 1;	// Pull up A0
006550  A82070     BSET CNPU3, #1
354:               	CNPU3bits.CN34PUE = 1;	// Pull up A1
006552  A84070     BSET CNPU3, #2
355:               	CNPU3bits.CN35PUE = 1;	// Pull up A2
006554  A86070     BSET CNPU3, #3
356:               	CNPU3bits.CN36PUE = 1;	// Pull up A3
006556  A88070     BSET CNPU3, #4
357:               	CNPU3bits.CN37PUE = 1;	// Pull up A4
006558  A8A070     BSET CNPU3, #5
358:               	CNPU3bits.CN38PUE = 1;	// Pull up A5
00655A  A8C070     BSET CNPU3, #6
359:               	CNPU3bits.CN39PUE = 1;	// Pull up A6
00655C  A8E070     BSET CNPU3, #7
360:               	CNPU3bits.CN40PUE = 1;	// Pull up A7
00655E  A80071     BSET 0x71, #0
361:               
362:               	CNPU5bits.CN64PUE = 1;	// pull up SCL
006560  A80074     BSET CNPU5, #0
363:               	CNPU5bits.CN65PUE = 1;	// pull up SDA
006562  A82074     BSET CNPU5, #1
364:               	CNPU4bits.CN48PUE = 1;	// pull up iTacho
006564  A80072     BSET CNPU4, #0
365:               	CNPU4bits.CN49PUE = 1;	// pull up iFault
006566  A82072     BSET CNPU4, #1
366:               	CNPU4bits.CN50PUE = 1;	// pull up iHome
006568  A84072     BSET CNPU4, #2
367:               	CNPU4bits.CN55PUE = 1;	// pull up Idigi1
00656A  A8E072     BSET CNPU4, #7
368:               	CNPU4bits.CN56PUE = 1;	// pull up Idigi2
00656C  A80073     BSET 0x73, #0
369:               
370:               	oErrLed=0;
00656E  A922F4     BCLR LATG, #1
371:               	I2C_Init ();			// inizializzo l'I2C1
006570  07108D     RCALL I2C_Init
372:               	LoadAllE2_Data();		// carico i valori dala E2
006572  07022A     RCALL LoadAllE2_Data
373:               	LoadE2_TouchValue();	// carica i valori di funzionamento da EEPROM
006574  07046E     RCALL LoadE2_TouchValue
374:               	oErrLed=1;	
006576  A822F4     BSET LATG, #1
375:               	
376:               	// Init ADC
377:               	IEC0bits.AD1IE = 0;		// abilito interrupt AD
006578  A9A095     BCLR 0x95, #5
378:               	IFS0bits.AD1IF = 0;		// reseto il flag d'interrupt del convertitotore
00657A  A9A085     BCLR 0x85, #5
379:               	Init_Adc();	
00657C  801904     MOV AD1CON1, W4
00657E  A18004     BCLR W4, #8
006580  A19004     BCLR W4, #9
006582  881904     MOV W4, AD1CON1
006584  801904     MOV AD1CON1, W4
006586  A05004     BSET W4, #5
006588  A06004     BSET W4, #6
00658A  A07004     BSET W4, #7
00658C  881904     MOV W4, AD1CON1
00658E  A9A321     BCLR 0x321, #5
006590  A84320     BSET AD1CON1, #2
006592  801914     MOV AD1CON2, W4
006594  A0D004     BSET W4, #13
006596  A1E004     BCLR W4, #14
006598  A1F004     BCLR W4, #15
00659A  881914     MOV W4, AD1CON2
00659C  A84323     BSET 0x323, #2
00659E  801914     MOV AD1CON2, W4
0065A0  A02004     BSET W4, #2
0065A2  A13004     BCLR W4, #3
0065A4  A14004     BCLR W4, #4
0065A6  A05004     BSET W4, #5
0065A8  881914     MOV W4, AD1CON2
0065AA  A92322     BCLR AD1CON2, #1
0065AC  A90322     BCLR AD1CON2, #0
0065AE  A9E325     BCLR 0x325, #7
0065B0  801925     MOV AD1CON3, W5
0065B2  2E0FF4     MOV #0xE0FF, W4
0065B4  628284     AND W5, W4, W5
0065B6  207004     MOV #0x700, W4
0065B8  720205     IOR W4, W5, W4
0065BA  881924     MOV W4, AD1CON3
0065BC  B3C024     MOV.B #0x2, W4
0065BE  784304     MOV.B W4, W6
0065C0  203245     MOV #0x324, W5
0065C2  784A86     MOV.B W6, [W5]
0065C4  A9E329     BCLR 0x329, #7
0065C6  801945     MOV AD1CHS, W5
0065C8  2E0FF4     MOV #0xE0FF, W4
0065CA  628284     AND W5, W4, W5
0065CC  211004     MOV #0x1100, W4
0065CE  720205     IOR W4, W5, W4
0065D0  881944     MOV W4, AD1CHS
0065D2  A9E328     BCLR AD1CHS, #7
0065D4  801945     MOV AD1CHS, W5
0065D6  2FFE04     MOV #0xFFE0, W4
0065D8  628204     AND W5, W4, W4
0065DA  B30114     IOR #0x11, W4
0065DC  881944     MOV W4, AD1CHS
0065DE  2FEC04     MOV #0xFEC0, W4
0065E0  881964     MOV W4, AD1PCFGL
0065E2  EB0200     CLR W4
0065E4  881954     MOV W4, AD1PCFGH
0065E6  2013F4     MOV #0x13F, W4
0065E8  881984     MOV W4, AD1CSSL
0065EA  EB0200     CLR W4
0065EC  881994     MOV W4, AD1CSSH
0065EE  A8E321     BSET 0x321, #7
380:               
381:               	My_Address = (~PORTA & 0x000F);		//(~PORTA & 0x00FF);		// configuro l'indirizzo del modulo
0065F0  801614     MOV PORTA, W4
0065F2  784204     MOV.B W4, W4
0065F4  EAC204     COM.B W4, W4
0065F6  62426F     AND.B W4, #0xF, W4
0065F8  784304     MOV.B W4, W6
0065FA  20A915     MOV #0xA91, W5
0065FC  784A86     MOV.B W6, [W5]
382:               	Me.My_Address = My_Address;
0065FE  20A914     MOV #0xA91, W4
006600  784214     MOV.B [W4], W4
006602  784304     MOV.B W4, W6
006604  20BA45     MOV #0xBA4, W5
006606  784A86     MOV.B W6, [W5]
383:               	Me.NetPanelActive = ((~PORTA & 0x0080) != 0);		// Flag attivazione gestione Pannelli NetBuilding (Dip Switch n.8 = ON)
006608  801614     MOV PORTA, W4
00660A  EA8284     COM W4, W5
00660C  200804     MOV #0x80, W4
00660E  628204     AND W5, W4, W4
006610  A7F004     BTSC W4, #15
006612  EA0204     NEG W4, W4
006614  EA0204     NEG W4, W4
006616  DE224F     LSR W4, #15, W4
006618  784204     MOV.B W4, W4
00661A  784304     MOV.B W4, W6
00661C  20BA55     MOV #0xBA5, W5
00661E  784A86     MOV.B W6, [W5]
384:               	
385:               	// Init UART 1			// Bus serial @57K6, 8,n,1
386:               	init_comms1();
006620  A9A2EC     BCLR LATF, #5
006622  200444     MOV #0x44, W4
006624  881144     MOV W4, U1BRG
006626  A8E221     BSET 0x221, #7
006628  A9A221     BCLR 0x221, #5
00662A  A98221     BCLR 0x221, #4
00662C  A86221     BSET 0x221, #3
00662E  A90221     BCLR 0x221, #0
006630  A92221     BCLR 0x221, #1
006632  A9E220     BCLR U1MODE, #7
006634  A9C220     BCLR U1MODE, #6
006636  A9A220     BCLR U1MODE, #5
006638  A98220     BCLR U1MODE, #4
00663A  A86220     BSET U1MODE, #3
00663C  801104     MOV U1MODE, W4
00663E  A11004     BCLR W4, #1
006640  A12004     BCLR W4, #2
006642  881104     MOV W4, U1MODE
006644  A90220     BCLR U1MODE, #0
006646  A9E223     BCLR 0x223, #7
006648  A8A223     BSET 0x223, #5
00664A  A9C223     BCLR 0x223, #6
00664C  A96223     BCLR 0x223, #3
00664E  A84223     BSET 0x223, #2
006650  801114     MOV U1STA, W4
006652  A16004     BCLR W4, #6
006654  A17004     BCLR W4, #7
006656  881114     MOV W4, U1STA
006658  A9A222     BCLR U1STA, #5
387:               	IEC0bits.U1RXIE = 1;	// abilito interrupt su rx usart 1
00665A  A86095     BSET 0x95, #3
388:               	IPC2bits.U1RXIP = 4;	// imposto il livello di interupt (7 più alto)
00665C  800544     MOV IPC2, W4
00665E  A1C004     BCLR W4, #12
006660  A1D004     BCLR W4, #13
006662  A0E004     BSET W4, #14
006664  880544     MOV W4, IPC2
389:               	ClearUart1Err();
006666  071314     RCALL ClearUart1Err
390:               
391:               	// Init UART 2			// Touch Serial @57K6, 8,n,1
392:               	init_comms2();
006668  A962EC     BCLR LATF, #3
00666A  200444     MOV #0x44, W4
00666C  8811C4     MOV W4, U2BRG
00666E  A8E231     BSET 0x231, #7
006670  A9A231     BCLR 0x231, #5
006672  A98231     BCLR 0x231, #4
006674  A86231     BSET 0x231, #3
006676  A90231     BCLR 0x231, #0
006678  A92231     BCLR 0x231, #1
00667A  A9E230     BCLR U2MODE, #7
00667C  A9C230     BCLR U2MODE, #6
00667E  A9A230     BCLR U2MODE, #5
006680  A98230     BCLR U2MODE, #4
006682  A86230     BSET U2MODE, #3
006684  801184     MOV U2MODE, W4
006686  A11004     BCLR W4, #1
006688  A12004     BCLR W4, #2
00668A  881184     MOV W4, U2MODE
00668C  A90230     BCLR U2MODE, #0
00668E  A9E233     BCLR 0x233, #7
006690  A8A233     BSET 0x233, #5
006692  A9C233     BCLR 0x233, #6
006694  A96233     BCLR 0x233, #3
006696  A84233     BSET 0x233, #2
006698  801194     MOV U2STA, W4
00669A  A16004     BCLR W4, #6
00669C  A17004     BCLR W4, #7
00669E  881194     MOV W4, U2STA
0066A0  A9A232     BCLR U2STA, #5
393:               	IEC1bits.U2RXIE = 1;	// abilito interrupt su rx usart 2
0066A2  A8C097     BSET 0x97, #6
394:               	IPC7bits.U2RXIP = 3;	// imposto il livello di interupt (7 più alto)
0066A4  800594     MOV IPC7, W4
0066A6  A08004     BSET W4, #8
0066A8  A09004     BSET W4, #9
0066AA  A1A004     BCLR W4, #10
0066AC  880594     MOV W4, IPC7
395:               	ClearUart2Err();
0066AE  0712F9     RCALL ClearUart2Err
396:               
397:               	Init_Timer();			// Init TMR1
0066B0  071358     RCALL Init_Timer
398:               	Init_PWM_Module();		// Init PWM
0066B2  07F5AC     RCALL Init_PWM_Module
399:               	InitValvola();			// Init Valvola
0066B4  071175     RCALL InitValvola
400:               	Tacho_Init();
0066B6  07F9B9     RCALL Tacho_Init
401:               	PID_init(&ValvePID, K_p_gain, K_i_gain, K_d_gain, K_iMin, K_iMax, K_PoMin, K_PoMax, K_dead_zone);
0066B8  270004     MOV #0x7000, W4
0066BA  246145     MOV #0x4614, W5
0066BC  BE9F84     MOV.D W4, [W15++]
0066BE  B82260     MUL.UU W4, #0, W4
0066C0  BE9F84     MOV.D W4, [W15++]
0066C2  270004     MOV #0x7000, W4
0066C4  246145     MOV #0x4614, W5
0066C6  BE9F84     MOV.D W4, [W15++]
0066C8  B82260     MUL.UU W4, #0, W4
0066CA  BE9F84     MOV.D W4, [W15++]
0066CC  200021     MOV #0x2, W1
0066CE  B83360     MUL.UU W6, #0, W6
0066D0  24F0E4     MOV #0x4F0E, W4
0066D2  23C2F5     MOV #0x3C2F, W5
0066D4  2999A2     MOV #0x999A, W2
0066D6  240113     MOV #0x4011, W3
0066D8  20E5E0     MOV #0xE5E, W0
0066DA  070B9E     RCALL PID_init
0066DC  5787F0     SUB W15, #0x10, W15
402:               	Init_PWM_Value();		// Inizializza i valori delle velocità ventialtore da costanti anziche da EEPROM
0066DE  07F4E4     RCALL Init_PWM_Value
403:               	
404:               	// inizializzo il timer per il test delle EEV
405:               	TimerTestEEV.Enable = 0;
0066E0  A90B1E     BCLR 0xB1E, #0
406:               	TimerTestEEV.TimeOut = 0;
0066E2  A92B1E     BCLR 0xB1E, #1
407:               	TimerTestEEV.Time = WaitCloseTime;
0066E4  2000A4     MOV #0xA, W4
0066E6  8858E4     MOV W4, 0xB1C
408:               	TimerTestEEV.Value = 0;
0066E8  EB0200     CLR W4
0066EA  8858D4     MOV W4, TimerTestEEV
409:               
410:               	// inizializzo il timer per il controllo della valvola espansione
411:               	TimerExpValvola.TimeOut = 0;
0066EC  A92E26     BCLR 0xE26, #1
412:               	TimerExpValvola.Time = WaitExpValvolaCaldo;
0066EE  207D04     MOV #0x7D0, W4
0066F0  887124     MOV W4, 0xE24
413:               	TimerExpValvola.Value = 0;
0066F2  EB0200     CLR W4
0066F4  887114     MOV W4, TimerExpValvola
414:               	TimerExpValvola.Enable = 1;
0066F6  A80E26     BSET 0xE26, #0
415:               
416:               	// configuro il timer per il controllo della comunicazione
417:               	TmrLastRequest.Value = 0;
0066F8  EB0200     CLR W4
0066FA  887604     MOV W4, TmrLastRequest
418:               	TmrLastRequest.Time = 30;
0066FC  2001E4     MOV #0x1E, W4
0066FE  887614     MOV W4, 0xEC2
419:               	TmrLastRequest.TimeOut = 0;
006700  A92EC4     BCLR 0xEC4, #1
420:               	TmrLastRequest.Enable = 1;
006702  A80EC4     BSET 0xEC4, #0
421:               
422:               	// setto i valori predefiniti del power manager
423:               	Me.PowerLimit = InitPowerLimit;
006704  200FF4     MOV #0xFF, W4
006706  885BD4     MOV W4, 0xB7A
424:               	Me.OldPowerLimit = InitPowerLimit;
006708  200FF4     MOV #0xFF, W4
00670A  885BE4     MOV W4, 0xB7C
425:               	EngineBox.PowerLimit = InitPowerLimit;
00670C  200FF4     MOV #0xFF, W4
00670E  885A34     MOV W4, 0xB46
426:               	EngineBox.OldPowerLimit = InitPowerLimit;
006710  200FF4     MOV #0xFF, W4
006712  885A44     MOV W4, 0xB48
427:               
428:               	// timer di startup dei touch/Panel
429:               #ifndef	DEBUGSERIAL	
430:               	if(Me.NetPanelActive)
006714  20BA54     MOV #0xBA5, W4
006716  784214     MOV.B [W4], W4
006718  524FE0     SUB.B W4, #0x0, [W15]
00671A  320003     BRA Z, 0x6722
431:               		TimerStartUp.Time = 4;
00671C  200044     MOV #0x4, W4
00671E  887644     MOV W4, 0xEC8
006720  370002     BRA 0x6726
432:               	else
433:               		TimerStartUp.Time = 40; //DEBUG 40; 
006722  200284     MOV #0x28, W4
006724  887644     MOV W4, 0xEC8
434:               #else
435:               		TimerStartUp.Time = 1;
436:               #endif	
437:               
438:               	TimerStartUp.Enable = 1;
006726  A80ECA     BSET 0xECA, #0
439:               	oErrLed = 0;
006728  A922F4     BCLR LATG, #1
440:               
441:               	while(TimerStartUp.TimeOut == 0)
00672A  000000     NOP
00672C  370001     BRA 0x6730
006730  807654     MOV 0xECA, W4
006732  620262     AND W4, #0x2, W4
006734  520FE0     SUB W4, #0x0, [W15]
006736  32FFFB     BRA Z, 0x672E
442:               		continue;
00672E  000000     NOP
443:               	TimerStartUp.TimeOut = 0;
006738  A92ECA     BCLR 0xECA, #1
444:               	TimerStartUp.Value = 0;
00673A  EB0200     CLR W4
00673C  887634     MOV W4, TimerStartUp
445:               	TimerStartUp.Enable = 0;
00673E  A90ECA     BCLR 0xECA, #0
446:               	oErrLed = 1;
006740  A822F4     BSET LATG, #1
447:               
448:               	// cerco gli split sul secondo bus
449:               	CurUsedProtocolId = FlagMyBusProt;
006742  EB4200     CLR.B W4
006744  784304     MOV.B W4, W6
006746  20EE25     MOV #0xEE2, W5
006748  784A86     MOV.B W6, [W5]
450:               #ifndef	DEBUGSERIAL	
451:               	CheckModuli_Sec();
00674A  0707BB     RCALL CheckModuli_Sec
452:               #endif
453:               	// cerco i touch
454:               	CurUsedProtocolId = FlagModBusProt;
00674C  B3C014     MOV.B #0x1, W4
00674E  784304     MOV.B W4, W6
006750  20EE25     MOV #0xEE2, W5
006752  784A86     MOV.B W6, [W5]
455:               	if(Me.NetPanelActive)
006754  20BA54     MOV #0xBA5, W4
006756  784214     MOV.B [W4], W4
006758  524FE0     SUB.B W4, #0x0, [W15]
00675A  320003     BRA Z, 0x6762
456:               	{
457:               #ifndef	DEBUGSERIAL		
458:               		Search_Panel();
00675C  07DEEB     RCALL Search_Panel
459:               		InitPanel();
00675E  07E084     RCALL InitPanel
006760  370002     BRA 0x6766
460:               #endif		
461:               	}
462:               	else
463:               		{
464:               #ifndef	DEBUGSERIAL		
465:               			Search_Touch();
006762  07D837     RCALL Search_Touch
466:               			InitTouch();
006764  07DE61     RCALL InitTouch
467:               #endif
468:               		}
469:               
470:               	RefreshVentil.Time = 500;
006766  201F44     MOV #0x1F4, W4
006768  885704     MOV W4, 0xAE0
471:               	RefreshVentil.TimeOut = 0;
00676A  A92AE2     BCLR 0xAE2, #1
472:               	RefreshVentil.Value = 0;
00676C  EB0200     CLR W4
00676E  8856F4     MOV W4, RefreshVentil
473:               	RefreshVentil.Enable = 1;
006770  A80AE2     BSET 0xAE2, #0
474:               
475:               	RefreshFineVentil.Time = 5;
006772  200054     MOV #0x5, W4
006774  885734     MOV W4, 0xAE6
476:               	RefreshFineVentil.TimeOut = 0;
006776  A92AE8     BCLR 0xAE8, #1
477:               	RefreshFineVentil.Value = 0;
006778  EB0200     CLR W4
00677A  885724     MOV W4, RefreshFineVentil
478:               	RefreshFineVentil.Enable = 1;
00677C  A80AE8     BSET 0xAE8, #0
479:               
480:               	RefreshPanelRead.Time = 100;	// Lettura pannelli NetBuilding ogni 100mS
00677E  200644     MOV #0x64, W4
006780  887674     MOV W4, 0xECE
481:               	RefreshPanelRead.TimeOut = 0;
006782  A92ED0     BCLR 0xED0, #1
482:               	RefreshPanelRead.Value = 0;
006784  EB0200     CLR W4
006786  887664     MOV W4, RefreshPanelRead
483:               	RefreshPanelRead.Enable = 1;
006788  A80ED0     BSET 0xED0, #0
484:               
485:               	TimerSystemCycle.Time = 15000;					// Tempo di calcolo tempo di ciclo programma (MAX = 15000 mSec.)
00678A  23A984     MOV #0x3A98, W4
00678C  8876A4     MOV W4, 0xED4
486:               	TimerSystemCycle.Enable = 0;
00678E  A90ED6     BCLR 0xED6, #0
487:               	TimerSystemCycle.TimeOut = 0;					// resetto il timer
006790  A92ED6     BCLR 0xED6, #1
488:               	TimerSystemCycle.Value = 0;
006792  EB0200     CLR W4
006794  887694     MOV W4, TimerSystemCycle
489:               
490:               	TimerExecPID.Time = K_TimeExecPID;			// Tempo in mS per esecuzione regolatore PID per controllo Valvola espansione
006796  201F44     MOV #0x1F4, W4
006798  885914     MOV W4, 0xB22
491:               	TimerExecPID.TimeOut = 0;					// resetto il timer
00679A  A92B24     BCLR 0xB24, #1
492:               	TimerExecPID.Value = 0;
00679C  EB0200     CLR W4
00679E  885904     MOV W4, TimerExecPID
493:               	TimerExecPID.Enable = 1;
0067A0  A80B24     BSET 0xB24, #0
494:               
495:               	
496:               	
497:               	if((My_Address == 0) || (My_Address > 15))
0067A2  20A914     MOV #0xA91, W4
0067A4  784214     MOV.B [W4], W4
0067A6  524FE0     SUB.B W4, #0x0, [W15]
0067A8  320004     BRA Z, 0x67B2
0067AA  20A914     MOV #0xA91, W4
0067AC  784214     MOV.B [W4], W4
0067AE  524FEF     SUB.B W4, #0xF, [W15]
0067B0  360006     BRA LEU, 0x67BE
498:               	{	My_Address = 0;
0067B2  EB4200     CLR.B W4
0067B4  784304     MOV.B W4, W6
0067B6  20A915     MOV #0xA91, W5
0067B8  784A86     MOV.B W6, [W5]
499:               		oErrLed = 0;
0067BA  A922F4     BCLR LATG, #1
0067BC  370001     BRA 0x67C0
500:               	}
501:               	else
502:               		oErrLed = 1;
0067BE  A822F4     BSET LATG, #1
503:               }
0067C0  FA8000     ULNK
0067C2  060000     RETURN
504:               
505:               //----------------------------------------------------------------------------------
506:               //	Interrupt
507:               //----------------------------------------------------------------------------------
508:               /*
509:               	Interrupt vector list
510:               #define INT0_VCTR	0x14	// External Interrupt 0
511:               #define IC1_VCTR	0x16	// Input Capture 1
512:               #define OC1_VCTR	0x18	// Output Compare 1
513:               #define T1_VCTR		0x1a	// Timer 1
514:               
515:               #define DMA0_VCTR	0x1c	// DMA Channel 0
516:               #define IC2_VCTR	0x1e	// Input Capture 2
517:               #define OC2_VCTR	0x20	// Output Compare 2
518:               #define T2_VCTR		0x22	// Timer 2
519:               #define T3_VCTR		0x24	// Timer 3
520:               #define SPI1E_VCTR	0x26	// Serial Comms 1 Error
521:               #define SPI1D_VCTR	0x28	// Serial Comms 1 Transfer Done
522:               #define U1RX_VCTR	0x2a	// UART1 Receiver
523:               #define U1TX_VCTR	0x2c	// UART1 Transmitter
524:               #define ADC1_VCTR	0x2e	// A/D Converter 1
525:               #define DMA1_VCTR	0x30	// DMA Channel 1
526:               #define SI2C1_VCTR	0x34	// I2C1 Slave Interrupt
527:               #define MI2C1_VCTR	0x36	// I2C1 Master Interrupt
528:               #define CM_VCTR		0x38	// Comparator Event
529:               #define INCH_VCTR	0x3A	// Input Change Interrupt
530:               #define INT1_VCTR	0x3C	// External Interrupt 1
531:               #define ADC2_VCTR	0x3e	// A/D Converter 2
532:               #define IC7_VCTR	0x40	// Input Capture 7
533:               #define DMA2_VCTR	0x44	// DMA Channel 2
534:               #define IC8_VCTR	0x42	// Input Capture 8
535:               #define OC3_VCTR	0x46	// Output Compare 3
536:               #define OC4_VCTR	0x48	// Output Compare 4
537:               #define T4_VCTR		0x4a	// Timer 4
538:               #define T5_VCTR		0x4c	// Timer 5
539:               #define INT2_VCTR	0x4e	// External Interrupt 2
540:               #define U2RX_VCTR	0x50	// UART2 Receiver
541:               #define U2TX_VCTR	0x52	// UART2 Transmitter
542:               #define SPI2E_VCTR	0x54	// Serial Comms 2 Error
543:               #define SPI2D_VCTR	0x56	// Serial Comms 2 Transfer Done
544:               #define C1RX_VCTR	0x58	// ECAN1 Receive Data Ready
545:               #define C1E_VCTR	0x58	// CAN1 Error on PS devices
546:               #define C1_VCTR		0x5A	// CAN1 or ECAN1 Event
547:               #define DMA3_VCTR	0x5c	// DMA Channel 3
548:               #define IC3_VCTR	0x5e	// Input Capture 3
549:               #define IC4_VCTR	0x60	// Input Capture 4
550:               #define IC5_VCTR	0x62	// Input Capture 5
551:               #define IC6_VCTR	0x64	// Input Capture 6
552:               #define OC5_VCTR	0x66	// Output Compare 5
553:               #define OC6_VCTR	0x68	// Output Compare 6
554:               #define OC7_VCTR	0x6a	// Output Compare 7
555:               #define OC8_VCTR	0x6c	// Output Compare 8
556:               #define PMP_VCTR	0x6e	// Parallel Port Master
557:               #define DMA4_VCTR	0x70	// DMA Channel 4
558:               #define T6_VCTR		0x72	// Timer 6
559:               #define T7_VCTR		0x74	// Timer 7
560:               #define SI2C2_VCTR	0x76	// I2C2 Slave Interrupt
561:               #define MI2C2_VCTR	0x78	// I2C2 Master Interrupt
562:               #define T8_VCTR		0x7a	// Timer 8
563:               #define T9_VCTR		0x7c	// Timer 9
564:               #define INT3_VCTR	0x7e	// External Interrupt 3
565:               #define INT4_VCTR	0x80	// External Interrupt 4
566:               #define C2RX_VCTR	0x82	// ECAN2 Receive Data Ready
567:               #define C2E_VCTR	0x82	// CAN2 Error on PS devices
568:               #define C2_VCTR		0x84	// CAN2 or ECAN2 Event
569:               #define PWM_VCTR	0x86	// PWM Period Match
570:               #define QEI_VCTR	0x88	// QEI Interrupt
571:               #define DCIE_VCTR	0x8A	// DCI Error
572:               #define DCID_VCTR	0x8c	// DCI Transfer Done
573:               #define DMA5_VCTR	0x8e	// DMA Channel 5
574:               #define RTCC_VCTR	0x90	// Real-time Clock/Calendar
575:               #define FLTA_VCTR	0x92	// PWM Fault A
576:               #define FLTB_VCTR	0x94	// PWM Fault B
577:               #define U1E_VCTR	0x96	// UART1 Error
578:               #define U2E_VCTR	0x98	// UART2 Error
579:               #define DMA6_VCTR	0x9c	// DMA Channel 6
580:               #define DMA7_VCTR	0x9e	// DMA Channel 7
581:               #define C1TX_VCTR	0xa0	// ECAN1 Transmit Data Request
582:               #define C2TX_VCTR	0xa2	// ECAN2 Transmit Data Request
583:               */
584:               
585:               //---------------------------------------------------------------------------------
586:               //void interrupt UART1_Rx(void) @ U1RX_VCTR
587:               //---------------------------------------------------------------------------------
588:               //void __attribute__((interrupt, no_auto_psv)) _U1RXInterrupt()
589:               void __attribute__((interrupt)) _U1RXInterrupt()
590:               {
0067C4  F80036     PUSH RCOUNT
0067C6  BE9F80     MOV.D W0, [W15++]
0067C8  BE9F82     MOV.D W2, [W15++]
0067CA  BE9F84     MOV.D W4, [W15++]
0067CC  BE9F86     MOV.D W6, [W15++]
0067CE  F80034     PUSH PSVPAG
0067D0  200000     MOV #0x0, W0
0067D2  8801A0     MOV W0, PSVPAG
0067D4  FA0000     LNK #0x0
591:               	IntReadBus(&BufferRx);
0067D6  209360     MOV #0x936, W0
0067D8  07096E     RCALL IntReadBus
592:               	Recive_Cmd(&BufferRx, &LastRx);
0067DA  2094E1     MOV #0x94E, W1
0067DC  209360     MOV #0x936, W0
0067DE  070A12     RCALL Recive_Cmd
593:               	if(LastRx.Valid_Data)
0067E0  209584     MOV #0x958, W4
0067E2  784214     MOV.B [W4], W4
0067E4  524FE0     SUB.B W4, #0x0, [W15]
0067E6  320003     BRA Z, 0x67EE
594:               	{
595:               		TmrLastRequest.Value = 0;
0067E8  EB0200     CLR W4
0067EA  887604     MOV W4, TmrLastRequest
596:               		TmrLastRequest.TimeOut = 0;
0067EC  A92EC4     BCLR 0xEC4, #1
597:               	}
598:               	Process_Cmd(&LastRx);
0067EE  2094E0     MOV #0x94E, W0
0067F0  07EB28     RCALL Process_Cmd
599:               	ClearUart2Err();
0067F2  071257     RCALL ClearUart2Err
600:               	IFS0bits.U1RXIF = 0;
0067F4  A96085     BCLR 0x85, #3
601:               	return;
602:               }
0067F6  FA8000     ULNK
0067F8  F90034     POP PSVPAG
0067FA  BE034F     MOV.D [--W15], W6
0067FC  BE024F     MOV.D [--W15], W4
0067FE  BE014F     MOV.D [--W15], W2
006800  BE004F     MOV.D [--W15], W0
006802  F90036     POP RCOUNT
006804  064000     RETFIE
603:               
604:               //---------------------------------------------------------------------------------
605:               //void interrupt UART2_Rx(void) @ U2RX_VCTR
606:               //---------------------------------------------------------------------------------
607:               //void __attribute__((interrupt, no_auto_psv)) _U2RXInterrupt()
608:               void __attribute__((interrupt)) _U2RXInterrupt()
609:               {
006806  F80036     PUSH RCOUNT
006808  BE9F80     MOV.D W0, [W15++]
00680A  BE9F82     MOV.D W2, [W15++]
00680C  BE9F84     MOV.D W4, [W15++]
00680E  BE9F86     MOV.D W6, [W15++]
006810  F80034     PUSH PSVPAG
006812  200000     MOV #0x0, W0
006814  8801A0     MOV W0, PSVPAG
006816  FA0000     LNK #0x0
610:               	//ClearUart2Err();
611:               	switch (CurUsedProtocolId)			// controlo il protocollo che sto utilizzando
006818  20EE24     MOV #0xEE2, W4
00681A  784214     MOV.B [W4], W4
00681C  FB8204     ZE W4, W4
00681E  520FE0     SUB W4, #0x0, [W15]
006820  320003     BRA Z, 0x6828
006822  520FE1     SUB W4, #0x1, [W15]
006824  320008     BRA Z, 0x6836
006826  370009     BRA 0x683A
612:               	{
613:               		case FlagMyBusProt:				// utilizzo il mio protocollo
614:               			iPckModRx = 0;
006828  EB4200     CLR.B W4
00682A  784304     MOV.B W4, W6
00682C  20A905     MOV #0xA90, W5
00682E  784A86     MOV.B W6, [W5]
615:               			IntReadBusSec(&BufferRxSec);
006830  209620     MOV #0x962, W0
006832  070E01     RCALL IntReadBusSec
616:               			break;
006834  370002     BRA 0x683A
617:               
618:               		case FlagModBusProt:			// utilizzo il protocollo ModBus
619:               			Mod_IntReadBus();
006836  0703E8     RCALL Mod_IntReadBus
620:               			break;
006838  000000     NOP
621:               	}
622:               	
623:               	Recive_Cmd_Sec(&BufferRxSec, &LastRxSec);
00683A  2097A1     MOV #0x97A, W1
00683C  209620     MOV #0x962, W0
00683E  070E8F     RCALL Recive_Cmd_Sec
624:               	Mod_Recive_Cmd();
006840  0704F3     RCALL Mod_Recive_Cmd
625:               	return;
626:               }
006842  FA8000     ULNK
006844  F90034     POP PSVPAG
006846  BE034F     MOV.D [--W15], W6
006848  BE024F     MOV.D [--W15], W4
00684A  BE014F     MOV.D [--W15], W2
00684C  BE004F     MOV.D [--W15], W0
00684E  F90036     POP RCOUNT
006850  064000     RETFIE
627:               
628:               //---------------------------------------------------------------------------------
629:               //void interrupt TMR_1(void) @ T1_VCTR (interrupt ogni 1mS)
630:               //---------------------------------------------------------------------------------
631:               //void __attribute__((interrupt, shadow)) _T1Interrupt()
632:               void __attribute__((interrupt)) _T1Interrupt()
633:               {
006852  F80036     PUSH RCOUNT
006854  BE9F80     MOV.D W0, [W15++]
006856  BE9F82     MOV.D W2, [W15++]
006858  BE9F84     MOV.D W4, [W15++]
00685A  BE9F86     MOV.D W6, [W15++]
00685C  F80034     PUSH PSVPAG
00685E  200000     MOV #0x0, W0
006860  8801A0     MOV W0, PSVPAG
006862  FA0000     LNK #0x0
634:               	// Gestisco i timer in ms
635:               	IntTimeOutRx();					// gestisco il time out del protocollo 485
006864  0709BA     RCALL IntTimeOutRx
636:               	IntTimeOutRxSec();				// gestisco il time out del protocollo 485
006866  070E66     RCALL IntTimeOutRxSec
637:               	Mod_IntTimeOutRx();				// gestisco il time out del protocollo 485 modbus
006868  0704C0     RCALL Mod_IntTimeOutRx
638:               	TachoInterrupt();				// gestisco il conteggio per la velocità del ventilatore
00686A  07F8F2     RCALL TachoInterrupt
639:               	ChkTimer(&TimeOutPktRxSec);
00686C  20A920     MOV #0xA92, W0
00686E  07125E     RCALL ChkTimer
640:               	ChkTimer(&TimeOutModPktRx);
006870  20A980     MOV #0xA98, W0
006872  07125C     RCALL ChkTimer
641:               	ChkTimer(&TimerValvola);
006874  20AEC0     MOV #0xAEC, W0
006876  07125A     RCALL ChkTimer
642:               	ChkTimer(&RefreshVentil);
006878  20ADE0     MOV #0xADE, W0
00687A  071258     RCALL ChkTimer
643:               	ChkTimer(&RefreshPanelRead);	// Timer per la lettura temporizzata dei valori da Panel NetBuilding
00687C  20ECC0     MOV #0xECC, W0
00687E  071256     RCALL ChkTimer
644:               	ChkTimer(&TimerExpValvola);		// Gestione Expansione valvola
006880  20E220     MOV #0xE22, W0
006882  071254     RCALL ChkTimer
645:               	ChkTimer(&TimerSystemCycle);
006884  20ED20     MOV #0xED2, W0
006886  071252     RCALL ChkTimer
646:               	ChkTimer(&TimerExecPID);
006888  20B200     MOV #0xB20, W0
00688A  071250     RCALL ChkTimer
647:               	ClearUart1Err();
00688C  071201     RCALL ClearUart1Err
648:               
649:               	SecDivider +=1;					// gestisco la base tempo di 1 secondo
00688E  8076C4     MOV SecDivider, W4
006890  E80204     INC W4, W4
006892  8876C4     MOV W4, SecDivider
650:               	if(SecDivider >999)				// timer 1 sec
006894  8076C5     MOV SecDivider, W5
006896  203E74     MOV #0x3E7, W4
006898  528F84     SUB W5, W4, [W15]
00689A  34000A     BRA LE, 0x68B0
651:               	{
652:               		SecDivider = 0;
00689C  EB0200     CLR W4
00689E  8876C4     MOV W4, SecDivider
653:               		// Gestisco i timer in sec
654:               		ChkTimer(&TmrLastRequest);	// gestisco il timer per la segnalazione del flag comunication lost
0068A0  20EC00     MOV #0xEC0, W0
0068A2  071244     RCALL ChkTimer
655:               		ChkTimer(&TimerStartUp);	// timer per l'attesa inaziale.
0068A4  20EC60     MOV #0xEC6, W0
0068A6  071242     RCALL ChkTimer
656:               		ChkTimer(&RefreshFineVentil);
0068A8  20AE40     MOV #0xAE4, W0
0068AA  071240     RCALL ChkTimer
657:               		ChkTimer(&TimerTestEEV);
0068AC  20B1A0     MOV #0xB1A, W0
0068AE  07123E     RCALL ChkTimer
658:               		//RefreshRTC(&MyRTC);
659:               	}
660:               
661:               	ComunicationLost = TmrLastRequest.TimeOut;
0068B0  807624     MOV 0xEC4, W4
0068B2  D10204     LSR W4, W4
0068B4  624261     AND.B W4, #0x1, W4
0068B6  FB8204     ZE W4, W4
0068B8  887704     MOV W4, ComunicationLost
662:               	Led_Divider +=1;
0068BA  8076D4     MOV Led_Divider, W4
0068BC  E80204     INC W4, W4
0068BE  8876D4     MOV W4, Led_Divider
663:               	if(ComunicationLost)
0068C0  807704     MOV ComunicationLost, W4
0068C2  520FE0     SUB W4, #0x0, [W15]
0068C4  320015     BRA Z, 0x68F0
664:               	{	if(Led_Divider > 50)
0068C6  8076D5     MOV Led_Divider, W5
0068C8  200324     MOV #0x32, W4
0068CA  528F84     SUB W5, W4, [W15]
0068CC  340025     BRA LE, 0x6918
665:               		{	oPwrLed = !oPwrLed;
0068CE  8017A4     MOV LATG, W4
0068D0  620261     AND W4, #0x1, W4
0068D2  A7F004     BTSC W4, #15
0068D4  EA0204     NEG W4, W4
0068D6  E90204     DEC W4, W4
0068D8  DE224F     LSR W4, #15, W4
0068DA  784204     MOV.B W4, W4
0068DC  FB8204     ZE W4, W4
0068DE  620261     AND W4, #0x1, W4
0068E0  8017A6     MOV LATG, W6
0068E2  2FFFE5     MOV #0xFFFE, W5
0068E4  630285     AND W6, W5, W5
0068E6  720205     IOR W4, W5, W4
0068E8  8817A4     MOV W4, LATG
666:               			Led_Divider = 0;}
0068EA  EB0200     CLR W4
0068EC  8876D4     MOV W4, Led_Divider
0068EE  370014     BRA 0x6918
667:               	}
668:               	else
669:               	{	if(Led_Divider > 200)
0068F0  8076D5     MOV Led_Divider, W5
0068F2  200C84     MOV #0xC8, W4
0068F4  528F84     SUB W5, W4, [W15]
0068F6  340010     BRA LE, 0x6918
670:               		{	oPwrLed = !oPwrLed;
0068F8  8017A4     MOV LATG, W4
0068FA  620261     AND W4, #0x1, W4
0068FC  A7F004     BTSC W4, #15
0068FE  EA0204     NEG W4, W4
006900  E90204     DEC W4, W4
006902  DE224F     LSR W4, #15, W4
006904  784204     MOV.B W4, W4
006906  FB8204     ZE W4, W4
006908  620261     AND W4, #0x1, W4
00690A  8017A6     MOV LATG, W6
00690C  2FFFE5     MOV #0xFFFE, W5
00690E  630285     AND W6, W5, W5
006910  720205     IOR W4, W5, W4
006912  8817A4     MOV W4, LATG
671:               			Led_Divider = 0;}
006914  EB0200     CLR W4
006916  8876D4     MOV W4, Led_Divider
672:               	}
673:               
674:               	IFS0bits.T1IF = 0;				// resetto il flag di interrupt
006918  A96084     BCLR IFS0, #3
675:               	return;
676:               }
00691A  FA8000     ULNK
00691C  F90034     POP PSVPAG
00691E  BE034F     MOV.D [--W15], W6
006920  BE024F     MOV.D [--W15], W4
006922  BE014F     MOV.D [--W15], W2
006924  BE004F     MOV.D [--W15], W0
006926  F90036     POP RCOUNT
006928  064000     RETFIE
---  D:/WORK3/Lavori/TERMODINAMICA/Work/FW/1 - Generico/Split/Split v.8.4.22 - Working/I2C.c  -----------
1:                 /*
2:                 -----------------------------------------------------------------------------
3:                 	Nome: New_I2C.c
4:                 	Autore: Endi Emanuele
5:                 	Revisione\Data:	Rev.2 - 09/05/2010
6:                 	Descrizione: Corpo delle funzioni per la comunicazione su bus I2C
7:                 	Dipendenze: I2C.h - Header di questo file	
8:                 -----------------------------------------------------------------------------
9:                 */
10:                #include "MicroModelSelection.h"
11:                #ifdef GB210
12:                	#include <p24FJ256GB210.h>
13:                #else
14:                	#include <p24FJ256GB110.h>
15:                #endif
16:                #include <stdio.h>		
17:                #include "delay.h"
18:                #include "I2C.h"			// Header del file .c
19:                
20:                /*
21:                -----------------------------------------------------------------------------
22:                	Tipo: procedura	
23:                	Nome: I2C_Init()
24:                	Descrizione: Inizializzazione del modulo SSP per il Bus I2C sui pin SDA1-RB9 e SCL1-RB8
25:                -----------------------------------------------------------------------------
26:                */
27:                void I2C_Init(void)
28:                {
00868C  FA0002     LNK #0x2
29:                	int temp;
30:                	// I2CBRG = 194 for 10Mhz OSCI with PPL with 100kHz I2C clock
31:                	I2C3BRG = DIVIDER_I2C;	// Imposto il divider per generare il clock
00868E  2013C4     MOV #0x13C, W4
008690  8813A4     MOV W4, I2C3BRG
32:                	I2C3CON = 0;
008692  EB0200     CLR W4
008694  8813B4     MOV W4, I2C3CON
33:                	I2C3CONbits.I2CEN = 0;	// Disabilito il modulo I2C
008696  A9E277     BCLR 0x277, #7
34:                	I2C3CONbits.DISSLW = 1;	// Disabilito lo slew rate control
008698  A82277     BSET 0x277, #1
35:                	IFS5bits.MI2C3IF = 0;	// Resetto Interrupt
00869A  A9A08E     BCLR IFS5, #5
36:                	I2C3CONbits.I2CEN = 1;	// Abilito il modulo I2C
00869C  A8E277     BSET 0x277, #7
37:                	temp = I2C3RCV;			// Leggo il buffer per cancellarlo
00869E  801384     MOV I2C3RCV, W4
0086A0  780F04     MOV W4, [W14]
38:                	Reset_I2C_bus();		// Setto il bus in idle
0086A2  070071     RCALL Reset_I2C_bus
39:                }
0086A4  FA8000     ULNK
0086A6  060000     RETURN
40:                
41:                /*
42:                -----------------------------------------------------------------------------
43:                	Tipo: funzione	
44:                	Nome: I2C_Is_Idle()
45:                	Descrizione: Testa se il Bus è libero
46:                	Exit Value:
47:                				  0 -> Il Bus risulta occupato
48:                				255 -> Il bus risulta libero
49:                -----------------------------------------------------------------------------
50:                */
51:                unsigned char I2C_Is_Idle(void)					// restituisce 1 se il bus I2C è libero
52:                {
0086A8  FA0000     LNK #0x0
53:                	if(I2C3STATbits.R_W || 
0086AA  8013C4     MOV I2C3STAT, W4
0086AC  620264     AND W4, #0x4, W4
0086AE  520FE0     SUB W4, #0x0, [W15]
0086B0  3A0014     BRA NZ, 0x86DA
0086B2  8013B4     MOV I2C3CON, W4
0086B4  620270     AND W4, #0x10, W4
0086B6  520FE0     SUB W4, #0x0, [W15]
0086B8  3A0010     BRA NZ, 0x86DA
54:                		I2C3CONbits.ACKEN || 
0086BA  8013B4     MOV I2C3CON, W4
0086BC  620268     AND W4, #0x8, W4
0086BE  520FE0     SUB W4, #0x0, [W15]
0086C0  3A000C     BRA NZ, 0x86DA
55:                		I2C3CONbits.RCEN || 
0086C2  8013B4     MOV I2C3CON, W4
0086C4  620264     AND W4, #0x4, W4
0086C6  520FE0     SUB W4, #0x0, [W15]
0086C8  3A0008     BRA NZ, 0x86DA
56:                		I2C3CONbits.PEN || 
0086CA  8013B4     MOV I2C3CON, W4
0086CC  620262     AND W4, #0x2, W4
0086CE  520FE0     SUB W4, #0x0, [W15]
0086D0  3A0004     BRA NZ, 0x86DA
57:                		I2C3CONbits.RSEN || 
0086D2  8013B4     MOV I2C3CON, W4
0086D4  620261     AND W4, #0x1, W4
0086D6  520FE0     SUB W4, #0x0, [W15]
0086D8  320002     BRA Z, 0x86DE
58:                		I2C3CONbits.SEN)		// testo se uno dei flag di attivata del bus I2C è settato
59:                		return 0;				// nel caso segnalo che il bus è in uso
0086DA  EB4200     CLR.B W4
0086DC  370001     BRA 0x86E0
60:                	else
61:                		return 255;				// o segnalo che è libero
0086DE  EBC200     SETM.B W4
62:                }
0086E0  784004     MOV.B W4, W0
0086E2  FA8000     ULNK
0086E4  060000     RETURN
63:                
64:                /*
65:                -----------------------------------------------------------------------------
66:                	Tipo: funzione	
67:                	Nome: I2C_Start()
68:                	Descrizione: Genera lo start e attende che venga geerato correttamente.
69:                	Exit Value:
70:                				0 -> Eseguita con successo
71:                				1 -> Time Out durante la generazione dello start
72:                -----------------------------------------------------------------------------
73:                */
74:                //function iniates a start condition on bus
75:                unsigned char I2C_Start(void)
76:                {
0086E6  FA0002     LNK #0x2
77:                	int x = 0;
0086E8  EB0200     CLR W4
0086EA  780F04     MOV W4, [W14]
78:                
79:                	I2C3CONbits.ACKDT = 0;	// Resetto ogni ACK precedente
0086EC  A9A276     BCLR I2C3CON, #5
80:                	DelayuSec(10);
0086EE  201400     MOV #0x140, W0
0086F0  200001     MOV #0x0, W1
0086F2  07033E     RCALL ___delay32
81:                	I2C3CONbits.SEN = 1;	// Inizializzo la condizione di start
0086F4  A80276     BSET I2C3CON, #0
82:                	Nop();
0086F6  000000     NOP
83:                	while (I2C3CONbits.SEN)	// Attendo la fine dello start
0086F8  370009     BRA 0x870C
00870C  8013B4     MOV I2C3CON, W4
00870E  620261     AND W4, #0x1, W4
008710  520FE0     SUB W4, #0x0, [W15]
008712  3AFFF3     BRA NZ, 0x86FA
84:                	{	DelayuSec(1);
0086FA  200200     MOV #0x20, W0
0086FC  200001     MOV #0x0, W1
0086FE  070338     RCALL ___delay32
85:                		x++;
008700  E80F1E     INC [W14], [W14]
86:                		if (x > 20)
008702  78021E     MOV [W14], W4
008704  520FF4     SUB W4, #0x14, [W15]
008706  340002     BRA LE, 0x870C
87:                			return 1;		// Se lo start dura più di 20 uSec
008708  B3C014     MOV.B #0x1, W4
00870A  370008     BRA 0x871C
88:                	}
89:                	DelayuSec(2);
008714  200400     MOV #0x40, W0
008716  200001     MOV #0x0, W1
008718  07032B     RCALL ___delay32
90:                	return 0;
00871A  EB4200     CLR.B W4
91:                }
00871C  784004     MOV.B W4, W0
00871E  FA8000     ULNK
008720  060000     RETURN
92:                
93:                /*
94:                -----------------------------------------------------------------------------
95:                	Tipo: funzione
96:                	Nome: I2C_Repeated_Start()
97:                	Descrizione: Genera il segnale di Repeted Start sul bus I2C e attende 
98:                				 che venga generato correttamente.
99:                	Exit value:
100:               				0 -> Eseguita con successo
101:               				1 -> Time Out durante la generazione del repeted start
102:               -----------------------------------------------------------------------------
103:               */
104:               unsigned char I2C_Repeated_Start(void)
105:               {
008722  FA0002     LNK #0x2
106:               	int x = 0;
008724  EB0200     CLR W4
008726  780F04     MOV W4, [W14]
107:               
108:               	I2C3CONbits.RSEN = 1;		// Inizializzo la condizione di repeted start
008728  A82276     BSET I2C3CON, #1
109:               	Nop();
00872A  000000     NOP
110:               	while (I2C3CONbits.RSEN)	// Attendo la fine del repeted start
00872C  370009     BRA 0x8740
008740  8013B4     MOV I2C3CON, W4
008742  620262     AND W4, #0x2, W4
008744  520FE0     SUB W4, #0x0, [W15]
008746  3AFFF3     BRA NZ, 0x872E
111:               	{	DelayuSec(1);
00872E  200200     MOV #0x20, W0
008730  200001     MOV #0x0, W1
008732  07031E     RCALL ___delay32
112:               		x++;
008734  E80F1E     INC [W14], [W14]
113:               		if (x > 20) 
008736  78021E     MOV [W14], W4
008738  520FF4     SUB W4, #0x14, [W15]
00873A  340002     BRA LE, 0x8740
114:               			return 1;
00873C  B3C014     MOV.B #0x1, W4
00873E  370008     BRA 0x8750
115:               	}
116:               	DelayuSec(2);
008748  200400     MOV #0x40, W0
00874A  200001     MOV #0x0, W1
00874C  070311     RCALL ___delay32
117:               	return 0;
00874E  EB4200     CLR.B W4
118:               }
008750  784004     MOV.B W4, W0
008752  FA8000     ULNK
008754  060000     RETURN
119:               
120:               /*
121:               -----------------------------------------------------------------------------
122:               	Tipo: funzione	
123:               	Nome: I2C_Stop()
124:               	Descrizione: Genera il segnale di Stop sul bus I2C e attende che venga 
125:               				 generato correttamente
126:               	Exit value:
127:               				0 -> Eseguita con successo
128:               				1 -> Time Out durante l'operazione
129:               -----------------------------------------------------------------------------
130:               */
131:               void I2C_Stop(void)
132:               {
008756  FA0002     LNK #0x2
133:               	int x = 0;
008758  EB0200     CLR W4
00875A  780F04     MOV W4, [W14]
134:               	
135:               	I2C3CONbits.PEN = 1;	// Mando un bit di stop
00875C  A84276     BSET I2C3CON, #2
136:               	Nop();
00875E  000000     NOP
137:               	while (I2C3CONbits.PEN)	// Attendo la conclusione
008760  370007     BRA 0x8770
008770  8013B4     MOV I2C3CON, W4
008772  620264     AND W4, #0x4, W4
008774  520FE0     SUB W4, #0x0, [W15]
008776  3AFFF5     BRA NZ, 0x8762
008778  370001     BRA 0x877C
138:               	{	DelayuSec(1);
008762  200200     MOV #0x20, W0
008764  200001     MOV #0x0, W1
008766  070304     RCALL ___delay32
139:               		x ++;
008768  E80F1E     INC [W14], [W14]
140:               		if (x > 20) 
00876A  78021E     MOV [W14], W4
00876C  520FF4     SUB W4, #0x14, [W15]
00876E  3C0005     BRA GT, 0x877A
141:               			break;
00877A  000000     NOP
142:               	}
143:               	DelayuSec(10);
00877C  201400     MOV #0x140, W0
00877E  200001     MOV #0x0, W1
008780  0702F7     RCALL ___delay32
144:               }
008782  FA8000     ULNK
008784  060000     RETURN
145:               
146:               /*
147:               -----------------------------------------------------------------------------
148:               	Tipo: procedura
149:               	Nome: Reset_I2C_bus()
150:               	Descrizione: Resetta il bus
151:               -----------------------------------------------------------------------------
152:               */
153:               void Reset_I2C_bus(void)
154:               {
008786  FA0002     LNK #0x2
155:               	int x = 0;
008788  EB0200     CLR W4
00878A  780F04     MOV W4, [W14]
156:               	
157:               	I2C3CONbits.PEN = 1;	// Mando un bit di stop
00878C  A84276     BSET I2C3CON, #2
158:               	Nop();
00878E  000000     NOP
159:               	while (I2C3CONbits.PEN)	// Attendo la conclusione
008790  370007     BRA 0x87A0
0087A0  8013B4     MOV I2C3CON, W4
0087A2  620264     AND W4, #0x4, W4
0087A4  520FE0     SUB W4, #0x0, [W15]
0087A6  3AFFF5     BRA NZ, 0x8792
0087A8  370001     BRA 0x87AC
160:               	{	DelayuSec(1);
008792  200200     MOV #0x20, W0
008794  200001     MOV #0x0, W1
008796  0702EC     RCALL ___delay32
161:               		x ++;
008798  E80F1E     INC [W14], [W14]
162:               		if (x > 20) break;
00879A  78021E     MOV [W14], W4
00879C  520FF4     SUB W4, #0x14, [W15]
00879E  3C0005     BRA GT, 0x87AA
0087AA  000000     NOP
163:               	}
164:               	I2C3CONbits.RCEN = 0;
0087AC  A96276     BCLR I2C3CON, #3
165:               	IFS5bits.MI2C3IF = 0;	// Reseto l'interrupt
0087AE  A9A08E     BCLR IFS5, #5
166:               	I2C3STATbits.IWCOL = 0;
0087B0  A9E278     BCLR I2C3STAT, #7
167:               	I2C3STATbits.BCL = 0;
0087B2  A94279     BCLR 0x279, #2
168:               	DelayuSec(10);
0087B4  201400     MOV #0x140, W0
0087B6  200001     MOV #0x0, W1
0087B8  0702DB     RCALL ___delay32
169:               }
0087BA  FA8000     ULNK
0087BC  060000     RETURN
170:               
171:               /*
172:               -----------------------------------------------------------------------------
173:               	Tipo: funzione	
174:               	Nome: I2C_Write(Data)
175:               	Descrizione: Scrive il Byte Data sul Bus I2C
176:               	Exit Value:
177:               				0 -> Eseguita con successo
178:               				1 -> Time Out durante la trasmissione
179:               				2 -> Non ho ricevuto l'ACK dallo Slave
180:               -----------------------------------------------------------------------------
181:               */
182:               unsigned char I2C_Write(unsigned char Data)	// Scrivo un byte
183:               {
0087BE  FA0004     LNK #0x4
0087C0  984720     MOV.B W0, [W14+2]
184:               	int i;
185:               
186:               	DelayuSec(10);
0087C2  201400     MOV #0x140, W0
0087C4  200001     MOV #0x0, W1
0087C6  0702D4     RCALL ___delay32
187:               	while (I2C3STATbits.TBF)
0087C8  000000     NOP
0087CA  370001     BRA 0x87CE
0087CE  8013C4     MOV I2C3STAT, W4
0087D0  620261     AND W4, #0x1, W4
0087D2  520FE0     SUB W4, #0x0, [W15]
0087D4  3AFFFB     BRA NZ, 0x87CC
188:               		continue;
0087CC  000000     NOP
189:               	IFS5bits.MI2C3IF = 0;		// Resetto l'interrupt
0087D6  A9A08E     BCLR IFS5, #5
190:               	I2C3TRN = Data;				// Carico i dati da trasmettere
0087D8  90422E     MOV.B [W14+2], W4
0087DA  FB8204     ZE W4, W4
0087DC  881394     MOV W4, I2C3TRN
191:               	Nop();
0087DE  000000     NOP
192:               	for (i=0; i<500; i++)		// Attendo la fine della trasmissione del byte
0087E0  EB0200     CLR W4
0087E2  780F04     MOV W4, [W14]
0087E4  370009     BRA 0x87F8
0087F6  E80F1E     INC [W14], [W14]
0087F8  201F34     MOV #0x1F3, W4
0087FA  78029E     MOV [W14], W5
0087FC  528F84     SUB W5, W4, [W15]
0087FE  34FFF3     BRA LE, 0x87E6
008800  370001     BRA 0x8804
193:               	{	if (!I2C3STATbits.TRSTAT) 
0087E6  8013C5     MOV I2C3STAT, W5
0087E8  240004     MOV #0x4000, W4
0087EA  628204     AND W5, W4, W4
0087EC  520FE0     SUB W4, #0x0, [W15]
0087EE  320009     BRA Z, 0x8802
194:               			break;
008802  000000     NOP
195:               		DelayuSec(1);
0087F0  200200     MOV #0x20, W0
0087F2  200001     MOV #0x0, W1
0087F4  0702BD     RCALL ___delay32
196:               	}
197:               	if(i>=499)
008804  201F24     MOV #0x1F2, W4
008806  78029E     MOV [W14], W5
008808  528F84     SUB W5, W4, [W15]
00880A  340002     BRA LE, 0x8810
198:               		return 1;				// Se non ho completato il send
00880C  B3C014     MOV.B #0x1, W4
00880E  37000B     BRA 0x8826
199:               	
200:               	if(I2C3STATbits.ACKSTAT)	// Controllo se ho ricevuto Nack
008810  8013C5     MOV I2C3STAT, W5
008812  280004     MOV #0x8000, W4
008814  628204     AND W5, W4, W4
008816  520FE0     SUB W4, #0x0, [W15]
008818  320002     BRA Z, 0x881E
201:               		return 2;				// Se non ho ricevuto l'ACK
00881A  B3C024     MOV.B #0x2, W4
00881C  370004     BRA 0x8826
202:               	DelayuSec(2);
00881E  200400     MOV #0x40, W0
008820  200001     MOV #0x0, W1
008822  0702A6     RCALL ___delay32
203:               	return 0;					// Esco segnalando la corretta conclusione della funzione
008824  EB4200     CLR.B W4
204:               }
008826  784004     MOV.B W4, W0
008828  FA8000     ULNK
00882A  060000     RETURN
205:               
206:               /*
207:               -----------------------------------------------------------------------------
208:               	Tipo: funzione	
209:               	Nome: I2C_Read(Ack)
210:               	Descrizione: Riceve un Byte dal Bus I2C
211:               	Exit Value: Data Read
212:               	Ack ->	0 ==> MACK	- flag inviato per proseguire la lettura
213:               			1 ==> NMACK	- flag inviato per terminare la lettura
214:               -----------------------------------------------------------------------------
215:               */
216:               
217:               unsigned char I2C_Read(unsigned char Ack)	// leggo un byte e rispondo con MACK o NMACK
218:               {
00882C  FA0006     LNK #0x6
00882E  984740     MOV.B W0, [W14+4]
219:               	int LoopCnt = 0;
008830  EB0200     CLR W4
008832  780F04     MOV W4, [W14]
220:               	unsigned char ReciveDt;
221:               
222:               	I2C3CONbits.RCEN = 1;		// abilita la ricezione dati
008834  A86276     BSET I2C3CON, #3
223:               	Nop();
008836  000000     NOP
224:               	Nop();
008838  000000     NOP
225:               	while(!I2C3STATbits.RBF)	// attendi l'evento ricezione dati
00883A  370005     BRA 0x8846
008846  8013C4     MOV I2C3STAT, W4
008848  620262     AND W4, #0x2, W4
00884A  520FE0     SUB W4, #0x0, [W15]
00884C  32FFF7     BRA Z, 0x883C
00884E  370001     BRA 0x8852
226:               	{	LoopCnt ++;
00883C  E80F1E     INC [W14], [W14]
227:               		if(LoopCnt > 2000)
00883E  207D04     MOV #0x7D0, W4
008840  78029E     MOV [W14], W5
008842  528F84     SUB W5, W4, [W15]
008844  3C0005     BRA GT, 0x8850
228:               			break;
008850  000000     NOP
229:               	}
230:               
231:               	ReciveDt = I2C3RCV;			// copio i dati ricevuti
008852  801384     MOV I2C3RCV, W4
008854  984724     MOV.B W4, [W14+2]
232:               
233:               	if(!Ack)
008856  90424E     MOV.B [W14+4], W4
008858  524FE0     SUB.B W4, #0x0, [W15]
00885A  3A0004     BRA NZ, 0x8864
234:               	{	I2C3CONbits.ACKEN = 1;	// avvio la trasmissione del segnale di Ack
00885C  A88276     BSET I2C3CON, #4
235:               		DelayuSec(10);
00885E  201400     MOV #0x140, W0
008860  200001     MOV #0x0, W1
008862  070286     RCALL ___delay32
236:               	}
237:               	return ReciveDt;			// restituisco il byte letto
008864  90422E     MOV.B [W14+2], W4
238:               }
008866  784004     MOV.B W4, W0
008868  FA8000     ULNK
00886A  060000     RETURN
239:               
240:               /*
241:               -----------------------------------------------------------------------------
242:               	Tipo: funzione
243:               	Nome: SetRegI2C(Address, Reg, Data)
244:               	Descrizione: Scrive il byte Data nel registro Reg del dispositivo con indirizzo Addres
245:               	Exit Value: 
246:               				0 -> Eseguita con successo
247:               				1 -> Bus is Busy
248:               				2 -> Errore durante la scrittura dell'indirizzo
249:               				3 -> Errore durante la scrittura del registro da impostare
250:               				4 -> Errore durante la scrittura dei dati
251:               	Parametri:
252:               				Address	->	Indirizzo del dispositivo
253:               				Reg		->	Registro da scrivere
254:               				Data	->	Valore da scrivere nel registro
255:               -----------------------------------------------------------------------------
256:               */
257:               unsigned char SetRegI2C(unsigned char Address, unsigned char Reg, unsigned char Data)
258:               {
00886C  FA0008     LNK #0x8
00886E  984740     MOV.B W0, [W14+4]
008870  984751     MOV.B W1, [W14+5]
008872  984762     MOV.B W2, [W14+6]
259:               	unsigned char TmpSt = 0;
008874  EB4200     CLR.B W4
008876  984724     MOV.B W4, [W14+2]
260:               	int i = 0;
008878  EB0200     CLR W4
00887A  780F04     MOV W4, [W14]
261:               	TmpSt = I2C_Start();			// Start
00887C  07FF34     RCALL I2C_Start
00887E  784200     MOV.B W0, W4
008880  984724     MOV.B W4, [W14+2]
262:               	if(TmpSt != 0)
008882  90422E     MOV.B [W14+2], W4
008884  524FE0     SUB.B W4, #0x0, [W15]
008886  320002     BRA Z, 0x888C
263:               		return 1;
008888  B3C014     MOV.B #0x1, W4
00888A  370031     BRA 0x88EE
264:               	TmpSt = I2C_Write(Address);		// Invio Indirizzo + W
00888C  90404E     MOV.B [W14+4], W0
00888E  07FF97     RCALL I2C_Write
008890  784200     MOV.B W0, W4
008892  984724     MOV.B W4, [W14+2]
265:               	if(TmpSt != 0)
008894  90422E     MOV.B [W14+2], W4
008896  524FE0     SUB.B W4, #0x0, [W15]
008898  320002     BRA Z, 0x889E
266:               		return 2;
00889A  B3C024     MOV.B #0x2, W4
00889C  370028     BRA 0x88EE
267:               	TmpSt = I2C_Write(Reg);			// Invio registro
00889E  90405E     MOV.B [W14+5], W0
0088A0  07FF8E     RCALL I2C_Write
0088A2  784200     MOV.B W0, W4
0088A4  984724     MOV.B W4, [W14+2]
268:               	if(TmpSt != 0)
0088A6  90422E     MOV.B [W14+2], W4
0088A8  524FE0     SUB.B W4, #0x0, [W15]
0088AA  320002     BRA Z, 0x88B0
269:               		return 3;
0088AC  B3C034     MOV.B #0x3, W4
0088AE  37001F     BRA 0x88EE
270:               	TmpSt = I2C_Write(Data);		// Invio Dati
0088B0  90406E     MOV.B [W14+6], W0
0088B2  07FF85     RCALL I2C_Write
0088B4  784200     MOV.B W0, W4
0088B6  984724     MOV.B W4, [W14+2]
271:               	if(TmpSt != 0)
0088B8  90422E     MOV.B [W14+2], W4
0088BA  524FE0     SUB.B W4, #0x0, [W15]
0088BC  320002     BRA Z, 0x88C2
272:               		return 4;
0088BE  B3C044     MOV.B #0x4, W4
0088C0  370016     BRA 0x88EE
273:               	I2C_Stop();						// Invio Stop
0088C2  07FF49     RCALL I2C_Stop
274:               	for(i=0; i<100; i++)			// attendo max 10 mSec
0088C4  EB0200     CLR W4
0088C6  780F04     MOV W4, [W14]
0088C8  37000D     BRA 0x88E4
0088E2  E80F1E     INC [W14], [W14]
0088E4  200634     MOV #0x63, W4
0088E6  78029E     MOV [W14], W5
0088E8  528F84     SUB W5, W4, [W15]
0088EA  34FFEF     BRA LE, 0x88CA
275:               	{
276:               		TmpSt = I2C_Start();			// Start
0088CA  07FF0D     RCALL I2C_Start
0088CC  784200     MOV.B W0, W4
0088CE  984724     MOV.B W4, [W14+2]
277:               		TmpSt = I2C_Write(Address);		// Invio Indirizzo + W
0088D0  90404E     MOV.B [W14+4], W0
0088D2  07FF75     RCALL I2C_Write
0088D4  784200     MOV.B W0, W4
0088D6  984724     MOV.B W4, [W14+2]
278:               		if(TmpSt == 0)
0088D8  90422E     MOV.B [W14+2], W4
0088DA  524FE0     SUB.B W4, #0x0, [W15]
0088DC  3A0002     BRA NZ, 0x88E2
279:               			return 0;	
0088DE  EB4200     CLR.B W4
0088E0  370006     BRA 0x88EE
280:               	}
281:               	return 5;
0088EC  B3C054     MOV.B #0x5, W4
282:               }
0088EE  784004     MOV.B W4, W0
0088F0  FA8000     ULNK
0088F2  060000     RETURN
283:               
284:               /*
285:               -----------------------------------------------------------------------------
286:               	Tipo: funzione	
287:               	Nome: ReadRegI2C(Address, Re)
288:               	Descrizione: Riceve un Byte dal Bus I2C
289:               	Exit Value: 
290:               				Data	->	Valore letto dal bus I2C
291:               	Parametri:
292:               				Addres	->	Indirizzo del dispositivo
293:               				Reg		->	Registro da leggere
294:               -----------------------------------------------------------------------------
295:               */
296:               unsigned char ReadRegI2C(unsigned char Address, unsigned char Reg)
297:               {
0088F4  FA0004     LNK #0x4
0088F6  984720     MOV.B W0, [W14+2]
0088F8  984731     MOV.B W1, [W14+3]
298:               	unsigned char RxBuff = 0;
0088FA  EB4200     CLR.B W4
0088FC  784F04     MOV.B W4, [W14]
299:               
300:               	I2C_Start();				// invio Start
0088FE  07FEF3     RCALL I2C_Start
301:               	I2C_Write(Address);			// invio indirizzo + W
008900  90402E     MOV.B [W14+2], W0
008902  07FF5D     RCALL I2C_Write
302:               	I2C_Write(Reg);				// invio Registro da leggere
008904  90403E     MOV.B [W14+3], W0
008906  07FF5B     RCALL I2C_Write
303:               	DelayuSec(10);
008908  201400     MOV #0x140, W0
00890A  200001     MOV #0x0, W1
00890C  070231     RCALL ___delay32
304:               	I2C_Repeated_Start();		// invio RepeatedStart
00890E  07FF09     RCALL I2C_Repeated_Start
305:               	I2C_Write(Address+1);		// invio Indirizzo + R
008910  90422E     MOV.B [W14+2], W4
008912  E84204     INC.B W4, W4
008914  784004     MOV.B W4, W0
008916  07FF53     RCALL I2C_Write
306:               	RxBuff = I2C_Read(NMACK);	// Leggo i Dati
008918  B3C010     MOV.B #0x1, W0
00891A  07FF88     RCALL I2C_Read
00891C  784200     MOV.B W0, W4
00891E  784F04     MOV.B W4, [W14]
307:               	I2C_Stop();
008920  07FF1A     RCALL I2C_Stop
308:               
309:               	return RxBuff;
008922  78421E     MOV.B [W14], W4
310:               }
008924  784004     MOV.B W4, W0
008926  FA8000     ULNK
008928  060000     RETURN
---  D:/WORK3/Lavori/TERMODINAMICA/Work/FW/1 - Generico/Split/Split v.8.4.22 - Working/EEPROM.c  --------
1:                 //----------------------------------------------------------------------------------
2:                 //	Progect name:	EEPROM.h
3:                 //	Device:			PIC18F4550 @ 20Mhz (PLL 96 Mhz)
4:                 //	Autor:			Emanuele
5:                 //	Date:			22/05/2011
6:                 //	Description:	Corpo delle funzioni per l'allocazione della E2 del micro
7:                 //----------------------------------------------------------------------------------
8:                 #include "MicroModelSelection.h"
9:                 #ifdef GB210
10:                	#include <p24FJ256GB210.h>
11:                #else
12:                	#include <p24FJ256GB110.h>
13:                #endif
14:                #include <stdio.h>
15:                #include "DefinePeriferiche.h"
16:                #include "delay.h"
17:                #include "ADC.h"
18:                #include "I2C.h"
19:                #include "PWM.h"
20:                #include "Valvola_PassoPasso.h"
21:                #include "EEPROM.h"
22:                #include "Core.h"
23:                
24:                //----------------------------------------------------------------------------------
25:                //	Funzioni
26:                //----------------------------------------------------------------------------------
27:                char HiByte(int Data)
28:                {
00692A  FA0002     LNK #0x2
00692C  780F00     MOV W0, [W14]
29:                	return (char)((Data & 0xFF00) >> 8);
00692E  78021E     MOV [W14], W4
006930  DE2248     LSR W4, #8, W4
006932  784204     MOV.B W4, W4
30:                }
006934  784004     MOV.B W4, W0
006936  FA8000     ULNK
006938  060000     RETURN
31:                
32:                char LoByte(int Data)
33:                {
00693A  FA0002     LNK #0x2
00693C  780F00     MOV W0, [W14]
34:                	return (char)(Data & 0x00FF);
00693E  78021E     MOV [W14], W4
006940  784204     MOV.B W4, W4
35:                }
006942  784004     MOV.B W4, W0
006944  FA8000     ULNK
006946  060000     RETURN
36:                
37:                int ToInt(char HiByte, char LoByte)
38:                {
006948  FA0002     LNK #0x2
00694A  784F00     MOV.B W0, [W14]
00694C  984711     MOV.B W1, [W14+1]
39:                //	return (((int)HiByte) <<8 )| (LoByte&0x00FF);
40:                	return ((((int)HiByte) <<8 ) & 0xFF00) | (LoByte&0x00FF);	// Modifica 05/01/2015 Aggiunta mascheratura byte shift
00694E  FB021E     SE [W14], W4
006950  DD2248     SL W4, #8, W4
006952  780284     MOV W4, W5
006954  90421E     MOV.B [W14+1], W4
006956  FB0304     SE W4, W6
006958  200FF4     MOV #0xFF, W4
00695A  630204     AND W6, W4, W4
00695C  720205     IOR W4, W5, W4
41:                }
00695E  780004     MOV W4, W0
006960  FA8000     ULNK
006962  060000     RETURN
42:                
43:                void StoreInt(int Data, int Address)
44:                {
006964  FA0006     LNK #0x6
006966  980710     MOV W0, [W14+2]
006968  980721     MOV W1, [W14+4]
45:                	unsigned char ByteLow, ByteHigh;
46:                
47:                	ByteLow = LoByte(Data);
00696A  90001E     MOV [W14+2], W0
00696C  07FFE6     RCALL LoByte
00696E  784200     MOV.B W0, W4
006970  784F04     MOV.B W4, [W14]
48:                	ByteHigh = HiByte(Data);
006972  90001E     MOV [W14+2], W0
006974  07FFDA     RCALL HiByte
006976  784200     MOV.B W0, W4
006978  984714     MOV.B W4, [W14+1]
49:                	
50:                	SetRegI2C(EEPROM_Add, Address, ByteHigh);
00697A  90022E     MOV [W14+4], W4
00697C  784204     MOV.B W4, W4
00697E  90411E     MOV.B [W14+1], W2
006980  784084     MOV.B W4, W1
006982  B3CA00     MOV.B #0xA0, W0
006984  070F73     RCALL SetRegI2C
51:                	SetRegI2C(EEPROM_Add, Address +1, ByteLow);
006986  90022E     MOV [W14+4], W4
006988  784204     MOV.B W4, W4
00698A  E84204     INC.B W4, W4
00698C  78411E     MOV.B [W14], W2
00698E  784084     MOV.B W4, W1
006990  B3CA00     MOV.B #0xA0, W0
006992  070F6C     RCALL SetRegI2C
52:                }
006994  FA8000     ULNK
006996  060000     RETURN
53:                
54:                int LoadInt(int Address)
55:                {
006998  FA0004     LNK #0x4
00699A  980710     MOV W0, [W14+2]
56:                	char ByteLow, ByteHigh;
57:                
58:                	ByteHigh = ReadRegI2C(EEPROM_Add, Address);
00699C  90021E     MOV [W14+2], W4
00699E  784204     MOV.B W4, W4
0069A0  784084     MOV.B W4, W1
0069A2  B3CA00     MOV.B #0xA0, W0
0069A4  070FA7     RCALL ReadRegI2C
0069A6  784200     MOV.B W0, W4
0069A8  784F04     MOV.B W4, [W14]
59:                	ByteLow = ReadRegI2C(EEPROM_Add, Address +1);
0069AA  90021E     MOV [W14+2], W4
0069AC  784204     MOV.B W4, W4
0069AE  E84204     INC.B W4, W4
0069B0  784084     MOV.B W4, W1
0069B2  B3CA00     MOV.B #0xA0, W0
0069B4  070F9F     RCALL ReadRegI2C
0069B6  784200     MOV.B W0, W4
0069B8  984714     MOV.B W4, [W14+1]
60:                	
61:                	return ToInt(ByteHigh, ByteLow);
0069BA  90409E     MOV.B [W14+1], W1
0069BC  78401E     MOV.B [W14], W0
0069BE  07FFC4     RCALL ToInt
0069C0  780200     MOV W0, W4
62:                }
0069C2  780004     MOV W4, W0
0069C4  FA8000     ULNK
0069C6  060000     RETURN
63:                
64:                void LoadAllE2_Data(void)
65:                {
0069C8  FA0002     LNK #0x2
0069CA  781F88     MOV W8, [W15++]
66:                	char i=0;
0069CC  EB4200     CLR.B W4
0069CE  784F04     MOV.B W4, [W14]
67:                
68:                	oErrLed=0;
0069D0  A922F4     BCLR LATG, #1
69:                
70:                	CRC_Flash = LoadInt(CRC_Hi_Flash);
0069D2  EB0000     CLR W0
0069D4  07FFE1     RCALL LoadInt
0069D6  780200     MOV W0, W4
0069D8  885544     MOV W4, CRC_Flash
71:                	SN1 = ReadRegI2C(EEPROM_Add, System_SN_1);
0069DA  B3C021     MOV.B #0x2, W1
0069DC  B3CA00     MOV.B #0xA0, W0
0069DE  070F8A     RCALL ReadRegI2C
0069E0  784200     MOV.B W0, W4
0069E2  784304     MOV.B W4, W6
0069E4  20AAA5     MOV #0xAAA, W5
0069E6  784A86     MOV.B W6, [W5]
72:                	SN2 = ReadRegI2C(EEPROM_Add, System_SN_2);
0069E8  B3C031     MOV.B #0x3, W1
0069EA  B3CA00     MOV.B #0xA0, W0
0069EC  070F83     RCALL ReadRegI2C
0069EE  784200     MOV.B W0, W4
0069F0  784304     MOV.B W4, W6
0069F2  20AAB5     MOV #0xAAB, W5
0069F4  784A86     MOV.B W6, [W5]
73:                	SN3 = ReadRegI2C(EEPROM_Add, System_SN_3);
0069F6  B3C041     MOV.B #0x4, W1
0069F8  B3CA00     MOV.B #0xA0, W0
0069FA  070F7C     RCALL ReadRegI2C
0069FC  784200     MOV.B W0, W4
0069FE  784304     MOV.B W4, W6
006A00  20AAC5     MOV #0xAAC, W5
006A02  784A86     MOV.B W6, [W5]
74:                	SN4 = ReadRegI2C(EEPROM_Add, System_SN_4);
006A04  B3C051     MOV.B #0x5, W1
006A06  B3CA00     MOV.B #0xA0, W0
006A08  070F75     RCALL ReadRegI2C
006A0A  784200     MOV.B W0, W4
006A0C  784304     MOV.B W4, W6
006A0E  20AAD5     MOV #0xAAD, W5
006A10  784A86     MOV.B W6, [W5]
75:                	GiornoFabbricazione = ReadRegI2C(EEPROM_Add, Fab_Day);
006A12  B3C061     MOV.B #0x6, W1
006A14  B3CA00     MOV.B #0xA0, W0
006A16  070F6E     RCALL ReadRegI2C
006A18  784200     MOV.B W0, W4
006A1A  FB8204     ZE W4, W4
006A1C  885574     MOV W4, GiornoFabbricazione
76:                	MeseFabbricazione = ReadRegI2C(EEPROM_Add, Fab_Month);
006A1E  B3C071     MOV.B #0x7, W1
006A20  B3CA00     MOV.B #0xA0, W0
006A22  070F68     RCALL ReadRegI2C
006A24  784200     MOV.B W0, W4
006A26  FB8204     ZE W4, W4
006A28  885584     MOV W4, MeseFabbricazione
77:                	AnnoFabbricazione = ReadRegI2C(EEPROM_Add, Fab_Year);
006A2A  B3C081     MOV.B #0x8, W1
006A2C  B3CA00     MOV.B #0xA0, W0
006A2E  070F62     RCALL ReadRegI2C
006A30  784200     MOV.B W0, W4
006A32  FB8204     ZE W4, W4
006A34  885594     MOV W4, AnnoFabbricazione
78:                
79:                	// Inizializzazione parametri di lavoro da K e non più da caricamento EEPROM
80:                
81:                	// Vedi "InitValvola()"  in Valvola_PassoPasso.c
82:                	//StepRefreshTime = ReadRegI2C(EEPROM_Add, ValvoleStepRefreshTime);
83:                	//ValvolaMaxStepNum = LoadInt(ValvolaMaxStepNum_Hi);
84:                
85:                	//SogliaCorrenteVentil = LoadInt(VentilMinCorrente_Hi);
86:                	SogliaCorrenteVentil = K_FanCurrentThreshold;		// NON UTILIZZATO!
006A36  217704     MOV #0x1770, W4
006A38  8855B4     MOV W4, SogliaCorrenteVentil
87:                
88:                	for(i=0; i<12; i++)
006A3A  EB4200     CLR.B W4
006A3C  784F04     MOV.B W4, [W14]
006A3E  37000C     BRA 0x6A58
006A56  E84F1E     INC.B [W14], [W14]
006A58  78421E     MOV.B [W14], W4
006A5A  524FEB     SUB.B W4, #0xB, [W15]
006A5C  34FFF1     BRA LE, 0x6A40
89:                		AD_T_Piccolo[i] = LoadInt(AD_T_Piccolo_0_Hi+(2*i));
006A40  FB041E     SE [W14], W8
006A42  FB021E     SE [W14], W4
006A44  420204     ADD W4, W4, W4
006A46  420269     ADD W4, #0x9, W4
006A48  780004     MOV W4, W0
006A4A  07FFA6     RCALL LoadInt
006A4C  780200     MOV W0, W4
006A4E  440308     ADD W8, W8, W6
006A50  208785     MOV #0x878, W5
006A52  430285     ADD W6, W5, W5
006A54  780A84     MOV W4, [W5]
90:                	for(i=0; i<12; i++)
006A5E  EB4200     CLR.B W4
006A60  784F04     MOV.B W4, [W14]
006A62  37000C     BRA 0x6A7C
006A7A  E84F1E     INC.B [W14], [W14]
006A7C  78421E     MOV.B [W14], W4
006A7E  524FEB     SUB.B W4, #0xB, [W15]
006A80  34FFF1     BRA LE, 0x6A64
91:                		AD_T_Grande[i] = LoadInt(AD_T_Grande_0_Hi+(2*i));
006A64  FB041E     SE [W14], W8
006A66  FB021E     SE [W14], W4
006A68  420204     ADD W4, W4, W4
006A6A  B00214     ADD #0x21, W4
006A6C  780004     MOV W4, W0
006A6E  07FF94     RCALL LoadInt
006A70  780200     MOV W0, W4
006A72  440308     ADD W8, W8, W6
006A74  208905     MOV #0x890, W5
006A76  430285     ADD W6, W5, W5
006A78  780A84     MOV W4, [W5]
92:                	for(i=0; i<12; i++)
006A82  EB4200     CLR.B W4
006A84  784F04     MOV.B W4, [W14]
006A86  37000C     BRA 0x6AA0
006A9E  E84F1E     INC.B [W14], [W14]
006AA0  78421E     MOV.B [W14], W4
006AA2  524FEB     SUB.B W4, #0xB, [W15]
006AA4  34FFF1     BRA LE, 0x6A88
93:                		AD_T_Out[i] = LoadInt(AD_T_Out_0_Hi+(2*i));
006A88  FB041E     SE [W14], W8
006A8A  FB021E     SE [W14], W4
006A8C  420204     ADD W4, W4, W4
006A8E  B00394     ADD #0x39, W4
006A90  780004     MOV W4, W0
006A92  07FF82     RCALL LoadInt
006A94  780200     MOV W0, W4
006A96  440308     ADD W8, W8, W6
006A98  208A85     MOV #0x8A8, W5
006A9A  430285     ADD W6, W5, W5
006A9C  780A84     MOV W4, [W5]
94:                	for(i=0; i<12; i++)
006AA6  EB4200     CLR.B W4
006AA8  784F04     MOV.B W4, [W14]
006AAA  37000C     BRA 0x6AC4
006AC2  E84F1E     INC.B [W14], [W14]
006AC4  78421E     MOV.B [W14], W4
006AC6  524FEB     SUB.B W4, #0xB, [W15]
006AC8  34FFF1     BRA LE, 0x6AAC
95:                		AD_T_Amb[i] = LoadInt(AD_T_Amb_0_Hi+(2*i));
006AAC  FB041E     SE [W14], W8
006AAE  FB021E     SE [W14], W4
006AB0  420204     ADD W4, W4, W4
006AB2  B00514     ADD #0x51, W4
006AB4  780004     MOV W4, W0
006AB6  07FF70     RCALL LoadInt
006AB8  780200     MOV W0, W4
006ABA  440308     ADD W8, W8, W6
006ABC  208C05     MOV #0x8C0, W5
006ABE  430285     ADD W6, W5, W5
006AC0  780A84     MOV W4, [W5]
96:                
97:                	for(i=0; i<11; i++)
006ACA  EB4200     CLR.B W4
006ACC  784F04     MOV.B W4, [W14]
006ACE  37000C     BRA 0x6AE8
006AE6  E84F1E     INC.B [W14], [W14]
006AE8  78421E     MOV.B [W14], W4
006AEA  524FEA     SUB.B W4, #0xA, [W15]
006AEC  34FFF1     BRA LE, 0x6AD0
98:                		Kt_T_Piccolo[i] = LoadInt(Kt_T_Piccolo_0_Hi+(2*i));
006AD0  FB041E     SE [W14], W8
006AD2  FB021E     SE [W14], W4
006AD4  420204     ADD W4, W4, W4
006AD6  B00694     ADD #0x69, W4
006AD8  780004     MOV W4, W0
006ADA  07FF5E     RCALL LoadInt
006ADC  780200     MOV W0, W4
006ADE  440308     ADD W8, W8, W6
006AE0  208D85     MOV #0x8D8, W5
006AE2  430285     ADD W6, W5, W5
006AE4  780A84     MOV W4, [W5]
99:                	for(i=0; i<11; i++)
006AEE  EB4200     CLR.B W4
006AF0  784F04     MOV.B W4, [W14]
006AF2  37000C     BRA 0x6B0C
006B0A  E84F1E     INC.B [W14], [W14]
006B0C  78421E     MOV.B [W14], W4
006B0E  524FEA     SUB.B W4, #0xA, [W15]
006B10  34FFF1     BRA LE, 0x6AF4
100:               		Kt_T_Grande[i] = LoadInt(Kt_T_Grande_0_Hi+(2*i));
006AF4  FB041E     SE [W14], W8
006AF6  FB021E     SE [W14], W4
006AF8  420204     ADD W4, W4, W4
006AFA  B007F4     ADD #0x7F, W4
006AFC  780004     MOV W4, W0
006AFE  07FF4C     RCALL LoadInt
006B00  780200     MOV W0, W4
006B02  440308     ADD W8, W8, W6
006B04  208EE5     MOV #0x8EE, W5
006B06  430285     ADD W6, W5, W5
006B08  780A84     MOV W4, [W5]
101:               	for(i=0; i<11; i++)
006B12  EB4200     CLR.B W4
006B14  784F04     MOV.B W4, [W14]
006B16  37000C     BRA 0x6B30
006B2E  E84F1E     INC.B [W14], [W14]
006B30  78421E     MOV.B [W14], W4
006B32  524FEA     SUB.B W4, #0xA, [W15]
006B34  34FFF1     BRA LE, 0x6B18
102:               		Kt_T_Out[i] = LoadInt(Kt_T_Out_0_Hi+(2*i));
006B18  FB041E     SE [W14], W8
006B1A  FB021E     SE [W14], W4
006B1C  420204     ADD W4, W4, W4
006B1E  B00954     ADD #0x95, W4
006B20  780004     MOV W4, W0
006B22  07FF3A     RCALL LoadInt
006B24  780200     MOV W0, W4
006B26  440308     ADD W8, W8, W6
006B28  209045     MOV #0x904, W5
006B2A  430285     ADD W6, W5, W5
006B2C  780A84     MOV W4, [W5]
103:               	for(i=0; i<11; i++)
006B36  EB4200     CLR.B W4
006B38  784F04     MOV.B W4, [W14]
006B3A  37000C     BRA 0x6B54
006B52  E84F1E     INC.B [W14], [W14]
006B54  78421E     MOV.B [W14], W4
006B56  524FEA     SUB.B W4, #0xA, [W15]
006B58  34FFF1     BRA LE, 0x6B3C
104:               		Kt_T_Amb[i] = LoadInt(Kt_T_Amb_0_Hi+(2*i));
006B3C  FB041E     SE [W14], W8
006B3E  FB021E     SE [W14], W4
006B40  420204     ADD W4, W4, W4
006B42  B00AB4     ADD #0xAB, W4
006B44  780004     MOV W4, W0
006B46  07FF28     RCALL LoadInt
006B48  780200     MOV W0, W4
006B4A  440308     ADD W8, W8, W6
006B4C  2091A5     MOV #0x91A, W5
006B4E  430285     ADD W6, W5, W5
006B50  780A84     MOV W4, [W5]
105:               
106:               	// Ora inizializzato da funzione "Init_PWM_Value()" in PWM.c
107:               	//for(i=0; i<9; i++)
108:               	//	PWMValue[i] = LoadInt(PWM_Value_Off_Hi+(2*i));
109:               
110:               	// Non più utilizzati: ora si usa routine "DeltaTempReqOut()" e "DeltaTempInOut()" in PWM.c
111:               	//for(i=0; i<8; i++)
112:               	//	TempLimitSpeed[i] = LoadInt(TempLimitSpeed_Night_Hi+(2*i));
113:               
114:               	oErrLed=1;
006B5A  A822F4     BSET LATG, #1
115:               }
006B5C  78044F     MOV [--W15], W8
006B5E  FA8000     ULNK
006B60  060000     RETURN
116:               
117:               void RefreshE2_Data(void)
118:               {
006B62  FA0004     LNK #0x4
119:               	if(WriteE2Status != 0)
006B64  805534     MOV WriteE2Status, W4
006B66  520FE0     SUB W4, #0x0, [W15]
006B68  320117     BRA Z, 0x6D98
120:               	{
121:               		char i = 0;
006B6A  EB4200     CLR.B W4
006B6C  784F04     MOV.B W4, [W14]
122:               		int E2Data = 0;
006B6E  EB0200     CLR W4
006B70  980714     MOV W4, [W14+2]
123:               
124:               		oErrLed=0;
006B72  A922F4     BCLR LATG, #1
125:               
126:               /*
127:               		if(CRC_Flash != (LoadInt(CRC_Hi_Flash)))
128:               			{StoreInt(CRC_Flash, CRC_Hi_Flash);}
129:               
130:               		if(SN1 != (ReadRegI2C(EEPROM_Add, System_SN_1)))
131:               			{SetRegI2C(EEPROM_Add, System_SN_1, SN1);}
132:               
133:               		if(SN2 != (ReadRegI2C(EEPROM_Add, System_SN_2)))
134:               			{SetRegI2C(EEPROM_Add, System_SN_2, SN2);}
135:               
136:               		if(SN3 != (ReadRegI2C(EEPROM_Add, System_SN_3)))
137:               			{SetRegI2C(EEPROM_Add, System_SN_3, SN3);}
138:               
139:               		if(SN4 != (ReadRegI2C(EEPROM_Add, System_SN_4)))
140:               			{SetRegI2C(EEPROM_Add, System_SN_4, SN4);}
141:               
142:               		if(GiornoFabbricazione != (ReadRegI2C(EEPROM_Add, Fab_Day)))
143:               			{SetRegI2C(EEPROM_Add, Fab_Day, GiornoFabbricazione);}
144:               
145:               		if(MeseFabbricazione != (ReadRegI2C(EEPROM_Add, Fab_Month)))
146:               			{SetRegI2C(EEPROM_Add, Fab_Month, MeseFabbricazione);}
147:               
148:               		if(AnnoFabbricazione != (ReadRegI2C(EEPROM_Add, Fab_Year)))
149:               			{SetRegI2C(EEPROM_Add, Fab_Year, AnnoFabbricazione);}
150:               */
151:               
152:               /*
153:               		if(StepRefreshTime != (ReadRegI2C(EEPROM_Add, ValvoleStepRefreshTime)))
154:               			{SetRegI2C(EEPROM_Add, ValvoleStepRefreshTime, StepRefreshTime);}
155:               
156:               		if(ValvolaMaxStepNum != (LoadInt(ValvolaMaxStepNum_Hi)))
157:               			{StoreInt(ValvolaMaxStepNum, ValvolaMaxStepNum_Hi);}
158:               
159:               		if(SogliaCorrenteVentil != (LoadInt(VentilMinCorrente_Hi)))
160:               			{StoreInt(SogliaCorrenteVentil, VentilMinCorrente_Hi);}
161:               */
162:               
163:               		for(i=0; i<12; i++)
006B74  EB4200     CLR.B W4
006B76  784F04     MOV.B W4, [W14]
006B78  37001B     BRA 0x6BB0
006BAE  E84F1E     INC.B [W14], [W14]
006BB0  78421E     MOV.B [W14], W4
006BB2  524FEB     SUB.B W4, #0xB, [W15]
006BB4  34FFE2     BRA LE, 0x6B7A
164:               		{
165:               			E2Data = LoadInt(AD_T_Piccolo_0_Hi+(i*2));
006B7A  FB021E     SE [W14], W4
006B7C  420204     ADD W4, W4, W4
006B7E  420269     ADD W4, #0x9, W4
006B80  780004     MOV W4, W0
006B82  07FF0A     RCALL LoadInt
006B84  780200     MOV W0, W4
006B86  980714     MOV W4, [W14+2]
166:               			if(AD_T_Piccolo[i] != E2Data)
006B88  FB021E     SE [W14], W4
006B8A  420284     ADD W4, W4, W5
006B8C  208784     MOV #0x878, W4
006B8E  428204     ADD W5, W4, W4
006B90  780294     MOV [W4], W5
006B92  90021E     MOV [W14+2], W4
006B94  528F84     SUB W5, W4, [W15]
006B96  32000B     BRA Z, 0x6BAE
167:               				{StoreInt(AD_T_Piccolo[i], AD_T_Piccolo_0_Hi+(i*2));}
006B98  FB021E     SE [W14], W4
006B9A  420204     ADD W4, W4, W4
006B9C  4202E9     ADD W4, #0x9, W5
006B9E  FB021E     SE [W14], W4
006BA0  420304     ADD W4, W4, W6
006BA2  208784     MOV #0x878, W4
006BA4  430204     ADD W6, W4, W4
006BA6  780214     MOV [W4], W4
006BA8  780085     MOV W5, W1
006BAA  780004     MOV W4, W0
006BAC  07FEDB     RCALL StoreInt
168:               		}
169:               		for(i=0; i<12; i++)
006BB6  EB4200     CLR.B W4
006BB8  784F04     MOV.B W4, [W14]
006BBA  37001C     BRA 0x6BF4
006BF2  E84F1E     INC.B [W14], [W14]
006BF4  78421E     MOV.B [W14], W4
006BF6  524FEB     SUB.B W4, #0xB, [W15]
006BF8  34FFE1     BRA LE, 0x6BBC
170:               		{
171:               			E2Data = LoadInt(AD_T_Grande_0_Hi+(i*2));
006BBC  FB021E     SE [W14], W4
006BBE  420204     ADD W4, W4, W4
006BC0  B00214     ADD #0x21, W4
006BC2  780004     MOV W4, W0
006BC4  07FEE9     RCALL LoadInt
006BC6  780200     MOV W0, W4
006BC8  980714     MOV W4, [W14+2]
172:               			if(AD_T_Grande[i] != E2Data)
006BCA  FB021E     SE [W14], W4
006BCC  420284     ADD W4, W4, W5
006BCE  208904     MOV #0x890, W4
006BD0  428204     ADD W5, W4, W4
006BD2  780294     MOV [W4], W5
006BD4  90021E     MOV [W14+2], W4
006BD6  528F84     SUB W5, W4, [W15]
006BD8  32000C     BRA Z, 0x6BF2
173:               				{StoreInt(AD_T_Grande[i], AD_T_Grande_0_Hi+(i*2));}
006BDA  FB021E     SE [W14], W4
006BDC  420204     ADD W4, W4, W4
006BDE  200215     MOV #0x21, W5
006BE0  428284     ADD W5, W4, W5
006BE2  FB021E     SE [W14], W4
006BE4  420304     ADD W4, W4, W6
006BE6  208904     MOV #0x890, W4
006BE8  430204     ADD W6, W4, W4
006BEA  780214     MOV [W4], W4
006BEC  780085     MOV W5, W1
006BEE  780004     MOV W4, W0
006BF0  07FEB9     RCALL StoreInt
174:               		}
175:               		for(i=0; i<12; i++)
006BFA  EB4200     CLR.B W4
006BFC  784F04     MOV.B W4, [W14]
006BFE  37001C     BRA 0x6C38
006C36  E84F1E     INC.B [W14], [W14]
006C38  78421E     MOV.B [W14], W4
006C3A  524FEB     SUB.B W4, #0xB, [W15]
006C3C  34FFE1     BRA LE, 0x6C00
176:               		{
177:               			E2Data = LoadInt(AD_T_Out_0_Hi+(i*2));
006C00  FB021E     SE [W14], W4
006C02  420204     ADD W4, W4, W4
006C04  B00394     ADD #0x39, W4
006C06  780004     MOV W4, W0
006C08  07FEC7     RCALL LoadInt
006C0A  780200     MOV W0, W4
006C0C  980714     MOV W4, [W14+2]
178:               			if(AD_T_Out[i] != E2Data)
006C0E  FB021E     SE [W14], W4
006C10  420284     ADD W4, W4, W5
006C12  208A84     MOV #0x8A8, W4
006C14  428204     ADD W5, W4, W4
006C16  780294     MOV [W4], W5
006C18  90021E     MOV [W14+2], W4
006C1A  528F84     SUB W5, W4, [W15]
006C1C  32000C     BRA Z, 0x6C36
179:               				{StoreInt(AD_T_Out[i], AD_T_Out_0_Hi+(i*2));}
006C1E  FB021E     SE [W14], W4
006C20  420204     ADD W4, W4, W4
006C22  200395     MOV #0x39, W5
006C24  428284     ADD W5, W4, W5
006C26  FB021E     SE [W14], W4
006C28  420304     ADD W4, W4, W6
006C2A  208A84     MOV #0x8A8, W4
006C2C  430204     ADD W6, W4, W4
006C2E  780214     MOV [W4], W4
006C30  780085     MOV W5, W1
006C32  780004     MOV W4, W0
006C34  07FE97     RCALL StoreInt
180:               		}
181:               		for(i=0; i<12; i++)
006C3E  EB4200     CLR.B W4
006C40  784F04     MOV.B W4, [W14]
006C42  37001C     BRA 0x6C7C
006C7A  E84F1E     INC.B [W14], [W14]
006C7C  78421E     MOV.B [W14], W4
006C7E  524FEB     SUB.B W4, #0xB, [W15]
006C80  34FFE1     BRA LE, 0x6C44
182:               		{
183:               			E2Data = LoadInt(AD_T_Amb_0_Hi+(2*i));
006C44  FB021E     SE [W14], W4
006C46  420204     ADD W4, W4, W4
006C48  B00514     ADD #0x51, W4
006C4A  780004     MOV W4, W0
006C4C  07FEA5     RCALL LoadInt
006C4E  780200     MOV W0, W4
006C50  980714     MOV W4, [W14+2]
184:               			if(AD_T_Amb[i] != E2Data)
006C52  FB021E     SE [W14], W4
006C54  420284     ADD W4, W4, W5
006C56  208C04     MOV #0x8C0, W4
006C58  428204     ADD W5, W4, W4
006C5A  780294     MOV [W4], W5
006C5C  90021E     MOV [W14+2], W4
006C5E  528F84     SUB W5, W4, [W15]
006C60  32000C     BRA Z, 0x6C7A
185:               				{StoreInt(AD_T_Amb[i], AD_T_Amb_0_Hi+(i*2));}
006C62  FB021E     SE [W14], W4
006C64  420204     ADD W4, W4, W4
006C66  200515     MOV #0x51, W5
006C68  428284     ADD W5, W4, W5
006C6A  FB021E     SE [W14], W4
006C6C  420304     ADD W4, W4, W6
006C6E  208C04     MOV #0x8C0, W4
006C70  430204     ADD W6, W4, W4
006C72  780214     MOV [W4], W4
006C74  780085     MOV W5, W1
006C76  780004     MOV W4, W0
006C78  07FE75     RCALL StoreInt
186:               		}
187:               	
188:               		for(i=0; i<11; i++)
006C82  EB4200     CLR.B W4
006C84  784F04     MOV.B W4, [W14]
006C86  37001C     BRA 0x6CC0
006CBE  E84F1E     INC.B [W14], [W14]
006CC0  78421E     MOV.B [W14], W4
006CC2  524FEA     SUB.B W4, #0xA, [W15]
006CC4  34FFE1     BRA LE, 0x6C88
189:               		{
190:               			E2Data = LoadInt(Kt_T_Piccolo_0_Hi+(i*2));
006C88  FB021E     SE [W14], W4
006C8A  420204     ADD W4, W4, W4
006C8C  B00694     ADD #0x69, W4
006C8E  780004     MOV W4, W0
006C90  07FE83     RCALL LoadInt
006C92  780200     MOV W0, W4
006C94  980714     MOV W4, [W14+2]
191:               			if(Kt_T_Piccolo[i] != E2Data)
006C96  FB021E     SE [W14], W4
006C98  420284     ADD W4, W4, W5
006C9A  208D84     MOV #0x8D8, W4
006C9C  428204     ADD W5, W4, W4
006C9E  780294     MOV [W4], W5
006CA0  90021E     MOV [W14+2], W4
006CA2  528F84     SUB W5, W4, [W15]
006CA4  32000C     BRA Z, 0x6CBE
192:               				{StoreInt(Kt_T_Piccolo[i], Kt_T_Piccolo_0_Hi+(i*2));}
006CA6  FB021E     SE [W14], W4
006CA8  420204     ADD W4, W4, W4
006CAA  200695     MOV #0x69, W5
006CAC  428284     ADD W5, W4, W5
006CAE  FB021E     SE [W14], W4
006CB0  420304     ADD W4, W4, W6
006CB2  208D84     MOV #0x8D8, W4
006CB4  430204     ADD W6, W4, W4
006CB6  780214     MOV [W4], W4
006CB8  780085     MOV W5, W1
006CBA  780004     MOV W4, W0
006CBC  07FE53     RCALL StoreInt
193:               		}
194:               		for(i=0; i<11; i++)
006CC6  EB4200     CLR.B W4
006CC8  784F04     MOV.B W4, [W14]
006CCA  37001C     BRA 0x6D04
006D02  E84F1E     INC.B [W14], [W14]
006D04  78421E     MOV.B [W14], W4
006D06  524FEA     SUB.B W4, #0xA, [W15]
006D08  34FFE1     BRA LE, 0x6CCC
195:               		{
196:               			E2Data = LoadInt(Kt_T_Grande_0_Hi+(i*2));
006CCC  FB021E     SE [W14], W4
006CCE  420204     ADD W4, W4, W4
006CD0  B007F4     ADD #0x7F, W4
006CD2  780004     MOV W4, W0
006CD4  07FE61     RCALL LoadInt
006CD6  780200     MOV W0, W4
006CD8  980714     MOV W4, [W14+2]
197:               			if(Kt_T_Grande[i] != E2Data)
006CDA  FB021E     SE [W14], W4
006CDC  420284     ADD W4, W4, W5
006CDE  208EE4     MOV #0x8EE, W4
006CE0  428204     ADD W5, W4, W4
006CE2  780294     MOV [W4], W5
006CE4  90021E     MOV [W14+2], W4
006CE6  528F84     SUB W5, W4, [W15]
006CE8  32000C     BRA Z, 0x6D02
198:               				{StoreInt(Kt_T_Grande[i], Kt_T_Grande_0_Hi+(i*2));}
006CEA  FB021E     SE [W14], W4
006CEC  420204     ADD W4, W4, W4
006CEE  2007F5     MOV #0x7F, W5
006CF0  428284     ADD W5, W4, W5
006CF2  FB021E     SE [W14], W4
006CF4  420304     ADD W4, W4, W6
006CF6  208EE4     MOV #0x8EE, W4
006CF8  430204     ADD W6, W4, W4
006CFA  780214     MOV [W4], W4
006CFC  780085     MOV W5, W1
006CFE  780004     MOV W4, W0
006D00  07FE31     RCALL StoreInt
199:               		}
200:               		for(i=0; i<11; i++)
006D0A  EB4200     CLR.B W4
006D0C  784F04     MOV.B W4, [W14]
006D0E  37001C     BRA 0x6D48
006D46  E84F1E     INC.B [W14], [W14]
006D48  78421E     MOV.B [W14], W4
006D4A  524FEA     SUB.B W4, #0xA, [W15]
006D4C  34FFE1     BRA LE, 0x6D10
201:               		{
202:               			E2Data = LoadInt(Kt_T_Out_0_Hi+(i*2));
006D10  FB021E     SE [W14], W4
006D12  420204     ADD W4, W4, W4
006D14  B00954     ADD #0x95, W4
006D16  780004     MOV W4, W0
006D18  07FE3F     RCALL LoadInt
006D1A  780200     MOV W0, W4
006D1C  980714     MOV W4, [W14+2]
203:               			if(Kt_T_Out[i] != E2Data)
006D1E  FB021E     SE [W14], W4
006D20  420284     ADD W4, W4, W5
006D22  209044     MOV #0x904, W4
006D24  428204     ADD W5, W4, W4
006D26  780294     MOV [W4], W5
006D28  90021E     MOV [W14+2], W4
006D2A  528F84     SUB W5, W4, [W15]
006D2C  32000C     BRA Z, 0x6D46
204:               				{StoreInt(Kt_T_Out[i], Kt_T_Out_0_Hi+(i*2));}
006D2E  FB021E     SE [W14], W4
006D30  420204     ADD W4, W4, W4
006D32  200955     MOV #0x95, W5
006D34  428284     ADD W5, W4, W5
006D36  FB021E     SE [W14], W4
006D38  420304     ADD W4, W4, W6
006D3A  209044     MOV #0x904, W4
006D3C  430204     ADD W6, W4, W4
006D3E  780214     MOV [W4], W4
006D40  780085     MOV W5, W1
006D42  780004     MOV W4, W0
006D44  07FE0F     RCALL StoreInt
205:               		}
206:               		for(i=0; i<11; i++)
006D4E  EB4200     CLR.B W4
006D50  784F04     MOV.B W4, [W14]
006D52  37001C     BRA 0x6D8C
006D8A  E84F1E     INC.B [W14], [W14]
006D8C  78421E     MOV.B [W14], W4
006D8E  524FEA     SUB.B W4, #0xA, [W15]
006D90  34FFE1     BRA LE, 0x6D54
207:               		{
208:               			E2Data = LoadInt(Kt_T_Amb_0_Hi+(i*2));
006D54  FB021E     SE [W14], W4
006D56  420204     ADD W4, W4, W4
006D58  B00AB4     ADD #0xAB, W4
006D5A  780004     MOV W4, W0
006D5C  07FE1D     RCALL LoadInt
006D5E  780200     MOV W0, W4
006D60  980714     MOV W4, [W14+2]
209:               			if(Kt_T_Amb[i] != E2Data)
006D62  FB021E     SE [W14], W4
006D64  420284     ADD W4, W4, W5
006D66  2091A4     MOV #0x91A, W4
006D68  428204     ADD W5, W4, W4
006D6A  780294     MOV [W4], W5
006D6C  90021E     MOV [W14+2], W4
006D6E  528F84     SUB W5, W4, [W15]
006D70  32000C     BRA Z, 0x6D8A
210:               				{StoreInt(Kt_T_Amb[i], Kt_T_Amb_0_Hi+(i*2));}
006D72  FB021E     SE [W14], W4
006D74  420204     ADD W4, W4, W4
006D76  200AB5     MOV #0xAB, W5
006D78  428284     ADD W5, W4, W5
006D7A  FB021E     SE [W14], W4
006D7C  420304     ADD W4, W4, W6
006D7E  2091A4     MOV #0x91A, W4
006D80  430204     ADD W6, W4, W4
006D82  780214     MOV [W4], W4
006D84  780085     MOV W5, W1
006D86  780004     MOV W4, W0
006D88  07FDED     RCALL StoreInt
211:               		}
212:               
213:               /*		for(i=0; i<9; i++)
214:               		{
215:               			E2Data = LoadInt(PWM_Value_Off_Hi+(i*2));
216:               			if(PWMValue[i] != E2Data)
217:               				{StoreInt(PWMValue[i], PWM_Value_Off_Hi+(i*2));}
218:               		}
219:               
220:               		for(i=0; i<8; i++)
221:               		{
222:               			E2Data = LoadInt(TempLimitSpeed_Night_Hi+(i*2));
223:               			if(TempLimitSpeed[i] != E2Data)
224:               				{StoreInt(TempLimitSpeed[i], TempLimitSpeed_Night_Hi+(i*2));}
225:               		}
226:               */		
227:               		
228:               		
229:               		WriteE2Status = 0;
006D92  EB0200     CLR W4
006D94  885534     MOV W4, WriteE2Status
230:               		oErrLed=1;
006D96  A822F4     BSET LATG, #1
231:               	}
232:               }
006D98  FA8000     ULNK
006D9A  060000     RETURN
233:               
234:               
235:               void RefreshE2_TouchValue(void)
236:               {
006D9C  FA0004     LNK #0x4
006D9E  781F88     MOV W8, [W15++]
237:               	int flag=0;
006DA0  EB0200     CLR W4
006DA2  780F04     MOV W4, [W14]
238:               	unsigned int CRC_calc;
239:               
240:               	if(Touch[0].FanMode != (LoadInt(E2_SPLIT_FanMode_Hi)))
006DA4  805D98     MOV 0xBB2, W8
006DA6  200F10     MOV #0xF1, W0
006DA8  07FDF7     RCALL LoadInt
006DAA  780200     MOV W0, W4
006DAC  540F84     SUB W8, W4, [W15]
006DAE  320006     BRA Z, 0x6DBC
241:               		{StoreInt(Touch[0].FanMode, E2_SPLIT_FanMode_Hi); flag=1;}
006DB0  805D94     MOV 0xBB2, W4
006DB2  200F11     MOV #0xF1, W1
006DB4  780004     MOV W4, W0
006DB6  07FDD6     RCALL StoreInt
006DB8  200014     MOV #0x1, W4
006DBA  780F04     MOV W4, [W14]
242:               
243:               	if(Touch[0].SetPoint != (LoadInt(E2_SPLIT_SP_Hi)))
006DBC  805D78     MOV Touch, W8
006DBE  200F30     MOV #0xF3, W0
006DC0  07FDEB     RCALL LoadInt
006DC2  780200     MOV W0, W4
006DC4  540F84     SUB W8, W4, [W15]
006DC6  320006     BRA Z, 0x6DD4
244:               		{StoreInt(Touch[0].SetPoint, E2_SPLIT_SP_Hi); flag=1;}
006DC8  805D74     MOV Touch, W4
006DCA  200F31     MOV #0xF3, W1
006DCC  780004     MOV W4, W0
006DCE  07FDCA     RCALL StoreInt
006DD0  200014     MOV #0x1, W4
006DD2  780F04     MOV W4, [W14]
245:               
246:               	if(Touch[0].DefMode != (LoadInt(E2_SPLIT_Mode_Hi)))
006DD4  805DF8     MOV 0xBBE, W8
006DD6  200F50     MOV #0xF5, W0
006DD8  07FDDF     RCALL LoadInt
006DDA  780200     MOV W0, W4
006DDC  540F84     SUB W8, W4, [W15]
006DDE  320006     BRA Z, 0x6DEC
247:               		{StoreInt(Touch[0].DefMode, E2_SPLIT_Mode_Hi); flag=1;}
006DE0  805DF4     MOV 0xBBE, W4
006DE2  200F51     MOV #0xF5, W1
006DE4  780004     MOV W4, W0
006DE6  07FDBE     RCALL StoreInt
006DE8  200014     MOV #0x1, W4
006DEA  780F04     MOV W4, [W14]
248:               
249:               	if(Touch[0].Script_Split_Pwr != (LoadInt(E2_SPLIT_Pwr_Hi)))
006DEC  805E08     MOV 0xBC0, W8
006DEE  200F70     MOV #0xF7, W0
006DF0  07FDD3     RCALL LoadInt
006DF2  780200     MOV W0, W4
006DF4  540F84     SUB W8, W4, [W15]
006DF6  320006     BRA Z, 0x6E04
250:               		{StoreInt(Touch[0].Script_Split_Pwr, E2_SPLIT_Pwr_Hi); flag=1;}
006DF8  805E04     MOV 0xBC0, W4
006DFA  200F71     MOV #0xF7, W1
006DFC  780004     MOV W4, W0
006DFE  07FDB2     RCALL StoreInt
006E00  200014     MOV #0x1, W4
006E02  780F04     MOV W4, [W14]
251:               
252:               	if(Touch[0].PowerLimit != (LoadInt(E2_PWR_Limit_Hi)))
006E04  805DA8     MOV 0xBB4, W8
006E06  200F90     MOV #0xF9, W0
006E08  07FDC7     RCALL LoadInt
006E0A  780200     MOV W0, W4
006E0C  540F84     SUB W8, W4, [W15]
006E0E  320006     BRA Z, 0x6E1C
253:               		{StoreInt(Touch[0].PowerLimit, E2_PWR_Limit_Hi); flag=1;}
006E10  805DA4     MOV 0xBB4, W4
006E12  200F91     MOV #0xF9, W1
006E14  780004     MOV W4, W0
006E16  07FDA6     RCALL StoreInt
006E18  200014     MOV #0x1, W4
006E1A  780F04     MOV W4, [W14]
254:               
255:               	if(Touch[0].Script_SetPoint_F != (LoadInt(E2_SPLIT_SP_F_Hi)))
006E1C  805E18     MOV 0xBC2, W8
006E1E  200FB0     MOV #0xFB, W0
006E20  07FDBB     RCALL LoadInt
006E22  780200     MOV W0, W4
006E24  540F84     SUB W8, W4, [W15]
006E26  320006     BRA Z, 0x6E34
256:               		{StoreInt(Touch[0].Script_SetPoint_F, E2_SPLIT_SP_F_Hi); flag=1;}
006E28  805E14     MOV 0xBC2, W4
006E2A  200FB1     MOV #0xFB, W1
006E2C  780004     MOV W4, W0
006E2E  07FD9A     RCALL StoreInt
006E30  200014     MOV #0x1, W4
006E32  780F04     MOV W4, [W14]
257:               
258:               	if(flag==1)
006E34  78021E     MOV [W14], W4
006E36  520FE1     SUB W4, #0x1, [W15]
006E38  3A0009     BRA NZ, 0x6E4C
259:               	{
260:               		CRC_calc = Generate_CRC_E2(E2_SPLIT_FanMode_Hi, E2_SPLIT_SP_F_Lo);
006E3A  200FC1     MOV #0xFC, W1
006E3C  200F10     MOV #0xF1, W0
006E3E  07003C     RCALL Generate_CRC_E2
006E40  780200     MOV W0, W4
006E42  980714     MOV W4, [W14+2]
261:               		StoreInt(CRC_calc, E2_CRC_TouchVal_Hi);
006E44  90021E     MOV [W14+2], W4
006E46  200FD1     MOV #0xFD, W1
006E48  780004     MOV W4, W0
006E4A  07FD8C     RCALL StoreInt
262:               	}
263:               
264:               }
006E4C  78044F     MOV [--W15], W8
006E4E  FA8000     ULNK
006E50  060000     RETURN
265:               
266:               void LoadE2_TouchValue(void)
267:               {
006E52  FA0004     LNK #0x4
268:               	unsigned int CRC_Eeprom;
269:               	unsigned int CRC_calc;
270:               
271:               	CRC_Eeprom = LoadInt(E2_CRC_TouchVal_Hi);
006E54  200FD0     MOV #0xFD, W0
006E56  07FDA0     RCALL LoadInt
006E58  780200     MOV W0, W4
006E5A  780F04     MOV W4, [W14]
272:               
273:               	Touch[0].FanMode = LoadInt(E2_SPLIT_FanMode_Hi);
006E5C  200F10     MOV #0xF1, W0
006E5E  07FD9C     RCALL LoadInt
006E60  780200     MOV W0, W4
006E62  885D94     MOV W4, 0xBB2
274:               	Touch[0].SetPoint = LoadInt(E2_SPLIT_SP_Hi);
006E64  200F30     MOV #0xF3, W0
006E66  07FD98     RCALL LoadInt
006E68  780200     MOV W0, W4
006E6A  885D74     MOV W4, Touch
275:               	Touch[0].DefMode = LoadInt(E2_SPLIT_Mode_Hi);
006E6C  200F50     MOV #0xF5, W0
006E6E  07FD94     RCALL LoadInt
006E70  780200     MOV W0, W4
006E72  885DF4     MOV W4, 0xBBE
276:               	Touch[0].Script_Split_Pwr = LoadInt(E2_SPLIT_Pwr_Hi);
006E74  200F70     MOV #0xF7, W0
006E76  07FD90     RCALL LoadInt
006E78  780200     MOV W0, W4
006E7A  885E04     MOV W4, 0xBC0
277:               	Touch[0].PowerLimit = LoadInt(E2_PWR_Limit_Hi);
006E7C  200F90     MOV #0xF9, W0
006E7E  07FD8C     RCALL LoadInt
006E80  780200     MOV W0, W4
006E82  885DA4     MOV W4, 0xBB4
278:               	Touch[0].Script_SetPoint_F = LoadInt(E2_SPLIT_SP_F_Hi);
006E84  200FB0     MOV #0xFB, W0
006E86  07FD88     RCALL LoadInt
006E88  780200     MOV W0, W4
006E8A  885E14     MOV W4, 0xBC2
279:               
280:               	CRC_calc = Generate_CRC_E2(E2_SPLIT_FanMode_Hi, E2_SPLIT_SP_F_Lo);
006E8C  200FC1     MOV #0xFC, W1
006E8E  200F10     MOV #0xF1, W0
006E90  070013     RCALL Generate_CRC_E2
006E92  780200     MOV W0, W4
006E94  980714     MOV W4, [W14+2]
281:               	
282:               	if(CRC_calc != CRC_Eeprom)
006E96  90021E     MOV [W14+2], W4
006E98  520F9E     SUB W4, [W14], [W15]
006E9A  32000C     BRA Z, 0x6EB4
283:               	{
284:               		Touch[0].FanMode = K_Def_SPLIT_FanMode;
006E9C  200094     MOV #0x9, W4
006E9E  885D94     MOV W4, 0xBB2
285:               		Touch[0].SetPoint = K_Def_SPLIT_SP;
006EA0  207D04     MOV #0x7D0, W4
006EA2  885D74     MOV W4, Touch
286:               		Touch[0].DefMode = K_Def_SPLIT_Mode;
006EA4  200104     MOV #0x10, W4
006EA6  885DF4     MOV W4, 0xBBE
287:               		Touch[0].Script_Split_Pwr = K_Def_SPLIT_Pwr;
006EA8  EB0200     CLR W4
006EAA  885E04     MOV W4, 0xBC0
288:               		Touch[0].PowerLimit = K_Def_PWR_Limit;
006EAC  200FF4     MOV #0xFF, W4
006EAE  885DA4     MOV W4, 0xBB4
289:               		Touch[0].Script_SetPoint_F = K_Def_SPLIT_SP_F;
006EB0  219004     MOV #0x1900, W4
006EB2  885E14     MOV W4, 0xBC2
290:               	}
291:               }
006EB4  FA8000     ULNK
006EB6  060000     RETURN
292:               
293:               
294:               unsigned int Generate_CRC_E2(int StartE2Data, int EndE2Data)
295:               {
006EB8  FA000A     LNK #0xA
006EBA  980730     MOV W0, [W14+6]
006EBC  980741     MOV W1, [W14+8]
296:               	unsigned int CRC_16=0xFFFF;
006EBE  EB8200     SETM W4
006EC0  780F04     MOV W4, [W14]
297:               	unsigned int i = 0;
006EC2  EB0200     CLR W4
006EC4  980714     MOV W4, [W14+2]
298:               	unsigned char e2val;
299:               	
300:               	
301:               	for(i=StartE2Data; i <= EndE2Data; i++)
006EC6  90023E     MOV [W14+6], W4
006EC8  980714     MOV W4, [W14+2]
006ECA  370011     BRA 0x6EEE
006EE8  90021E     MOV [W14+2], W4
006EEA  E80204     INC W4, W4
006EEC  980714     MOV W4, [W14+2]
006EEE  9002CE     MOV [W14+8], W5
006EF0  90021E     MOV [W14+2], W4
006EF2  528F84     SUB W5, W4, [W15]
006EF4  31FFEB     BRA C, 0x6ECC
302:               	{
303:               		e2val = ReadRegI2C(EEPROM_Add, i);
006ECC  90021E     MOV [W14+2], W4
006ECE  784204     MOV.B W4, W4
006ED0  784084     MOV.B W4, W1
006ED2  B3CA00     MOV.B #0xA0, W0
006ED4  070D0F     RCALL ReadRegI2C
006ED6  784200     MOV.B W0, W4
006ED8  984744     MOV.B W4, [W14+4]
304:               		CRC_16 = Mod_BaseCRC16(CRC_16, e2val);
006EDA  90424E     MOV.B [W14+4], W4
006EDC  FB8204     ZE W4, W4
006EDE  780084     MOV W4, W1
006EE0  78001E     MOV [W14], W0
006EE2  07000D     RCALL Mod_BaseCRC16
006EE4  780200     MOV W0, W4
006EE6  780F04     MOV W4, [W14]
305:               	}
306:               	return CRC_16;
006EF6  78021E     MOV [W14], W4
307:               }
006EF8  780004     MOV W4, W0
006EFA  FA8000     ULNK
006EFC  060000     RETURN
---  D:/WORK3/Lavori/TERMODINAMICA/Work/FW/1 - Generico/Split/Split v.8.4.22 - Working/Driver_ModBus.c  -
1:                 //----------------------------------------------------------------------------------
2:                 //	Progect name:	Driver_ModBus.c
3:                 //	Device:			PIC18F4550 @ 20Mhz (PLL 96 Mhz)
4:                 //	Autor:			Emanuele
5:                 //	Date:			18/06/2011
6:                 //	Description:	Corpo delle funzioni pilota della comunicazione ModBus
7:                 //----------------------------------------------------------------------------------
8:                 
9:                 //----------------------------------------------------------------------------------
10:                //	Include
11:                //----------------------------------------------------------------------------------
12:                #include "MicroModelSelection.h"
13:                #ifdef GB210
14:                	#include <p24FJ256GB210.h>
15:                #else
16:                	#include <p24FJ256GB110.h>
17:                #endif
18:                #include <stdio.h>
19:                #include "DefinePeriferiche.h"
20:                #include "Timer.h"
21:                #include "usart.h"
22:                #include "Driver_ModBus.h"
23:                #include "ProtocolloModBus.h"
24:                
25:                //----------------------------------------------------------------------------------
26:                //	Funzioni
27:                //----------------------------------------------------------------------------------
28:                unsigned int Mod_BaseCRC16(unsigned int Old_CRC, unsigned char NewChr)
29:                {
006EFE  FA0008     LNK #0x8
006F00  980720     MOV W0, [W14+4]
006F02  984761     MOV.B W1, [W14+6]
30:                	unsigned int i=0;
006F04  EB0200     CLR W4
006F06  780F04     MOV W4, [W14]
31:                	unsigned char LastBit = 0;
006F08  EB4200     CLR.B W4
006F0A  984724     MOV.B W4, [W14+2]
32:                	Old_CRC ^= NewChr;
006F0C  90426E     MOV.B [W14+6], W4
006F0E  FB8204     ZE W4, W4
006F10  9002AE     MOV [W14+4], W5
006F12  6A8204     XOR W5, W4, W4
006F14  980724     MOV W4, [W14+4]
33:                	for(i=0; i<8; i++)
006F16  EB0200     CLR W4
006F18  780F04     MOV W4, [W14]
006F1A  37000F     BRA 0x6F3A
006F38  E80F1E     INC [W14], [W14]
006F3A  78021E     MOV [W14], W4
006F3C  520FE7     SUB W4, #0x7, [W15]
006F3E  36FFEE     BRA LEU, 0x6F1C
34:                	{
35:                		LastBit = Old_CRC & 0x01;
006F1C  90022E     MOV [W14+4], W4
006F1E  784204     MOV.B W4, W4
006F20  624261     AND.B W4, #0x1, W4
006F22  984724     MOV.B W4, [W14+2]
36:                		Old_CRC = (Old_CRC>>1) & 0x7FFF;
006F24  90022E     MOV [W14+4], W4
006F26  D10204     LSR W4, W4
006F28  980724     MOV W4, [W14+4]
37:                		if(LastBit == 1)
006F2A  90422E     MOV.B [W14+2], W4
006F2C  524FE1     SUB.B W4, #0x1, [W15]
006F2E  3A0004     BRA NZ, 0x6F38
38:                			Old_CRC^=ModPolGenCRC16;
006F30  9002AE     MOV [W14+4], W5
006F32  2A0014     MOV #0xA001, W4
006F34  6A8204     XOR W5, W4, W4
006F36  980724     MOV W4, [W14+4]
39:                	}
40:                	return Old_CRC;
006F40  90022E     MOV [W14+4], W4
41:                }
006F42  780004     MOV W4, W0
006F44  FA8000     ULNK
006F46  060000     RETURN
42:                
43:                unsigned int Mod_Generate_CRC(TypModBuffer RtxBuff)
44:                {
006F48  FA0004     LNK #0x4
45:                	unsigned int CRC_16=0xFFFF;
006F4A  EB8200     SETM W4
006F4C  780F04     MOV W4, [W14]
46:                	unsigned int i = 0;
006F4E  EB0200     CLR W4
006F50  980714     MOV W4, [W14+2]
47:                	
48:                	for(i=0; i < (RtxBuff.nByte-2); i++)
006F52  EB0200     CLR W4
006F54  980714     MOV W4, [W14+2]
006F56  37000D     BRA 0x6F72
006F6C  90021E     MOV [W14+2], W4
006F6E  E80204     INC W4, W4
006F70  980714     MOV W4, [W14+2]
006F72  97F24E     MOV.B [W14-12], W4
006F74  FB0204     SE W4, W4
006F76  E98204     DEC2 W4, W4
006F78  780284     MOV W4, W5
006F7A  90021E     MOV [W14+2], W4
006F7C  528F84     SUB W5, W4, [W15]
006F7E  3EFFEC     BRA GTU, 0x6F58
49:                	{
50:                		CRC_16 = Mod_BaseCRC16(CRC_16, (unsigned char)RtxBuff.Buffer[i]);
006F58  2FFA45     MOV #0xFFA4, W5
006F5A  42828E     ADD W5, W14, W5
006F5C  90021E     MOV [W14+2], W4
006F5E  428204     ADD W5, W4, W4
006F60  784214     MOV.B [W4], W4
006F62  784084     MOV.B W4, W1
006F64  78001E     MOV [W14], W0
006F66  07FFCB     RCALL Mod_BaseCRC16
006F68  780200     MOV W0, W4
006F6A  780F04     MOV W4, [W14]
51:                	}
52:                	return CRC_16;
006F80  78021E     MOV [W14], W4
53:                }
006F82  780004     MOV W4, W0
006F84  FA8000     ULNK
006F86  060000     RETURN
54:                
55:                void Mod_CopyBuffer(TypModBuffer * Destinazione, TypModBuffer * Originale)
56:                {
006F88  FA0006     LNK #0x6
006F8A  980710     MOV W0, [W14+2]
006F8C  980721     MOV W1, [W14+4]
57:                	char i = 0;
006F8E  EB4200     CLR.B W4
006F90  784F04     MOV.B W4, [W14]
58:                	for(i=0; i<=Originale->nByte; i++)
006F92  EB4200     CLR.B W4
006F94  784F04     MOV.B W4, [W14]
006F96  370007     BRA 0x6FA6
006FA4  E84F1E     INC.B [W14], [W14]
006FA6  90022E     MOV [W14+4], W4
006FA8  90D204     MOV.B [W4+80], W4
006FAA  524F9E     SUB.B W4, [W14], [W15]
006FAC  3DFFF5     BRA GE, 0x6F98
59:                	{
60:                		Destinazione->Buffer[i] = Originale->Buffer[i];	// copio ogni attributo della struttura dalla struttura originale a quella di destinazione
006F98  FB021E     SE [W14], W4
006F9A  FB029E     SE [W14], W5
006F9C  90032E     MOV [W14+4], W6
006F9E  7AC366     MOV.B [W6+W5], W6
006FA0  90029E     MOV [W14+2], W5
006FA2  7A7286     MOV.B W6, [W5+W4]
61:                	}
62:                	Destinazione->nByte = Originale->nByte;
006FAE  90022E     MOV [W14+4], W4
006FB0  90D284     MOV.B [W4+80], W5
006FB2  90021E     MOV [W14+2], W4
006FB4  98D205     MOV.B W5, [W4+80]
63:                	Destinazione->Valid_Data = Originale->Valid_Data;
006FB6  90022E     MOV [W14+4], W4
006FB8  90D2C4     MOV.B [W4+84], W5
006FBA  90021E     MOV [W14+2], W4
006FBC  98D245     MOV.B W5, [W4+84]
64:                }
006FBE  FA8000     ULNK
006FC0  060000     RETURN
65:                
66:                char Mod_WriteBus(void)
67:                {
006FC2  FA0002     LNK #0x2
68:                	char i = 0;
006FC4  EB4200     CLR.B W4
006FC6  784F04     MOV.B W4, [W14]
69:                	
70:                	// Modifica del 05/01/2014
71:                	Mod_LastRx.Valid_Data = 0; 								// Azzero flag di RX dato valido!
006FC8  EB4200     CLR.B W4
006FCA  784304     MOV.B W4, W6
006FCC  20A8E5     MOV #0xA8E, W5
006FCE  784A86     MOV.B W6, [W5]
72:                
73:                	if (Mod_BufferTx.Valid_Data == 1)						// se il buffer di trasmissione ha un pacchetto validato
006FD0  20A384     MOV #0xA38, W4
006FD2  784214     MOV.B [W4], W4
006FD4  524FE1     SUB.B W4, #0x1, [W15]
006FD6  3A0014     BRA NZ, 0x7000
74:                	{
75:                		for(i=0; i < Mod_BufferTx.nByte; i++)
006FD8  EB4200     CLR.B W4
006FDA  784F04     MOV.B W4, [W14]
006FDC  370007     BRA 0x6FEC
006FEA  E84F1E     INC.B [W14], [W14]
006FEC  20A344     MOV #0xA34, W4
006FEE  784214     MOV.B [W4], W4
006FF0  524F9E     SUB.B W4, [W14], [W15]
006FF2  3CFFF5     BRA GT, 0x6FDE
76:                		{
77:                			putch2(Mod_BufferTx.Buffer[i]);					// invio sul bus la sequenza di byte
006FDE  FB029E     SE [W14], W5
006FE0  209E44     MOV #0x9E4, W4
006FE2  428204     ADD W5, W4, W4
006FE4  784214     MOV.B [W4], W4
006FE6  784004     MOV.B W4, W0
006FE8  070DFD     RCALL putch2
78:                		}
79:                		Mod_BufferTx.Valid_Data = 0;						// invalido il dato in quanto vecchio
006FF4  EB4200     CLR.B W4
006FF6  784304     MOV.B W4, W6
006FF8  20A385     MOV #0xA38, W5
006FFA  784A86     MOV.B W6, [W5]
80:                		return 0;											// ritorno 0 in quanto l'operazione è andata a boun fine
006FFC  EB4200     CLR.B W4
006FFE  370001     BRA 0x7002
81:                	}
82:                	return 1;												// ritorno 1 perche il pacchetto dati non è valido
007000  B3C014     MOV.B #0x1, W4
83:                }
007002  784004     MOV.B W4, W0
007004  FA8000     ULNK
007006  060000     RETURN
84:                
85:                void Mod_IntReadBus(void)
86:                {
007008  FA0000     LNK #0x0
87:                	while(U2STAbits.URXDA)				// se ho un interrupt di ricezione dalla seriale
00700A  3700E9     BRA 0x71DE
0071DE  801194     MOV U2STA, W4
0071E0  620261     AND W4, #0x1, W4
0071E2  520FE0     SUB W4, #0x0, [W15]
0071E4  3AFF13     BRA NZ, 0x700C
88:                	{
89:                		TimeOutModRx.Value = 0;			// resetto il timer comunque perchè ho appena ricevuto un carattere
00700C  EB0200     CLR W4
00700E  884C44     MOV W4, TimeOutModRx
90:                		TimeOutModRx.Time = 100;		// setto il time out @ 100 ms
007010  200644     MOV #0x64, W4
007012  884C54     MOV W4, 0x98A
91:                		if(TimeOutModRx.Enable == 0)	// verifico se il timer per il time out è già attivo (rx in corso)
007014  804C64     MOV 0x98C, W4
007016  620261     AND W4, #0x1, W4
007018  520FE0     SUB W4, #0x0, [W15]
00701A  3A0001     BRA NZ, 0x701E
92:                			TimeOutModRx.Enable = 1;	// se non lo attivo
00701C  A8098C     BSET 0x98C, #0
93:                
94:                		if(iPckModRx <ByteLenModBuff)
00701E  20A905     MOV #0xA90, W5
007020  784295     MOV.B [W5], W5
007022  B3C4F4     MOV.B #0x4F, W4
007024  52CF84     SUB.B W5, W4, [W15]
007026  3C00D2     BRA GT, 0x71CC
95:                		{
96:                			Mod_BufferRx.Buffer[iPckModRx] = U2RXREG;	// salvo nel buffer i dati in arrivo		
007028  20A904     MOV #0xA90, W4
00702A  784214     MOV.B [W4], W4
00702C  FB0304     SE W4, W6
00702E  8011B4     MOV U2RXREG, W4
007030  784284     MOV.B W4, W5
007032  2098E4     MOV #0x98E, W4
007034  430204     ADD W6, W4, W4
007036  784A05     MOV.B W5, [W4]
97:                			if(((iPckModRx == 0) & (Mod_BufferRx.Buffer[iPckModRx] == Mod_BufferTx.Buffer[0])) | (iPckModRx != 0))
007038  20A904     MOV #0xA90, W4
00703A  784214     MOV.B [W4], W4
00703C  FB8204     ZE W4, W4
00703E  E90204     DEC W4, W4
007040  DE224F     LSR W4, #15, W4
007042  784284     MOV.B W4, W5
007044  20A904     MOV #0xA90, W4
007046  784214     MOV.B [W4], W4
007048  FB0304     SE W4, W6
00704A  2098E4     MOV #0x98E, W4
00704C  430204     ADD W6, W4, W4
00704E  784314     MOV.B [W4], W6
007050  209E44     MOV #0x9E4, W4
007052  784214     MOV.B [W4], W4
007054  6B4204     XOR.B W6, W4, W4
007056  FB8204     ZE W4, W4
007058  E90204     DEC W4, W4
00705A  DE224F     LSR W4, #15, W4
00705C  784204     MOV.B W4, W4
00705E  62C204     AND.B W5, W4, W4
007060  FB8284     ZE W4, W5
007062  20A904     MOV #0xA90, W4
007064  784214     MOV.B [W4], W4
007066  FB8204     ZE W4, W4
007068  EA0204     NEG W4, W4
00706A  DE224F     LSR W4, #15, W4
00706C  720205     IOR W4, W5, W4
00706E  520FE0     SUB W4, #0x0, [W15]
007070  3200B5     BRA Z, 0x71DC
98:                			{
99:                				iPckModRx+=1;							// incremento l'indice
007072  20A904     MOV #0xA90, W4
007074  784214     MOV.B [W4], W4
007076  E84204     INC.B W4, W4
007078  784304     MOV.B W4, W6
00707A  20A905     MOV #0xA90, W5
00707C  784A86     MOV.B W6, [W5]
100:               				if(iPckModRx > 3)						// se ho completato la sequenza
00707E  20A904     MOV #0xA90, W4
007080  784214     MOV.B [W4], W4
007082  524FE3     SUB.B W4, #0x3, [W15]
007084  3400AB     BRA LE, 0x71DC
101:               				{
102:               					if(  ((Mod_BufferRx.Buffer[1] == 1) & (iPckModRx >(4+(Mod_BufferRx.Buffer[2])))) |	// Modifica del 05/01/2014 introdotto READ COIL register
007086  2098F4     MOV #0x98F, W4
007088  784214     MOV.B [W4], W4
00708A  A20404     BTG.B W4, #0
00708C  FB8204     ZE W4, W4
00708E  E90204     DEC W4, W4
007090  DE224F     LSR W4, #15, W4
007092  784204     MOV.B W4, W4
007094  20A905     MOV #0xA90, W5
007096  784295     MOV.B [W5], W5
007098  FB0385     SE W5, W7
00709A  209905     MOV #0x990, W5
00709C  784295     MOV.B [W5], W5
00709E  FB0285     SE W5, W5
0070A0  428364     ADD W5, #0x4, W6
0070A2  B3C015     MOV.B #0x1, W5
0070A4  538F86     SUB W7, W6, [W15]
0070A6  3C0001     BRA GT, 0x70AA
0070A8  EB4280     CLR.B W5
0070AA  624205     AND.B W4, W5, W4
0070AC  FB8304     ZE W4, W6
0070D6  720306     IOR W4, W6, W6
007142  520FE0     SUB W4, #0x0, [W15]
007144  320012     BRA Z, 0x716A
103:               						 ((Mod_BufferRx.Buffer[1] == 3) & (iPckModRx >(4+(Mod_BufferRx.Buffer[2])))) |
0070AE  2098F4     MOV #0x98F, W4
0070B0  784214     MOV.B [W4], W4
0070B2  B2C034     XOR.B #0x3, W4
0070B4  FB8204     ZE W4, W4
0070B6  E90204     DEC W4, W4
0070B8  DE224F     LSR W4, #15, W4
0070BA  784204     MOV.B W4, W4
0070BC  20A905     MOV #0xA90, W5
0070BE  784295     MOV.B [W5], W5
0070C0  FB0005     SE W5, W0
0070C2  209905     MOV #0x990, W5
0070C4  784295     MOV.B [W5], W5
0070C6  FB0285     SE W5, W5
0070C8  4283E4     ADD W5, #0x4, W7
0070CA  B3C015     MOV.B #0x1, W5
0070CC  500F87     SUB W0, W7, [W15]
0070CE  3C0001     BRA GT, 0x70D2
0070D0  EB4280     CLR.B W5
0070D2  624205     AND.B W4, W5, W4
0070D4  FB8204     ZE W4, W4
007100  720306     IOR W4, W6, W6
104:               						 ((Mod_BufferRx.Buffer[1] == 4) & (iPckModRx >(4+(Mod_BufferRx.Buffer[2])))) |
0070D8  2098F4     MOV #0x98F, W4
0070DA  784214     MOV.B [W4], W4
0070DC  A22404     BTG.B W4, #2
0070DE  FB8204     ZE W4, W4
0070E0  E90204     DEC W4, W4
0070E2  DE224F     LSR W4, #15, W4
0070E4  784204     MOV.B W4, W4
0070E6  20A905     MOV #0xA90, W5
0070E8  784295     MOV.B [W5], W5
0070EA  FB0005     SE W5, W0
0070EC  209905     MOV #0x990, W5
0070EE  784295     MOV.B [W5], W5
0070F0  FB0285     SE W5, W5
0070F2  4283E4     ADD W5, #0x4, W7
0070F4  B3C015     MOV.B #0x1, W5
0070F6  500F87     SUB W0, W7, [W15]
0070F8  3C0001     BRA GT, 0x70FC
0070FA  EB4280     CLR.B W5
0070FC  624205     AND.B W4, W5, W4
0070FE  FB8204     ZE W4, W4
007120  720306     IOR W4, W6, W6
105:               						 ((Mod_BufferRx.Buffer[1] == 6) & (iPckModRx >7)) |
007102  2098F4     MOV #0x98F, W4
007104  784214     MOV.B [W4], W4
007106  B2C064     XOR.B #0x6, W4
007108  FB8204     ZE W4, W4
00710A  E90204     DEC W4, W4
00710C  DE224F     LSR W4, #15, W4
00710E  784204     MOV.B W4, W4
007110  20A907     MOV #0xA90, W7
007112  784397     MOV.B [W7], W7
007114  B3C015     MOV.B #0x1, W5
007116  53CFE7     SUB.B W7, #0x7, [W15]
007118  3C0001     BRA GT, 0x711C
00711A  EB4280     CLR.B W5
00711C  624205     AND.B W4, W5, W4
00711E  FB8204     ZE W4, W4
007140  720206     IOR W4, W6, W4
106:               						 ((Mod_BufferRx.Buffer[1] == 16) & (iPckModRx >7)))
007122  2098F4     MOV #0x98F, W4
007124  784214     MOV.B [W4], W4
007126  A24404     BTG.B W4, #4
007128  FB8204     ZE W4, W4
00712A  E90204     DEC W4, W4
00712C  DE224F     LSR W4, #15, W4
00712E  784204     MOV.B W4, W4
007130  20A907     MOV #0xA90, W7
007132  784397     MOV.B [W7], W7
007134  B3C015     MOV.B #0x1, W5
007136  53CFE7     SUB.B W7, #0x7, [W15]
007138  3C0001     BRA GT, 0x713C
00713A  EB4280     CLR.B W5
00713C  624205     AND.B W4, W5, W4
00713E  FB8204     ZE W4, W4
107:               					{
108:               						Mod_BufferRx.nByte = iPckModRx;
007146  20A904     MOV #0xA90, W4
007148  784214     MOV.B [W4], W4
00714A  784304     MOV.B W4, W6
00714C  209DE5     MOV #0x9DE, W5
00714E  784A86     MOV.B W6, [W5]
109:               						iPckModRx = 0;					// azzero l'indice di ricezione in quanto il pacchetto è terminato
007150  EB4200     CLR.B W4
007152  784304     MOV.B W4, W6
007154  20A905     MOV #0xA90, W5
007156  784A86     MOV.B W6, [W5]
110:               						TimeOutModRx.Enable = 0;		// fermo il timer del time out
007158  A9098C     BCLR 0x98C, #0
111:               						TimeOutModRx.Value = 0;			// e ne azzero il conteggio, cosi da essere pronto alla ricezione di un nuovo pacchetto
00715A  EB0200     CLR W4
00715C  884C44     MOV W4, TimeOutModRx
112:               						TimeOutModRx.TimeOut = 0;		// e resetto il flag di time out
00715E  A9298C     BCLR 0x98C, #1
113:               						Mod_BufferRx.Valid_Data = 1;	// dico che ho ricevuto un dato valido
007160  B3C014     MOV.B #0x1, W4
007162  784304     MOV.B W4, W6
007164  209E25     MOV #0x9E2, W5
007166  784A86     MOV.B W6, [W5]
007168  370039     BRA 0x71DC
114:               					}
115:               					else
116:               					{
117:               						if(	(Mod_BufferRx.Buffer[1] != 1) & (Mod_BufferRx.Buffer[1] != 3) & (Mod_BufferRx.Buffer[1] != 4) & 
00716A  2098F4     MOV #0x98F, W4
00716C  784214     MOV.B [W4], W4
00716E  784284     MOV.B W4, W5
007170  A20405     BTG.B W5, #0
007172  FB8205     ZE W5, W4
007174  EA0204     NEG W4, W4
007176  DE224F     LSR W4, #15, W4
007178  784284     MOV.B W4, W5
00717A  2098F4     MOV #0x98F, W4
00717C  784214     MOV.B [W4], W4
00717E  B2C034     XOR.B #0x3, W4
007180  FB8204     ZE W4, W4
007182  EA0204     NEG W4, W4
007184  DE224F     LSR W4, #15, W4
007186  784204     MOV.B W4, W4
007188  62C204     AND.B W5, W4, W4
00718A  FB8284     ZE W4, W5
00718C  2098F4     MOV #0x98F, W4
00718E  784214     MOV.B [W4], W4
007190  A22404     BTG.B W4, #2
007192  FB8204     ZE W4, W4
007194  EA0204     NEG W4, W4
007196  DE224F     LSR W4, #15, W4
007198  628284     AND W5, W4, W5
0071A6  628284     AND W5, W4, W5
0071B6  520FE0     SUB W4, #0x0, [W15]
0071B8  320011     BRA Z, 0x71DC
118:               							(Mod_BufferRx.Buffer[1] != 6) & (Mod_BufferRx.Buffer[1] != 16))
00719A  2098F4     MOV #0x98F, W4
00719C  784214     MOV.B [W4], W4
00719E  B2C064     XOR.B #0x6, W4
0071A0  FB8204     ZE W4, W4
0071A2  EA0204     NEG W4, W4
0071A4  DE224F     LSR W4, #15, W4
0071A8  2098F4     MOV #0x98F, W4
0071AA  784214     MOV.B [W4], W4
0071AC  A24404     BTG.B W4, #4
0071AE  FB8204     ZE W4, W4
0071B0  EA0204     NEG W4, W4
0071B2  DE224F     LSR W4, #15, W4
0071B4  628204     AND W5, W4, W4
119:               						{
120:               							iPckModRx = 0;				// azzero l'indice di ricezione in quanto il pacchetto sfora il buffer di rx
0071BA  EB4200     CLR.B W4
0071BC  784304     MOV.B W4, W6
0071BE  20A905     MOV #0xA90, W5
0071C0  784A86     MOV.B W6, [W5]
121:               							TimeOutModRx.Enable = 0;	// fermo il timer del time out
0071C2  A9098C     BCLR 0x98C, #0
122:               							TimeOutModRx.Value = 0;		// e ne azzero il conteggio, cosi da essere pronto alla ricezione di un nuovo pacchetto
0071C4  EB0200     CLR W4
0071C6  884C44     MOV W4, TimeOutModRx
123:               							TimeOutModRx.TimeOut = 0;	// e resetto il flag di time out
0071C8  A9298C     BCLR 0x98C, #1
0071CA  370008     BRA 0x71DC
124:               						}
125:               					}
126:               				}
127:               			}
128:               		}
129:               		else
130:               		{
131:               			iPckModRx = 0;				// azzero l'indice di ricezione in quanto il pacchetto sfora il buffer di rx
0071CC  EB4200     CLR.B W4
0071CE  784304     MOV.B W4, W6
0071D0  20A905     MOV #0xA90, W5
0071D2  784A86     MOV.B W6, [W5]
132:               			TimeOutModRx.Enable = 0;	// fermo il timer del time out
0071D4  A9098C     BCLR 0x98C, #0
133:               			TimeOutModRx.Value = 0;		// e ne azzero il conteggio, cosi da essere pronto alla ricezione di un nuovo pacchetto
0071D6  EB0200     CLR W4
0071D8  884C44     MOV W4, TimeOutModRx
134:               			TimeOutModRx.TimeOut = 0;	// e resetto il flag di time out
0071DA  A9298C     BCLR 0x98C, #1
135:               		}
136:               	IFS1bits.U2RXIF = 0;
0071DC  A9C087     BCLR 0x87, #6
137:               	}
138:               }
0071E6  FA8000     ULNK
0071E8  060000     RETURN
139:               
140:               void Mod_IntTimeOutRx(void)
141:               {
0071EA  FA0000     LNK #0x0
142:               	if(TimeOutModRx.Enable ==1)				// controllo se il timer è attivo
0071EC  804C64     MOV 0x98C, W4
0071EE  620261     AND W4, #0x1, W4
0071F0  520FE0     SUB W4, #0x0, [W15]
0071F2  320018     BRA Z, 0x7224
143:               	{
144:               		TimeOutModRx.Value +=1;				// gestisco il conteggio del timer
0071F4  804C44     MOV TimeOutModRx, W4
0071F6  E80204     INC W4, W4
0071F8  884C44     MOV W4, TimeOutModRx
145:               		if(TimeOutModRx.Value >= TimeOutModRx.Time)		// gestisco il time out
0071FA  804C45     MOV TimeOutModRx, W5
0071FC  804C54     MOV 0x98A, W4
0071FE  528F84     SUB W5, W4, [W15]
007200  390011     BRA NC, 0x7224
146:               		{
147:               			TimeOutModRx.Enable = 0;		// fermo il timer del time out
007202  A9098C     BCLR 0x98C, #0
148:               			TimeOutModRx.Value = 0;			// e ne azzero il conteggio, cosi da essere pronto alla ricezione di un nuovo pacchetto
007204  EB0200     CLR W4
007206  884C44     MOV W4, TimeOutModRx
149:               			while(U2STAbits.URXDA)			// svuoto il buffer di ricezione
007208  370005     BRA 0x7214
007214  801194     MOV U2STA, W4
007216  620261     AND W4, #0x1, W4
007218  520FE0     SUB W4, #0x0, [W15]
00721A  3AFFF7     BRA NZ, 0x720A
150:               				iPckModRx = U2RXREG;
00720A  8011B4     MOV U2RXREG, W4
00720C  784204     MOV.B W4, W4
00720E  784304     MOV.B W4, W6
007210  20A905     MOV #0xA90, W5
007212  784A86     MOV.B W6, [W5]
151:               			iPckModRx = 0;					// azzero l'indice di ricezione in quanto presumo che si sia inetrrotta la comunicazione
00721C  EB4200     CLR.B W4
00721E  784304     MOV.B W4, W6
007220  20A905     MOV #0xA90, W5
007222  784A86     MOV.B W6, [W5]
152:               		}
153:               	}
154:               }
007224  FA8000     ULNK
007226  060000     RETURN
155:               
156:               void Mod_Recive_Cmd(void)
157:               {
007228  FA0004     LNK #0x4
158:               	unsigned int Temp = 0;								// temporaneo per il calcolo del crc e l'isolamento dei dati dal buffer
00722A  EB0200     CLR W4
00722C  780F04     MOV W4, [W14]
159:               	unsigned int CRC16_calcolato = 0;
00722E  EB0200     CLR W4
007230  980714     MOV W4, [W14+2]
160:               
161:               
162:               	if(Mod_BufferRx.Valid_Data == 1)			// controllo se ho finito di ricevere un pacchetto
007232  209E24     MOV #0x9E2, W4
007234  784214     MOV.B [W4], W4
007236  524FE1     SUB.B W4, #0x1, [W15]
007238  3A0042     BRA NZ, 0x72BE
163:               	{
164:               		Mod_CopyBuffer(&Mod_LastRx, &Mod_BufferRx);	// copio quello che ho ricevuto così da liberare il buffer di ricezione
00723A  2098E1     MOV #0x98E, W1
00723C  20A3A0     MOV #0xA3A, W0
00723E  07FEA4     RCALL Mod_CopyBuffer
165:               		iPckModRx = 0;							// reinizializzo l'indice 
007240  EB4200     CLR.B W4
007242  784304     MOV.B W4, W6
007244  20A905     MOV #0xA90, W5
007246  784A86     MOV.B W6, [W5]
166:               		Mod_BufferRx.Valid_Data = 0;			// resetto la validità del buffer di rx in quanto lo già copiato per analizzarlo
007248  EB4200     CLR.B W4
00724A  784304     MOV.B W4, W6
00724C  209E25     MOV #0x9E2, W5
00724E  784A86     MOV.B W6, [W5]
167:               		Mod_LastRx.Valid_Data = 0;				// resetto la validità del dato, sarà il controllo a giudicarne la validità
007250  EB4200     CLR.B W4
007252  784304     MOV.B W4, W6
007254  20A8E5     MOV #0xA8E, W5
007256  784A86     MOV.B W6, [W5]
168:               
169:               		CRC16_calcolato = Mod_Generate_CRC(Mod_LastRx);				// mi calcolo il CRC del pacchetto
007258  B0056F     ADD #0x56, W15
00725A  2FFAA4     MOV #0xFFAA, W4
00725C  42020F     ADD W4, W15, W4
00725E  20A3A5     MOV #0xA3A, W5
007260  09002A     REPEAT #0x2A
007262  781A35     MOV [W5++], [W4++]
007264  B10564     SUB #0x56, W4
007266  07FE70     RCALL Mod_Generate_CRC
007268  B1056F     SUB #0x56, W15
00726A  780200     MOV W0, W4
00726C  980714     MOV W4, [W14+2]
170:               
171:               		Temp = ((Mod_LastRx.Buffer[(Mod_LastRx.nByte)-1])<<8)&0xFF00; //(*0x100);		// recupero la parte alta del CRC dal bufer dei dati ricevuti  // Modifica 05/01/2015 Aggiunta mascheratura byte shift
00726E  20A8A4     MOV #0xA8A, W4
007270  784214     MOV.B [W4], W4
007272  FB0204     SE W4, W4
007274  E90284     DEC W4, W5
007276  20A3A4     MOV #0xA3A, W4
007278  428204     ADD W5, W4, W4
00727A  784214     MOV.B [W4], W4
00727C  FB0204     SE W4, W4
00727E  DD2248     SL W4, #8, W4
007280  780F04     MOV W4, [W14]
172:               		Temp = Temp | ((Mod_LastRx.Buffer[(Mod_LastRx.nByte)-2])&0x00FF);	// recupero la parte bassa del CRC dal bufer dei dati ricevuti
007282  20A8A4     MOV #0xA8A, W4
007284  784214     MOV.B [W4], W4
007286  FB0204     SE W4, W4
007288  E98284     DEC2 W4, W5
00728A  20A3A4     MOV #0xA3A, W4
00728C  428204     ADD W5, W4, W4
00728E  784214     MOV.B [W4], W4
007290  FB0284     SE W4, W5
007292  200FF4     MOV #0xFF, W4
007294  628204     AND W5, W4, W4
007296  720F1E     IOR W4, [W14], [W14]
173:               
174:               		if(CRC16_calcolato == Temp)									// se è uguale a quello ricevuto il pacchetto è ok
007298  90021E     MOV [W14+2], W4
00729A  520F9E     SUB W4, [W14], [W15]
00729C  3A0010     BRA NZ, 0x72BE
175:               		{
176:               			Mod_LastRx.Data = ((Mod_LastRx.Buffer[3]<<8)&0xFF00) | (Mod_LastRx.Buffer[4]&0x00FF);
00729E  20A3D4     MOV #0xA3D, W4
0072A0  784214     MOV.B [W4], W4
0072A2  FB0204     SE W4, W4
0072A4  DD2248     SL W4, #8, W4
0072A6  780284     MOV W4, W5
0072A8  20A3E4     MOV #0xA3E, W4
0072AA  784214     MOV.B [W4], W4
0072AC  FB0304     SE W4, W6
0072AE  200FF4     MOV #0xFF, W4
0072B0  630204     AND W6, W4, W4
0072B2  720205     IOR W4, W5, W4
0072B4  885464     MOV W4, 0xA8C
177:               			/*
178:               			Data1 = Mod_LastRx.Buffer[3] & 0x00FF; 
179:               			Data2 = (char)Mod_LastRx.Buffer[4] & 0x00FF;
180:               			Data3 = (Data1<<8) | Data2;
181:               			Mod_LastRx.Data = Data3;
182:               			*/
183:               			Mod_LastRx.Valid_Data = 1;								// a questo punto devo analizzare il pacchetto
0072B6  B3C014     MOV.B #0x1, W4
0072B8  784284     MOV.B W4, W5
0072BA  20A8E6     MOV #0xA8E, W6
0072BC  784B05     MOV.B W5, [W6]
184:               		}
185:               	}
186:               }
0072BE  FA8000     ULNK
0072C0  060000     RETURN
187:               
188:               void Mod_Write_Cmd(char Address, char Comando, int Registro, int Data)
189:               /*	Address => Indirizzo del dispositivo a cui è rivolto il comando 
190:               	Comando => codice del comando ModBus
191:               	Registro => Registro di partenza o unico del comando
192:               	Data =>		Func 3/4-> Numero di registri da leggere
193:               				Func 6	-> Valore del registro da settare
194:               				Func 16	-> Numero di registri da scrivere
195:               */
196:               {
0072C2  FA000A     LNK #0xA
0072C4  984740     MOV.B W0, [W14+4]
0072C6  984751     MOV.B W1, [W14+5]
0072C8  980732     MOV W2, [W14+6]
0072CA  980743     MOV W3, [W14+8]
197:               	volatile int CRC = 0;
0072CC  EB0200     CLR W4
0072CE  780F04     MOV W4, [W14]
198:               	volatile char ReturnValue = 0;
0072D0  EB4200     CLR.B W4
0072D2  984724     MOV.B W4, [W14+2]
199:               	//volatile char Indice = 0;
200:               	switch(Comando)
0072D4  90425E     MOV.B [W14+5], W4
0072D6  FB0204     SE W4, W4
0072D8  B92361     MUL.SU W4, #1, W6
0072DA  EB8200     SETM W4
0072DC  EB8280     SETM W5
0072DE  420206     ADD W4, W6, W4
0072E0  4A8287     ADDC W5, W7, W5
0072E2  2000F6     MOV #0xF, W6
0072E4  200007     MOV #0x0, W7
0072E6  520F86     SUB W4, W6, [W15]
0072E8  5A8F87     SUBB W5, W7, [W15]
0072EA  3E00D3     BRA GTU, 0x7492
0072EC  016004     BRA W4
0072EE  37000F     BRA 0x730E
0072F0  3700D0     BRA 0x7492
0072F2  37000D     BRA 0x730E
0072F4  37000C     BRA 0x730E
0072F6  3700CD     BRA 0x7492
0072F8  370045     BRA 0x7384
0072FA  3700CB     BRA 0x7492
0072FC  3700CA     BRA 0x7492
0072FE  3700C9     BRA 0x7492
007300  3700C8     BRA 0x7492
007302  3700C7     BRA 0x7492
007304  3700C6     BRA 0x7492
007306  3700C5     BRA 0x7492
007308  3700C4     BRA 0x7492
00730A  3700C3     BRA 0x7492
00730C  370076     BRA 0x73FA
201:               	{
202:               		case 1:							// Read Coil register
203:               		case 3:							// Read Output register
204:               		case 4:							// Read Input register
205:               			Mod_BufferTx.nByte = 8;									// la richiesta è formata da 8 byte
00730E  B3C084     MOV.B #0x8, W4
007310  784304     MOV.B W4, W6
007312  20A345     MOV #0xA34, W5
007314  784A86     MOV.B W6, [W5]
206:               			Mod_BufferTx.Buffer[0] = Address;						// il primo è l'indirizzo del destinatario
007316  9042CE     MOV.B [W14+4], W5
007318  209E44     MOV #0x9E4, W4
00731A  784A05     MOV.B W5, [W4]
207:               			Mod_BufferTx.Buffer[1] = Comando;						// il comando 
00731C  90425E     MOV.B [W14+5], W4
00731E  209E56     MOV #0x9E5, W6
007320  784B04     MOV.B W4, [W6]
208:               			Mod_BufferTx.Buffer[2] = (char)(((Registro & 0xFF00)>>8)&0x00FF);// il registro di partenza (hi byte)	// Modifica 05/01/2015 Aggiunta mascheratura byte shift
007322  90023E     MOV [W14+6], W4
007324  DE2248     LSR W4, #8, W4
007326  784204     MOV.B W4, W4
007328  784304     MOV.B W4, W6
00732A  209E65     MOV #0x9E6, W5
00732C  784A86     MOV.B W6, [W5]
209:               			Mod_BufferTx.Buffer[3] = (char)(Registro & 0x00FF);		// il registro di partenza (lo byte)
00732E  90023E     MOV [W14+6], W4
007330  784204     MOV.B W4, W4
007332  784304     MOV.B W4, W6
007334  209E75     MOV #0x9E7, W5
007336  784A86     MOV.B W6, [W5]
210:               			Mod_BufferTx.Buffer[4] = (char)(((Data & 0xFF00)>>8)&0x00FF);	// il numero di registri da leggere (hi byte)	// Modifica 05/01/2015 Aggiunta mascheratura byte shift
007338  90024E     MOV [W14+8], W4
00733A  DE2248     LSR W4, #8, W4
00733C  784204     MOV.B W4, W4
00733E  784304     MOV.B W4, W6
007340  209E85     MOV #0x9E8, W5
007342  784A86     MOV.B W6, [W5]
211:               			Mod_BufferTx.Buffer[5] = (char)(Data & 0x00FF);			// il numero di registri da leggere (lo byte)
007344  90024E     MOV [W14+8], W4
007346  784204     MOV.B W4, W4
007348  784304     MOV.B W4, W6
00734A  209E95     MOV #0x9E9, W5
00734C  784A86     MOV.B W6, [W5]
212:               	
213:               			CRC = Mod_Generate_CRC(Mod_BufferTx);					// calcolo il CRC
00734E  B0056F     ADD #0x56, W15
007350  2FFAA4     MOV #0xFFAA, W4
007352  42020F     ADD W4, W15, W4
007354  209E45     MOV #0x9E4, W5
007356  09002A     REPEAT #0x2A
007358  781A35     MOV [W5++], [W4++]
00735A  B10564     SUB #0x56, W4
00735C  07FDF5     RCALL Mod_Generate_CRC
00735E  B1056F     SUB #0x56, W15
007360  780200     MOV W0, W4
007362  780F04     MOV W4, [W14]
214:               			Mod_BufferTx.Buffer[6] = (char)(CRC & 0x00FF);			// CRC (Hi Byte)
007364  78021E     MOV [W14], W4
007366  784204     MOV.B W4, W4
007368  784284     MOV.B W4, W5
00736A  209EA6     MOV #0x9EA, W6
00736C  784B05     MOV.B W5, [W6]
215:               			Mod_BufferTx.Buffer[7] = (char)(((CRC & 0xFF00)>>8)&0x00FF);		// CRC (Lo BHyte)	// Modifica 05/01/2015 Aggiunta mascheratura byte shift
00736E  78021E     MOV [W14], W4
007370  DE2248     LSR W4, #8, W4
007372  784204     MOV.B W4, W4
007374  784284     MOV.B W4, W5
007376  209EB6     MOV #0x9EB, W6
007378  784B05     MOV.B W5, [W6]
216:               
217:               			Mod_BufferTx.Valid_Data = 1;			// setto il flag per la richiesta della trasmissione
00737A  B3C014     MOV.B #0x1, W4
00737C  784284     MOV.B W4, W5
00737E  20A386     MOV #0xA38, W6
007380  784B05     MOV.B W5, [W6]
218:               			break;
007382  370087     BRA 0x7492
219:               
220:               		case 6:							// Prese Single register
221:               			Mod_BufferTx.nByte = 8;									// la richiesta è formata da 8 byte
007384  B3C084     MOV.B #0x8, W4
007386  784284     MOV.B W4, W5
007388  20A346     MOV #0xA34, W6
00738A  784B05     MOV.B W5, [W6]
222:               			Mod_BufferTx.Buffer[0] = Address;						// il primo è l'indirizzo del destinatario
00738C  90424E     MOV.B [W14+4], W4
00738E  209E46     MOV #0x9E4, W6
007390  784B04     MOV.B W4, [W6]
223:               			Mod_BufferTx.Buffer[1] = Comando;						// il comando 
007392  90435E     MOV.B [W14+5], W6
007394  209E55     MOV #0x9E5, W5
007396  784A86     MOV.B W6, [W5]
224:               			Mod_BufferTx.Buffer[2] = (char)(((Registro & 0xFF00)>>8)&0x00FF);// il registro da settare (Hi Byte)	// Modifica 05/01/2015 Aggiunta mascheratura byte shift
007398  90023E     MOV [W14+6], W4
00739A  DE2248     LSR W4, #8, W4
00739C  784204     MOV.B W4, W4
00739E  784304     MOV.B W4, W6
0073A0  209E65     MOV #0x9E6, W5
0073A2  784A86     MOV.B W6, [W5]
225:               			Mod_BufferTx.Buffer[3] = (char)(Registro & 0x00FF);		// il registro da settare (Lo Byte)
0073A4  90023E     MOV [W14+6], W4
0073A6  784204     MOV.B W4, W4
0073A8  784304     MOV.B W4, W6
0073AA  209E75     MOV #0x9E7, W5
0073AC  784A86     MOV.B W6, [W5]
226:               			Mod_BufferTx.Buffer[4] = (char)(((Data & 0xFF00)>>8)&0x00FF);	// valore da settare (Hi Byte)		// Modifica 05/01/2015 Aggiunta mascheratura byte shift
0073AE  90024E     MOV [W14+8], W4
0073B0  DE2248     LSR W4, #8, W4
0073B2  784204     MOV.B W4, W4
0073B4  784304     MOV.B W4, W6
0073B6  209E85     MOV #0x9E8, W5
0073B8  784A86     MOV.B W6, [W5]
227:               			Mod_BufferTx.Buffer[5] = (char)(Data & 0x00FF);			// valore da settare (Lo Byte)
0073BA  90024E     MOV [W14+8], W4
0073BC  784204     MOV.B W4, W4
0073BE  784304     MOV.B W4, W6
0073C0  209E95     MOV #0x9E9, W5
0073C2  784A86     MOV.B W6, [W5]
228:               	
229:               			CRC = Mod_Generate_CRC(Mod_BufferTx);					// calcolo il CRC
0073C4  B0056F     ADD #0x56, W15
0073C6  2FFAA4     MOV #0xFFAA, W4
0073C8  42020F     ADD W4, W15, W4
0073CA  209E45     MOV #0x9E4, W5
0073CC  09002A     REPEAT #0x2A
0073CE  781A35     MOV [W5++], [W4++]
0073D0  B10564     SUB #0x56, W4
0073D2  07FDBA     RCALL Mod_Generate_CRC
0073D4  B1056F     SUB #0x56, W15
0073D6  780200     MOV W0, W4
0073D8  780F04     MOV W4, [W14]
230:               			Mod_BufferTx.Buffer[6] = (char)(CRC & 0x00FF);			// CRC (Hi Byte)
0073DA  78021E     MOV [W14], W4
0073DC  784204     MOV.B W4, W4
0073DE  784284     MOV.B W4, W5
0073E0  209EA6     MOV #0x9EA, W6
0073E2  784B05     MOV.B W5, [W6]
231:               			Mod_BufferTx.Buffer[7] = (char)(((CRC & 0xFF00)>>8)&0x00FF);		// CRC (Lo Byte)					// Modifica 05/01/2015 Aggiunta mascheratura byte shift
0073E4  78021E     MOV [W14], W4
0073E6  DE2248     LSR W4, #8, W4
0073E8  784204     MOV.B W4, W4
0073EA  784284     MOV.B W4, W5
0073EC  209EB6     MOV #0x9EB, W6
0073EE  784B05     MOV.B W5, [W6]
232:               	
233:               			Mod_BufferTx.Valid_Data = 1;			// setto il flag per la richiesta della trasmissione
0073F0  B3C014     MOV.B #0x1, W4
0073F2  784284     MOV.B W4, W5
0073F4  20A386     MOV #0xA38, W6
0073F6  784B05     MOV.B W5, [W6]
234:               			break;
0073F8  37004C     BRA 0x7492
235:               
236:               		case 16:						//Preset multiple register
237:               			Mod_BufferTx.nByte = 9+(2*Data);						// la richiesta è formata da 8 byte
0073FA  90024E     MOV [W14+8], W4
0073FC  784204     MOV.B W4, W4
0073FE  424204     ADD.B W4, W4, W4
007400  424269     ADD.B W4, #0x9, W4
007402  784284     MOV.B W4, W5
007404  20A346     MOV #0xA34, W6
007406  784B05     MOV.B W5, [W6]
238:               			Mod_BufferTx.Buffer[0] = Address;						// il primo è l'indirizzo del destinatario
007408  90424E     MOV.B [W14+4], W4
00740A  209E46     MOV #0x9E4, W6
00740C  784B04     MOV.B W4, [W6]
239:               			Mod_BufferTx.Buffer[1] = Comando;						// il comando 
00740E  90435E     MOV.B [W14+5], W6
007410  209E55     MOV #0x9E5, W5
007412  784A86     MOV.B W6, [W5]
240:               			Mod_BufferTx.Buffer[2] = (char)(((Registro & 0xFF00)>>8)&0x00FF);// il registro da settare (Hi Byte)	// Modifica 05/01/2015 Aggiunta mascheratura byte shift
007414  90023E     MOV [W14+6], W4
007416  DE2248     LSR W4, #8, W4
007418  784204     MOV.B W4, W4
00741A  784304     MOV.B W4, W6
00741C  209E65     MOV #0x9E6, W5
00741E  784A86     MOV.B W6, [W5]
241:               			Mod_BufferTx.Buffer[3] = (char)(Registro & 0x00FF);		// il registro da settare (Lo Byte)
007420  90023E     MOV [W14+6], W4
007422  784204     MOV.B W4, W4
007424  784304     MOV.B W4, W6
007426  209E75     MOV #0x9E7, W5
007428  784A86     MOV.B W6, [W5]
242:               			Mod_BufferTx.Buffer[4] = (char)(((Data & 0xFF00)>>8)&0x00FF);	// Numero di registri da settare (Hi Byte)	// Modifica 05/01/2015 Aggiunta mascheratura byte shift
00742A  90024E     MOV [W14+8], W4
00742C  DE2248     LSR W4, #8, W4
00742E  784204     MOV.B W4, W4
007430  784304     MOV.B W4, W6
007432  209E85     MOV #0x9E8, W5
007434  784A86     MOV.B W6, [W5]
243:               			Mod_BufferTx.Buffer[5] = (char)(Data & 0x00FF);			// Numero di registri da settare (Lo Byte)
007436  90024E     MOV [W14+8], W4
007438  784204     MOV.B W4, W4
00743A  784304     MOV.B W4, W6
00743C  209E95     MOV #0x9E9, W5
00743E  784A86     MOV.B W6, [W5]
244:               			Mod_BufferTx.Buffer[6] = Data*2;						// Numero di byte dati che seguono
007440  90024E     MOV [W14+8], W4
007442  784204     MOV.B W4, W4
007444  424204     ADD.B W4, W4, W4
007446  784304     MOV.B W4, W6
007448  209EA5     MOV #0x9EA, W5
00744A  784A86     MOV.B W6, [W5]
245:               	
246:               			CRC = Mod_Generate_CRC(Mod_BufferTx);					// calcolo il CRC
00744C  B0056F     ADD #0x56, W15
00744E  2FFAA4     MOV #0xFFAA, W4
007450  42020F     ADD W4, W15, W4
007452  209E45     MOV #0x9E4, W5
007454  09002A     REPEAT #0x2A
007456  781A35     MOV [W5++], [W4++]
007458  B10564     SUB #0x56, W4
00745A  07FD76     RCALL Mod_Generate_CRC
00745C  B1056F     SUB #0x56, W15
00745E  780200     MOV W0, W4
007460  780F04     MOV W4, [W14]
247:               			Mod_BufferTx.Buffer[Mod_BufferTx.nByte-2] = (char)(CRC & 0x00FF);		// CRC (Hi Byte)
007462  20A344     MOV #0xA34, W4
007464  784214     MOV.B [W4], W4
007466  FB0204     SE W4, W4
007468  E98304     DEC2 W4, W6
00746A  78021E     MOV [W14], W4
00746C  784284     MOV.B W4, W5
00746E  209E44     MOV #0x9E4, W4
007470  430204     ADD W6, W4, W4
007472  784A05     MOV.B W5, [W4]
248:               			Mod_BufferTx.Buffer[Mod_BufferTx.nByte-1] = (char)(((CRC & 0xFF00)>>8)&0x00FF);	// CRC (Lo Byte)	// Modifica 05/01/2015 Aggiunta mascheratura byte shift
007474  20A344     MOV #0xA34, W4
007476  784214     MOV.B [W4], W4
007478  FB0204     SE W4, W4
00747A  E90304     DEC W4, W6
00747C  78021E     MOV [W14], W4
00747E  DE2248     LSR W4, #8, W4
007480  784284     MOV.B W4, W5
007482  209E44     MOV #0x9E4, W4
007484  430204     ADD W6, W4, W4
007486  784A05     MOV.B W5, [W4]
249:               	
250:               			Mod_BufferTx.Valid_Data = 1;			// setto il flag per la richiesta della trasmissione
007488  B3C014     MOV.B #0x1, W4
00748A  784284     MOV.B W4, W5
00748C  20A386     MOV #0xA38, W6
00748E  784B05     MOV.B W5, [W6]
251:               			break;
007490  000000     NOP
252:               	}
253:               	ReturnValue = Mod_WriteBus();					// trasmetto la richiesta
007492  07FD97     RCALL Mod_WriteBus
007494  784200     MOV.B W0, W4
007496  984724     MOV.B W4, [W14+2]
254:               }
007498  FA8000     ULNK
00749A  060000     RETURN
---  D:/WORK3/Lavori/TERMODINAMICA/Work/FW/1 - Generico/Split/Split v.8.4.22 - Working/Driver_ComunicazioneSec.c
1:                 //----------------------------------------------------------------------------------
2:                 //	Progect name:	Driver_Comunicazione.c
3:                 //	Device:			PIC18F4550 @ 20Mhz (PLL 96 Mhz)
4:                 //	Autor:			Emanuele
5:                 //	Date:			22/05/2011
6:                 //	Description:	Corpo delle funzioni pilota della comunicazione su bus
7:                 //----------------------------------------------------------------------------------
8:                 
9:                 //----------------------------------------------------------------------------------
10:                //	Include
11:                //----------------------------------------------------------------------------------
12:                #include "MicroModelSelection.h"
13:                #ifdef GB210
14:                	#include <p24FJ256GB210.h>
15:                #else
16:                	#include <p24FJ256GB110.h>
17:                #endif
18:                #include <stdio.h>
19:                #include "DefinePeriferiche.h"
20:                #include "Timer.h"
21:                #include "usart.h"
22:                #include "Driver_Comunicazione.h"
23:                #include "Driver_ComunicazioneSec.h"
24:                #include "ProtocolloComunicazione.h"
25:                #include "ProtocolloComunicazioneSec.h"
26:                
27:                //----------------------------------------------------------------------------------
28:                //	Funzioni
29:                //----------------------------------------------------------------------------------
30:                char WriteBusSec(volatile TypBuffer * Tx_Buff)
31:                {
0083B6  FA0002     LNK #0x2
0083B8  780F00     MOV W0, [W14]
32:                	if (Tx_Buff->Valid_Data == 1)							// se il buffer di trasmissione ha un pacchetto validato
0083BA  78021E     MOV [W14], W4
0083BC  904A24     MOV.B [W4+10], W4
0083BE  524FE1     SUB.B W4, #0x1, [W15]
0083C0  3A0036     BRA NZ, 0x842E
33:                	{
34:                		putch2(Tx_Buff->Start_Chr);							// invio sul bus la sequenza di byte
0083C2  78021E     MOV [W14], W4
0083C4  784214     MOV.B [W4], W4
0083C6  784004     MOV.B W4, W0
0083C8  07040D     RCALL putch2
35:                		putch2(Tx_Buff->Dest_Add);
0083CA  78021E     MOV [W14], W4
0083CC  904214     MOV.B [W4+1], W4
0083CE  784004     MOV.B W4, W0
0083D0  070409     RCALL putch2
36:                		putch2(Tx_Buff->Mitt_Add);
0083D2  78021E     MOV [W14], W4
0083D4  904224     MOV.B [W4+2], W4
0083D6  784004     MOV.B W4, W0
0083D8  070405     RCALL putch2
37:                		putch2(Tx_Buff->Comando);
0083DA  78021E     MOV [W14], W4
0083DC  904234     MOV.B [W4+3], W4
0083DE  784004     MOV.B W4, W0
0083E0  070401     RCALL putch2
38:                		putch2((char)(((Tx_Buff->Registro & 0xFF00)>>8))&0x00FF);	// Modifica 05/01/2015 Aggiunta mascheratura byte shift
0083E2  78021E     MOV [W14], W4
0083E4  900224     MOV [W4+4], W4
0083E6  DE2248     LSR W4, #8, W4
0083E8  784204     MOV.B W4, W4
0083EA  784004     MOV.B W4, W0
0083EC  0703FB     RCALL putch2
39:                		putch2((char)(Tx_Buff->Registro & 0x00FF));
0083EE  78021E     MOV [W14], W4
0083F0  900224     MOV [W4+4], W4
0083F2  784204     MOV.B W4, W4
0083F4  784004     MOV.B W4, W0
0083F6  0703F6     RCALL putch2
40:                		putch2((char)(((Tx_Buff->Data & 0xFF00)>>8))&0x00FF);		// Modifica 05/01/2015 Aggiunta mascheratura byte shift
0083F8  78021E     MOV [W14], W4
0083FA  900234     MOV [W4+6], W4
0083FC  DE2248     LSR W4, #8, W4
0083FE  784204     MOV.B W4, W4
008400  784004     MOV.B W4, W0
008402  0703F0     RCALL putch2
41:                		putch2((char)(Tx_Buff->Data & 0x00FF));
008404  78021E     MOV [W14], W4
008406  900234     MOV [W4+6], W4
008408  784204     MOV.B W4, W4
00840A  784004     MOV.B W4, W0
00840C  0703EB     RCALL putch2
42:                		putch2((char)(((Tx_Buff->CRC16 & 0xFF00)>>8))&0x00FF);		// Modifica 05/01/2015 Aggiunta mascheratura byte shift
00840E  78021E     MOV [W14], W4
008410  900244     MOV [W4+8], W4
008412  DE2248     LSR W4, #8, W4
008414  784204     MOV.B W4, W4
008416  784004     MOV.B W4, W0
008418  0703E5     RCALL putch2
43:                		putch2((char)(Tx_Buff->CRC16 & 0x00FF));
00841A  78021E     MOV [W14], W4
00841C  900244     MOV [W4+8], W4
00841E  784204     MOV.B W4, W4
008420  784004     MOV.B W4, W0
008422  0703E0     RCALL putch2
44:                
45:                		Tx_Buff->Valid_Data = 0;							// invalido il dato in quanto vecchio
008424  78021E     MOV [W14], W4
008426  EB4280     CLR.B W5
008428  984A25     MOV.B W5, [W4+10]
46:                		return 0;											// ritorno 0 in quanto l'operazione è andata a boun fine
00842A  EB4200     CLR.B W4
00842C  370001     BRA 0x8430
47:                	}
48:                	return 1;												// ritorno 1 perche il pacchetto dati non è valido
00842E  B3C014     MOV.B #0x1, W4
49:                }
008430  784004     MOV.B W4, W0
008432  FA8000     ULNK
008434  060000     RETURN
50:                
51:                void IntReadBusSec(volatile TypBuffer * Rx_Buff)
52:                {
008436  FA0002     LNK #0x2
008438  780F00     MOV W0, [W14]
53:                	while(U2STAbits.URXDA)
00843A  370076     BRA 0x8528
008528  801194     MOV U2STA, W4
00852A  620261     AND W4, #0x1, W4
00852C  520FE0     SUB W4, #0x0, [W15]
00852E  3AFF86     BRA NZ, 0x843C
54:                	{
55:                		if(((iPckRxSec == 0) && (U2RXREG == StartPack)) || (iPckRxSec != 0))
00843C  209864     MOV #0x986, W4
00843E  784214     MOV.B [W4], W4
008440  524FE0     SUB.B W4, #0x0, [W15]
008442  3A0004     BRA NZ, 0x844C
008444  8011B5     MOV U2RXREG, W5
008446  200554     MOV #0x55, W4
008448  528F84     SUB W5, W4, [W15]
00844A  320004     BRA Z, 0x8454
00844C  209864     MOV #0x986, W4
00844E  784214     MOV.B [W4], W4
008450  524FE0     SUB.B W4, #0x0, [W15]
008452  320069     BRA Z, 0x8526
56:                		{
57:                			if(TimeOutRxSec.Enable == 0)			// verifico se il timer per il time out è già attivo (rx in corso)
008454  804B04     MOV 0x960, W4
008456  620261     AND W4, #0x1, W4
008458  520FE0     SUB W4, #0x0, [W15]
00845A  3A0001     BRA NZ, 0x845E
58:                				TimeOutRxSec.Enable = 1;			// se non lo attivo
00845C  A80960     BSET 0x960, #0
59:                			TimeOutRxSec.Value = 0;					// resetto il timer comunque perchè ho appena ricevuto un carattere
00845E  EB0200     CLR W4
008460  884AE4     MOV W4, TimeOutRxSec
60:                			TimeOutRxSec.Time = 10;					// setto il time out @ 100 ms
008462  2000A4     MOV #0xA, W4
008464  884AF4     MOV W4, 0x95E
61:                	
62:                			switch(iPckRxSec)						// in base all'indice ripongo il carattere ricevuto nella giusta posizione
008466  209864     MOV #0x986, W4
008468  784214     MOV.B [W4], W4
00846A  FB0204     SE W4, W4
00846C  DEA2CF     ASR W4, #15, W5
00846E  200096     MOV #0x9, W6
008470  200007     MOV #0x0, W7
008472  520F86     SUB W4, W6, [W15]
008474  5A8F87     SUBB W5, W7, [W15]
008476  3E0042     BRA GTU, 0x84FC
008478  016004     BRA W4
00847A  370009     BRA 0x848E
00847C  37000C     BRA 0x8496
00847E  370010     BRA 0x84A0
008480  370014     BRA 0x84AA
008482  370018     BRA 0x84B4
008484  37001B     BRA 0x84BC
008486  370022     BRA 0x84CC
008488  370025     BRA 0x84D4
00848A  37002C     BRA 0x84E4
00848C  37002F     BRA 0x84EC
63:                			{
64:                				case 0:
65:                					Rx_Buff->Start_Chr = StartPack; //U2RXREG;
00848E  78021E     MOV [W14], W4
008490  B3C555     MOV.B #0x55, W5
008492  784A05     MOV.B W5, [W4]
66:                					break;
008494  370033     BRA 0x84FC
67:                	
68:                				case 1:
69:                					Rx_Buff->Dest_Add = U2RXREG;
008496  8011B4     MOV U2RXREG, W4
008498  784284     MOV.B W4, W5
00849A  78021E     MOV [W14], W4
00849C  984215     MOV.B W5, [W4+1]
70:                					break;
00849E  37002E     BRA 0x84FC
71:                	
72:                				case 2:
73:                					Rx_Buff->Mitt_Add = U2RXREG;
0084A0  8011B4     MOV U2RXREG, W4
0084A2  784284     MOV.B W4, W5
0084A4  78021E     MOV [W14], W4
0084A6  984225     MOV.B W5, [W4+2]
74:                					break;
0084A8  370029     BRA 0x84FC
75:                	
76:                				case 3:
77:                					Rx_Buff->Comando = U2RXREG;
0084AA  8011B4     MOV U2RXREG, W4
0084AC  784284     MOV.B W4, W5
0084AE  78021E     MOV [W14], W4
0084B0  984235     MOV.B W5, [W4+3]
78:                					break;
0084B2  370024     BRA 0x84FC
79:                	
80:                				case 4:
81:                					Rx_Buff->Registro = (int)U2RXREG;
0084B4  8011B5     MOV U2RXREG, W5
0084B6  78021E     MOV [W14], W4
0084B8  980225     MOV W5, [W4+4]
82:                					break;
0084BA  370020     BRA 0x84FC
83:                	
84:                				case 5:
85:                					Rx_Buff->Registro = (((Rx_Buff->Registro<<8)&0xFF00) | (int)U2RXREG);	// Modifica 05/01/2015 Aggiunta mascheratura byte shift
0084BC  78021E     MOV [W14], W4
0084BE  900224     MOV [W4+4], W4
0084C0  DD22C8     SL W4, #8, W5
0084C2  8011B4     MOV U2RXREG, W4
0084C4  720285     IOR W4, W5, W5
0084C6  78021E     MOV [W14], W4
0084C8  980225     MOV W5, [W4+4]
86:                					break;
0084CA  370018     BRA 0x84FC
87:                	
88:                				case 6:
89:                					Rx_Buff->Data = (int)U2RXREG;
0084CC  8011B5     MOV U2RXREG, W5
0084CE  78021E     MOV [W14], W4
0084D0  980235     MOV W5, [W4+6]
90:                					break;
0084D2  370014     BRA 0x84FC
91:                	
92:                				case 7:
93:                					Rx_Buff->Data = (((Rx_Buff->Data <<8)&0xFF00) | (int)U2RXREG);	// Modifica 05/01/2015 Aggiunta mascheratura byte shift
0084D4  78021E     MOV [W14], W4
0084D6  900234     MOV [W4+6], W4
0084D8  DD22C8     SL W4, #8, W5
0084DA  8011B4     MOV U2RXREG, W4
0084DC  720285     IOR W4, W5, W5
0084DE  78021E     MOV [W14], W4
0084E0  980235     MOV W5, [W4+6]
94:                					break;
0084E2  37000C     BRA 0x84FC
95:                	
96:                				case 8:
97:                					Rx_Buff->CRC16 = (int)U2RXREG;
0084E4  8011B5     MOV U2RXREG, W5
0084E6  78021E     MOV [W14], W4
0084E8  980245     MOV W5, [W4+8]
98:                					break;
0084EA  370008     BRA 0x84FC
99:                	
100:               				case 9:
101:               					Rx_Buff->CRC16 = (((Rx_Buff->CRC16 <<8)&0xFF00) | (int)U2RXREG);	// Modifica 05/01/2015 Aggiunta mascheratura byte shift
0084EC  78021E     MOV [W14], W4
0084EE  900244     MOV [W4+8], W4
0084F0  DD22C8     SL W4, #8, W5
0084F2  8011B4     MOV U2RXREG, W4
0084F4  720285     IOR W4, W5, W5
0084F6  78021E     MOV [W14], W4
0084F8  980245     MOV W5, [W4+8]
102:               					break;
0084FA  000000     NOP
103:               			}
104:               	
105:               			iPckRxSec+=1;					// incremento l'indice
0084FC  209864     MOV #0x986, W4
0084FE  784214     MOV.B [W4], W4
008500  E84204     INC.B W4, W4
008502  784304     MOV.B W4, W6
008504  209865     MOV #0x986, W5
008506  784A86     MOV.B W6, [W5]
106:               			if(iPckRxSec > 9)				// se ho completato la sequenza
008508  209864     MOV #0x986, W4
00850A  784214     MOV.B [W4], W4
00850C  524FE9     SUB.B W4, #0x9, [W15]
00850E  34000B     BRA LE, 0x8526
107:               			{
108:               				iPckRxSec = 0;				// azzero l'indice di ricezione in quanto presumo che si sia inetrrotta la comunicazione
008510  EB4200     CLR.B W4
008512  784304     MOV.B W4, W6
008514  209865     MOV #0x986, W5
008516  784A86     MOV.B W6, [W5]
109:               				TimeOutRxSec.Enable = 0;	// fermo il timer del time out
008518  A90960     BCLR 0x960, #0
110:               				TimeOutRxSec.Value = 0;		// e ne azzero il conteggio, cosi da essere pronto alla ricezione di un nuovo pacchetto
00851A  EB0200     CLR W4
00851C  884AE4     MOV W4, TimeOutRxSec
111:               				TimeOutRxSec.TimeOut = 0;	// e resetto il flag di time out
00851E  A92960     BCLR 0x960, #1
112:               				Rx_Buff->Valid_Data = 1;	// dico che ho ricevuto un dato valido
008520  78021E     MOV [W14], W4
008522  B3C015     MOV.B #0x1, W5
008524  984A25     MOV.B W5, [W4+10]
113:               			}
114:               		}
115:               		IFS1bits.U2RXIF = 0;
008526  A9C087     BCLR 0x87, #6
116:               	}
117:               }
008530  FA8000     ULNK
008532  060000     RETURN
118:               
119:               void IntTimeOutRxSec(void)
120:               {
008534  FA0000     LNK #0x0
121:               	if(TimeOutRxSec.Enable == 1)		// controllo se il timer è attivo
008536  804B04     MOV 0x960, W4
008538  620261     AND W4, #0x1, W4
00853A  520FE0     SUB W4, #0x0, [W15]
00853C  32000E     BRA Z, 0x855A
122:               	{
123:               		TimeOutRxSec.Value += 1;		// gestisco il conteggio del timer
00853E  804AE4     MOV TimeOutRxSec, W4
008540  E80204     INC W4, W4
008542  884AE4     MOV W4, TimeOutRxSec
124:               		if (TimeOutRxSec.Value >= TimeOutRxSec.Time)	// gestisco il time out
008544  804AE5     MOV TimeOutRxSec, W5
008546  804AF4     MOV 0x95E, W4
008548  528F84     SUB W5, W4, [W15]
00854A  390007     BRA NC, 0x855A
125:               		{
126:               			TimeOutRxSec.Enable = 0;	// fermo il timer del time out
00854C  A90960     BCLR 0x960, #0
127:               			TimeOutRxSec.Value = 0;		// e ne azzero il conteggio, cosi da essere pronto alla ricezione di un nuovo pacchetto
00854E  EB0200     CLR W4
008550  884AE4     MOV W4, TimeOutRxSec
128:               			iPckRxSec = 0;				// azzero l'indice di ricezione in quanto presumo che si sia inetrrotta la comunicazione
008552  EB4200     CLR.B W4
008554  784304     MOV.B W4, W6
008556  209865     MOV #0x986, W5
008558  784A86     MOV.B W6, [W5]
129:               		}
130:               	}
131:               }
00855A  FA8000     ULNK
00855C  060000     RETURN
132:               
133:               void Recive_Cmd_Sec(volatile TypBuffer * Rx_Buff, volatile TypBuffer * LastCmd)
134:               {
00855E  FA0006     LNK #0x6
008560  980710     MOV W0, [W14+2]
008562  980721     MOV W1, [W14+4]
135:               	if(Rx_Buff->Valid_Data == 1)		// controllo se ho finito di ricevere un pacchetto
008564  90021E     MOV [W14+2], W4
008566  904A24     MOV.B [W4+10], W4
008568  524FE1     SUB.B W4, #0x1, [W15]
00856A  3A0027     BRA NZ, 0x85BA
136:               	{
137:               		int CRC16_calcolato = 0;
00856C  EB0200     CLR W4
00856E  780F04     MOV W4, [W14]
138:               
139:               		CopyBuffer(LastCmd, Rx_Buff);	// copio quello che ho ricevuto così da liberare il buffer di ricezione
008570  90009E     MOV [W14+2], W1
008572  90002E     MOV [W14+4], W0
008574  07FA39     RCALL CopyBuffer
140:               		iPckRxSec = 0;					// reinizializzo l'indice 
008576  EB4200     CLR.B W4
008578  784304     MOV.B W4, W6
00857A  209865     MOV #0x986, W5
00857C  784A86     MOV.B W6, [W5]
141:               		Rx_Buff->Valid_Data = 0;		// resetto la validità del buffer di rx in quanto lo già copiato per analizzarlo
00857E  90021E     MOV [W14+2], W4
008580  EB4280     CLR.B W5
008582  984A25     MOV.B W5, [W4+10]
142:               		LastCmd->Valid_Data = 0;		// resetto la validità del dato, sarà il controllo a giudicarne la validità
008584  90022E     MOV [W14+4], W4
008586  EB4280     CLR.B W5
008588  984A25     MOV.B W5, [W4+10]
143:               
144:               		CRC16_calcolato = GenerateCRC(*LastCmd);	// mi calcolo il CRC del pacchetto
00858A  9002AE     MOV [W14+4], W5
00858C  780015     MOV [W5], W0
00858E  900095     MOV [W5+2], W1
008590  900125     MOV [W5+4], W2
008592  9001B5     MOV [W5+6], W3
008594  900245     MOV [W5+8], W4
008596  9002D5     MOV [W5+10], W5
008598  07F9E4     RCALL GenerateCRC
00859A  780200     MOV W0, W4
00859C  780F04     MOV W4, [W14]
145:               
146:               		if(CRC16_calcolato == LastCmd->CRC16)		// se è uguale a quello ricevuto il pacchetto è ok
00859E  78029E     MOV [W14], W5
0085A0  90022E     MOV [W14+4], W4
0085A2  900244     MOV [W4+8], W4
0085A4  528F84     SUB W5, W4, [W15]
0085A6  3A0009     BRA NZ, 0x85BA
147:               		{
148:               			if(LastCmd->Dest_Add == My_Address)		// cotrollo se è indirizzato a me
0085A8  90022E     MOV [W14+4], W4
0085AA  904294     MOV.B [W4+1], W5
0085AC  20A914     MOV #0xA91, W4
0085AE  784214     MOV.B [W4], W4
0085B0  52CF84     SUB.B W5, W4, [W15]
0085B2  3A0003     BRA NZ, 0x85BA
149:               			{
150:               				LastCmd->Valid_Data = 1;			// a questo punto devo analizzare il pacchetto
0085B4  90022E     MOV [W14+4], W4
0085B6  B3C015     MOV.B #0x1, W5
0085B8  984A25     MOV.B W5, [W4+10]
151:               			}
152:               		}
153:               	}
154:               }
0085BA  FA8000     ULNK
0085BC  060000     RETURN
155:               
156:               void Write_Cmd_Sec(volatile TypBuffer * Tx_Buff, char Address, char Comando, int Registro, int Data)
157:               {
0085BE  FA000C     LNK #0xC
0085C0  980720     MOV W0, [W14+4]
0085C2  984761     MOV.B W1, [W14+6]
0085C4  984772     MOV.B W2, [W14+7]
0085C6  980743     MOV W3, [W14+8]
0085C8  980754     MOV W4, [W14+10]
158:               	int CRC = 0;
0085CA  EB0200     CLR W4
0085CC  780F04     MOV W4, [W14]
159:               	char ReturnValue = 0;
0085CE  EB4200     CLR.B W4
0085D0  984724     MOV.B W4, [W14+2]
160:               
161:               	Tx_Buff->Start_Chr = StartPack;
0085D2  90022E     MOV [W14+4], W4
0085D4  B3C555     MOV.B #0x55, W5
0085D6  784A05     MOV.B W5, [W4]
162:               	Tx_Buff->Dest_Add = Address;
0085D8  9042EE     MOV.B [W14+6], W5
0085DA  90022E     MOV [W14+4], W4
0085DC  984215     MOV.B W5, [W4+1]
163:               	Tx_Buff->Mitt_Add = My_Address;
0085DE  20A915     MOV #0xA91, W5
0085E0  784295     MOV.B [W5], W5
0085E2  90022E     MOV [W14+4], W4
0085E4  984225     MOV.B W5, [W4+2]
164:               	Tx_Buff->Comando = Comando;
0085E6  9042FE     MOV.B [W14+7], W5
0085E8  90022E     MOV [W14+4], W4
0085EA  984235     MOV.B W5, [W4+3]
165:               	Tx_Buff->Registro = Registro;
0085EC  9002CE     MOV [W14+8], W5
0085EE  90022E     MOV [W14+4], W4
0085F0  980225     MOV W5, [W4+4]
166:               	Tx_Buff->Data = Data;
0085F2  9002DE     MOV [W14+10], W5
0085F4  90022E     MOV [W14+4], W4
0085F6  980235     MOV W5, [W4+6]
167:               	CRC = GenerateCRC(*Tx_Buff);
0085F8  9002AE     MOV [W14+4], W5
0085FA  780015     MOV [W5], W0
0085FC  900095     MOV [W5+2], W1
0085FE  900125     MOV [W5+4], W2
008600  9001B5     MOV [W5+6], W3
008602  900245     MOV [W5+8], W4
008604  9002D5     MOV [W5+10], W5
008606  07F9AD     RCALL GenerateCRC
008608  780200     MOV W0, W4
00860A  780F04     MOV W4, [W14]
168:               	Tx_Buff->CRC16 = CRC;
00860C  78029E     MOV [W14], W5
00860E  90022E     MOV [W14+4], W4
008610  980245     MOV W5, [W4+8]
169:               	Tx_Buff->Valid_Data = 1;
008612  90022E     MOV [W14+4], W4
008614  B3C015     MOV.B #0x1, W5
008616  984A25     MOV.B W5, [W4+10]
170:               
171:               	ReturnValue = WriteBusSec(Tx_Buff);
008618  90002E     MOV [W14+4], W0
00861A  07FECD     RCALL WriteBusSec
00861C  784200     MOV.B W0, W4
00861E  984724     MOV.B W4, [W14+2]
172:               }
008620  FA8000     ULNK
008622  060000     RETURN
173:               
174:               void Write_brc_Cmd_Sec(volatile TypBuffer * Tx_Buff, char Comando, int Registro, int Data)
175:               {
008624  FA000C     LNK #0xC
008626  980720     MOV W0, [W14+4]
008628  984761     MOV.B W1, [W14+6]
00862A  980742     MOV W2, [W14+8]
00862C  980753     MOV W3, [W14+10]
176:               	volatile int CRC = 0;
00862E  EB0200     CLR W4
008630  780F04     MOV W4, [W14]
177:               	volatile char ReturnValue = 0;
008632  EB4200     CLR.B W4
008634  984724     MOV.B W4, [W14+2]
178:               
179:               	Tx_Buff->Start_Chr = StartPack;
008636  90022E     MOV [W14+4], W4
008638  B3C555     MOV.B #0x55, W5
00863A  784A05     MOV.B W5, [W4]
180:               	Tx_Buff->Dest_Add = My_Address;
00863C  20A915     MOV #0xA91, W5
00863E  784295     MOV.B [W5], W5
008640  90022E     MOV [W14+4], W4
008642  984215     MOV.B W5, [W4+1]
181:               	Tx_Buff->Mitt_Add = My_Address;
008644  20A915     MOV #0xA91, W5
008646  784295     MOV.B [W5], W5
008648  90022E     MOV [W14+4], W4
00864A  984225     MOV.B W5, [W4+2]
182:               	Tx_Buff->Comando = Comando;
00864C  9042EE     MOV.B [W14+6], W5
00864E  90022E     MOV [W14+4], W4
008650  984235     MOV.B W5, [W4+3]
183:               	Tx_Buff->Registro = Registro;
008652  9002CE     MOV [W14+8], W5
008654  90022E     MOV [W14+4], W4
008656  980225     MOV W5, [W4+4]
184:               	Tx_Buff->Data = Data;
008658  9002DE     MOV [W14+10], W5
00865A  90022E     MOV [W14+4], W4
00865C  980235     MOV W5, [W4+6]
185:               	CRC = GenerateCRC(*Tx_Buff);
00865E  9002AE     MOV [W14+4], W5
008660  780015     MOV [W5], W0
008662  900095     MOV [W5+2], W1
008664  900125     MOV [W5+4], W2
008666  9001B5     MOV [W5+6], W3
008668  900245     MOV [W5+8], W4
00866A  9002D5     MOV [W5+10], W5
00866C  07F97A     RCALL GenerateCRC
00866E  780200     MOV W0, W4
008670  780F04     MOV W4, [W14]
186:               	Tx_Buff->CRC16 = CRC;
008672  78021E     MOV [W14], W4
008674  780284     MOV W4, W5
008676  90022E     MOV [W14+4], W4
008678  980245     MOV W5, [W4+8]
187:               	Tx_Buff->Valid_Data = 1;
00867A  90022E     MOV [W14+4], W4
00867C  B3C015     MOV.B #0x1, W5
00867E  984A25     MOV.B W5, [W4+10]
188:               
189:               	ReturnValue = WriteBusSec(Tx_Buff);
008680  90002E     MOV [W14+4], W0
008682  07FE99     RCALL WriteBusSec
008684  784200     MOV.B W0, W4
008686  984724     MOV.B W4, [W14+2]
190:               }
008688  FA8000     ULNK
00868A  060000     RETURN
---  D:/WORK3/Lavori/TERMODINAMICA/Work/FW/1 - Generico/Split/Split v.8.4.22 - Working/Driver_Comunicazione.c
1:                 //----------------------------------------------------------------------------------
2:                 //	Progect name:	Driver_Comunicazione.c
3:                 //	Device:			PIC24FJ256GB110 @ 32Mhz (FRCPLL)
4:                 //	Autor:			Emanuele
5:                 //	Date:			04/01/2014
6:                 //	Description:	Corpo delle funzioni pilota della comunicazione su bus
7:                 //----------------------------------------------------------------------------------
8:                 
9:                 //----------------------------------------------------------------------------------
10:                //	Include
11:                //----------------------------------------------------------------------------------
12:                #include "MicroModelSelection.h"
13:                #ifdef GB210
14:                	#include <p24FJ256GB210.h>
15:                #else
16:                	#include <p24FJ256GB110.h>
17:                #endif
18:                #include <stdio.h>
19:                #include "DefinePeriferiche.h"
20:                #include "Timer.h"
21:                #include "usart.h"
22:                #include "Driver_Comunicazione.h"
23:                #include "ProtocolloComunicazione.h"
24:                
25:                
26:                //----------------------------------------------------------------------------------
27:                //	Funzioni
28:                //----------------------------------------------------------------------------------
29:                int BaseCRC16(int Old_CRC, unsigned char NewChr)
30:                {
007916  FA0006     LNK #0x6
007918  980710     MOV W0, [W14+2]
00791A  984741     MOV.B W1, [W14+4]
31:                	int i=0;
00791C  EB0200     CLR W4
00791E  780F04     MOV W4, [W14]
32:                
33:                	for(i=0; i<8; i++)
007920  EB0200     CLR W4
007922  780F04     MOV W4, [W14]
007924  370017     BRA 0x7954
007952  E80F1E     INC [W14], [W14]
007954  78021E     MOV [W14], W4
007956  520FE7     SUB W4, #0x7, [W15]
007958  34FFE6     BRA LE, 0x7926
34:                	{
35:                		Old_CRC = ((Old_CRC <<1)|(NewChr>>7));
007926  90021E     MOV [W14+2], W4
007928  420204     ADD W4, W4, W4
00792A  780284     MOV W4, W5
00792C  90424E     MOV.B [W14+4], W4
00792E  FB8204     ZE W4, W4
007930  DE2247     LSR W4, #7, W4
007932  784204     MOV.B W4, W4
007934  FB8204     ZE W4, W4
007936  720205     IOR W4, W5, W4
007938  980714     MOV W4, [W14+2]
36:                		NewChr = (NewChr<<1);
00793A  90424E     MOV.B [W14+4], W4
00793C  424204     ADD.B W4, W4, W4
00793E  984744     MOV.B W4, [W14+4]
37:                		if((Old_CRC & 0x100) != 0)
007940  90029E     MOV [W14+2], W5
007942  201004     MOV #0x100, W4
007944  628204     AND W5, W4, W4
007946  520FE0     SUB W4, #0x0, [W15]
007948  320004     BRA Z, 0x7952
38:                			Old_CRC^=PolGenCRC16;
00794A  90029E     MOV [W14+2], W5
00794C  201A54     MOV #0x1A5, W4
00794E  6A8204     XOR W5, W4, W4
007950  980714     MOV W4, [W14+2]
39:                	}
40:                	return Old_CRC;
00795A  90021E     MOV [W14+2], W4
41:                }
00795C  780004     MOV W4, W0
00795E  FA8000     ULNK
007960  060000     RETURN
42:                
43:                int GenerateCRC(volatile TypBuffer RtxBuff)
44:                {
007962  FA000E     LNK #0xE
007964  980710     MOV W0, [W14+2]
007966  980721     MOV W1, [W14+4]
007968  980732     MOV W2, [W14+6]
00796A  980743     MOV W3, [W14+8]
00796C  980754     MOV W4, [W14+10]
00796E  980765     MOV W5, [W14+12]
45:                	int CRC_16=0;
007970  EB0200     CLR W4
007972  780F04     MOV W4, [W14]
46:                
47:                	CRC_16 = BaseCRC16(CRC_16, RtxBuff.Start_Chr);
007974  90422E     MOV.B [W14+2], W4
007976  784084     MOV.B W4, W1
007978  78001E     MOV [W14], W0
00797A  07FFCD     RCALL BaseCRC16
00797C  780200     MOV W0, W4
00797E  780F04     MOV W4, [W14]
48:                	CRC_16 = BaseCRC16(CRC_16, RtxBuff.Dest_Add);
007980  90423E     MOV.B [W14+3], W4
007982  784084     MOV.B W4, W1
007984  78001E     MOV [W14], W0
007986  07FFC7     RCALL BaseCRC16
007988  780200     MOV W0, W4
00798A  780F04     MOV W4, [W14]
49:                	CRC_16 = BaseCRC16(CRC_16, RtxBuff.Mitt_Add);
00798C  90424E     MOV.B [W14+4], W4
00798E  784084     MOV.B W4, W1
007990  78001E     MOV [W14], W0
007992  07FFC1     RCALL BaseCRC16
007994  780200     MOV W0, W4
007996  780F04     MOV W4, [W14]
50:                	CRC_16 = BaseCRC16(CRC_16, RtxBuff.Comando);
007998  90425E     MOV.B [W14+5], W4
00799A  784084     MOV.B W4, W1
00799C  78001E     MOV [W14], W0
00799E  07FFBB     RCALL BaseCRC16
0079A0  780200     MOV W0, W4
0079A2  780F04     MOV W4, [W14]
51:                	CRC_16 = BaseCRC16(CRC_16, (char)(RtxBuff.Registro & 0x00FF));
0079A4  90023E     MOV [W14+6], W4
0079A6  784204     MOV.B W4, W4
0079A8  784084     MOV.B W4, W1
0079AA  78001E     MOV [W14], W0
0079AC  07FFB4     RCALL BaseCRC16
0079AE  780200     MOV W0, W4
0079B0  780F04     MOV W4, [W14]
52:                	//CRC_16 = BaseCRC16(CRC_16, (char)((RtxBuff.Registro & 0xFF00)>>8));
53:                	CRC_16 = BaseCRC16(CRC_16, (char)(((RtxBuff.Registro & 0xFF00)>>8))&0x00FF);	// Modifica 25/05/2015 Aggiunta mascheratura byte shift
0079B2  90023E     MOV [W14+6], W4
0079B4  DE2248     LSR W4, #8, W4
0079B6  784204     MOV.B W4, W4
0079B8  784084     MOV.B W4, W1
0079BA  78001E     MOV [W14], W0
0079BC  07FFAC     RCALL BaseCRC16
0079BE  780200     MOV W0, W4
0079C0  780F04     MOV W4, [W14]
54:                	CRC_16 = BaseCRC16(CRC_16, (char)(RtxBuff.Data & 0x00FF));
0079C2  90024E     MOV [W14+8], W4
0079C4  784204     MOV.B W4, W4
0079C6  784084     MOV.B W4, W1
0079C8  78001E     MOV [W14], W0
0079CA  07FFA5     RCALL BaseCRC16
0079CC  780200     MOV W0, W4
0079CE  780F04     MOV W4, [W14]
55:                	//CRC_16 = BaseCRC16(CRC_16, (char)((RtxBuff.Data & 0xFF00)>>8));
56:                	CRC_16 = BaseCRC16(CRC_16, (char)(((RtxBuff.Data & 0xFF00)>>8))&0x00FF);		// Modifica 25/05/2015 Aggiunta mascheratura byte shift
0079D0  90024E     MOV [W14+8], W4
0079D2  DE2248     LSR W4, #8, W4
0079D4  784204     MOV.B W4, W4
0079D6  784084     MOV.B W4, W1
0079D8  78001E     MOV [W14], W0
0079DA  07FF9D     RCALL BaseCRC16
0079DC  780200     MOV W0, W4
0079DE  780F04     MOV W4, [W14]
57:                	return CRC_16;
0079E0  78021E     MOV [W14], W4
58:                }
0079E2  780004     MOV W4, W0
0079E4  FA8000     ULNK
0079E6  060000     RETURN
59:                
60:                void CopyBuffer(volatile TypBuffer * Destinazione, volatile TypBuffer * Originale)
61:                {
0079E8  FA0004     LNK #0x4
0079EA  780F00     MOV W0, [W14]
0079EC  980711     MOV W1, [W14+2]
62:                	Destinazione->Start_Chr = Originale->Start_Chr;			// copio ogni attributo della struttura dalla struttura originale a quella di destinazione
0079EE  90021E     MOV [W14+2], W4
0079F0  784294     MOV.B [W4], W5
0079F2  78021E     MOV [W14], W4
0079F4  784A05     MOV.B W5, [W4]
63:                	Destinazione->Dest_Add = Originale->Dest_Add;
0079F6  90021E     MOV [W14+2], W4
0079F8  904294     MOV.B [W4+1], W5
0079FA  78021E     MOV [W14], W4
0079FC  984215     MOV.B W5, [W4+1]
64:                	Destinazione->Mitt_Add = Originale->Mitt_Add;
0079FE  90021E     MOV [W14+2], W4
007A00  9042A4     MOV.B [W4+2], W5
007A02  78021E     MOV [W14], W4
007A04  984225     MOV.B W5, [W4+2]
65:                	Destinazione->Comando = Originale->Comando;
007A06  90021E     MOV [W14+2], W4
007A08  9042B4     MOV.B [W4+3], W5
007A0A  78021E     MOV [W14], W4
007A0C  984235     MOV.B W5, [W4+3]
66:                	Destinazione->Registro = Originale->Registro;
007A0E  90021E     MOV [W14+2], W4
007A10  9002A4     MOV [W4+4], W5
007A12  78021E     MOV [W14], W4
007A14  980225     MOV W5, [W4+4]
67:                	Destinazione->Data = Originale->Data;
007A16  90021E     MOV [W14+2], W4
007A18  9002B4     MOV [W4+6], W5
007A1A  78021E     MOV [W14], W4
007A1C  980235     MOV W5, [W4+6]
68:                	Destinazione->CRC16 = Originale->CRC16;
007A1E  90021E     MOV [W14+2], W4
007A20  9002C4     MOV [W4+8], W5
007A22  78021E     MOV [W14], W4
007A24  980245     MOV W5, [W4+8]
69:                	Destinazione->Valid_Data = Originale->Valid_Data;	
007A26  90021E     MOV [W14+2], W4
007A28  904AA4     MOV.B [W4+10], W5
007A2A  78021E     MOV [W14], W4
007A2C  984A25     MOV.B W5, [W4+10]
70:                }
007A2E  FA8000     ULNK
007A30  060000     RETURN
71:                
72:                char WriteBus(volatile TypBuffer * Tx_Buff)
73:                {
007A32  FA0002     LNK #0x2
007A34  780F00     MOV W0, [W14]
74:                	if (Tx_Buff->Valid_Data == 1)							// se il buffer di trasmissione ha un pacchetto validato
007A36  78021E     MOV [W14], W4
007A38  904A24     MOV.B [W4+10], W4
007A3A  524FE1     SUB.B W4, #0x1, [W15]
007A3C  3A0038     BRA NZ, 0x7AAE
75:                	{	
76:                		oRTS_Master = 1;			// alzo il pin dell'rts x la 485
007A3E  A8A2EC     BSET LATF, #5
77:                		putch1(Tx_Buff->Start_Chr);							// invio sul bus la sequenza di byte
007A40  78021E     MOV [W14], W4
007A42  784214     MOV.B [W4], W4
007A44  784004     MOV.B W4, W0
007A46  0708A8     RCALL putch1
78:                		putch1(Tx_Buff->Dest_Add);
007A48  78021E     MOV [W14], W4
007A4A  904214     MOV.B [W4+1], W4
007A4C  784004     MOV.B W4, W0
007A4E  0708A4     RCALL putch1
79:                		putch1(Tx_Buff->Mitt_Add);
007A50  78021E     MOV [W14], W4
007A52  904224     MOV.B [W4+2], W4
007A54  784004     MOV.B W4, W0
007A56  0708A0     RCALL putch1
80:                		putch1(Tx_Buff->Comando);
007A58  78021E     MOV [W14], W4
007A5A  904234     MOV.B [W4+3], W4
007A5C  784004     MOV.B W4, W0
007A5E  07089C     RCALL putch1
81:                		//putch1((char)((Tx_Buff->Registro & 0xFF00)>>8));
82:                		putch1((char)(((Tx_Buff->Registro & 0xFF00)>>8))&0x00FF);	// Modifica 25/05/2015 Aggiunta mascheratura byte shift
007A60  78021E     MOV [W14], W4
007A62  900224     MOV [W4+4], W4
007A64  DE2248     LSR W4, #8, W4
007A66  784204     MOV.B W4, W4
007A68  784004     MOV.B W4, W0
007A6A  070896     RCALL putch1
83:                		putch1((char)(Tx_Buff->Registro & 0x00FF));
007A6C  78021E     MOV [W14], W4
007A6E  900224     MOV [W4+4], W4
007A70  784204     MOV.B W4, W4
007A72  784004     MOV.B W4, W0
007A74  070891     RCALL putch1
84:                		//putch1((char)((Tx_Buff->Data & 0xFF00)>>8));
85:                		putch1((char)(((Tx_Buff->Data & 0xFF00)>>8))&0x00FF);		// Modifica 25/05/2015 Aggiunta mascheratura byte shift
007A76  78021E     MOV [W14], W4
007A78  900234     MOV [W4+6], W4
007A7A  DE2248     LSR W4, #8, W4
007A7C  784204     MOV.B W4, W4
007A7E  784004     MOV.B W4, W0
007A80  07088B     RCALL putch1
86:                		putch1((char)(Tx_Buff->Data & 0x00FF));
007A82  78021E     MOV [W14], W4
007A84  900234     MOV [W4+6], W4
007A86  784204     MOV.B W4, W4
007A88  784004     MOV.B W4, W0
007A8A  070886     RCALL putch1
87:                		//putch1((char)((Tx_Buff->CRC16 & 0xFF00)>>8));
88:                		putch1((char)(((Tx_Buff->CRC16 & 0xFF00)>>8))&0x00FF);		// Modifica 25/05/2015 Aggiunta mascheratura byte shift
007A8C  78021E     MOV [W14], W4
007A8E  900244     MOV [W4+8], W4
007A90  DE2248     LSR W4, #8, W4
007A92  784204     MOV.B W4, W4
007A94  784004     MOV.B W4, W0
007A96  070880     RCALL putch1
89:                		putch1((char)(Tx_Buff->CRC16 & 0x00FF));
007A98  78021E     MOV [W14], W4
007A9A  900244     MOV [W4+8], W4
007A9C  784204     MOV.B W4, W4
007A9E  784004     MOV.B W4, W0
007AA0  07087B     RCALL putch1
90:                
91:                		oRTS_Master = 0;			// abbasso il pin dell'rts x la 485
007AA2  A9A2EC     BCLR LATF, #5
92:                
93:                		Tx_Buff->Valid_Data = 0;							// invalido il dato in quanto vecchio
007AA4  78021E     MOV [W14], W4
007AA6  EB4280     CLR.B W5
007AA8  984A25     MOV.B W5, [W4+10]
94:                		return 0;											// ritorno 0 in quanto l'operazione è andata a boun fine
007AAA  EB4200     CLR.B W4
007AAC  370001     BRA 0x7AB0
95:                	}
96:                	return 1;												// ritorno 1 perche il pacchetto dati non è valido
007AAE  B3C014     MOV.B #0x1, W4
97:                }
007AB0  784004     MOV.B W4, W0
007AB2  FA8000     ULNK
007AB4  060000     RETURN
98:                
99:                void IntReadBus(volatile TypBuffer * Rx_Buff)
100:               {
007AB6  FA0004     LNK #0x4
007AB8  980710     MOV W0, [W14+2]
101:               	int RxData = 0;
007ABA  EB0200     CLR W4
007ABC  780F04     MOV W4, [W14]
102:               	while(U1STAbits.URXDA)
007ABE  370087     BRA 0x7BCE
007BCE  801114     MOV U1STA, W4
007BD0  620261     AND W4, #0x1, W4
007BD2  520FE0     SUB W4, #0x0, [W15]
007BD4  3AFF75     BRA NZ, 0x7AC0
103:               	{
104:               		RxData = U1RXREG;
007AC0  801134     MOV U1RXREG, W4
007AC2  780F04     MOV W4, [W14]
105:               		if((((iPckRx == 0) && (RxData == StartPack)) || (iPckRx != 0)) & !oRTS_Master)
007AC4  2095A4     MOV #0x95A, W4
007AC6  784214     MOV.B [W4], W4
007AC8  524FE0     SUB.B W4, #0x0, [W15]
007ACA  3A0004     BRA NZ, 0x7AD4
007ACC  200554     MOV #0x55, W4
007ACE  78029E     MOV [W14], W5
007AD0  528F84     SUB W5, W4, [W15]
007AD2  320004     BRA Z, 0x7ADC
007AD4  2095A4     MOV #0x95A, W4
007AD6  784214     MOV.B [W4], W4
007AD8  524FE0     SUB.B W4, #0x0, [W15]
007ADA  320002     BRA Z, 0x7AE0
007ADC  200014     MOV #0x1, W4
007ADE  370001     BRA 0x7AE2
007AE0  EB0200     CLR W4
007AE2  784284     MOV.B W4, W5
007AE4  801766     MOV LATF, W6
007AE6  200204     MOV #0x20, W4
007AE8  630204     AND W6, W4, W4
007AEA  A7F004     BTSC W4, #15
007AEC  EA0204     NEG W4, W4
007AEE  E90204     DEC W4, W4
007AF0  DE224F     LSR W4, #15, W4
007AF2  784204     MOV.B W4, W4
007AF4  62C204     AND.B W5, W4, W4
007AF6  524FE0     SUB.B W4, #0x0, [W15]
007AF8  32006A     BRA Z, 0x7BCE
106:               		{
107:               			if(TimeOutRx.Enable == 0)				// verifico se il timer per il time out è già attivo (rx in corso)
007AFA  8049A4     MOV 0x934, W4
007AFC  620261     AND W4, #0x1, W4
007AFE  520FE0     SUB W4, #0x0, [W15]
007B00  3A0001     BRA NZ, 0x7B04
108:               				TimeOutRx.Enable = 1;				// se non lo attivo
007B02  A80934     BSET 0x934, #0
109:               			TimeOutRx.Value = 0;					// resetto il timer comunque perchè ho appena ricevuto un carattere
007B04  EB0200     CLR W4
007B06  884984     MOV W4, TimeOutRx
110:               			TimeOutRx.Time = 10;					// setto il time out @ 100 ms
007B08  2000A4     MOV #0xA, W4
007B0A  884994     MOV W4, 0x932
111:               	
112:               			switch(iPckRx)							// in base all'indice ripongo il carattere ricevuto nella giusta posizione
007B0C  2095A4     MOV #0x95A, W4
007B0E  784214     MOV.B [W4], W4
007B10  FB0204     SE W4, W4
007B12  DEA2CF     ASR W4, #15, W5
007B14  200096     MOV #0x9, W6
007B16  200007     MOV #0x0, W7
007B18  520F86     SUB W4, W6, [W15]
007B1A  5A8F87     SUBB W5, W7, [W15]
007B1C  3E0043     BRA GTU, 0x7BA4
007B1E  016004     BRA W4
007B20  370009     BRA 0x7B34
007B22  37000D     BRA 0x7B3E
007B24  370011     BRA 0x7B48
007B26  370015     BRA 0x7B52
007B28  370019     BRA 0x7B5C
007B2A  37001C     BRA 0x7B64
007B2C  370023     BRA 0x7B74
007B2E  370026     BRA 0x7B7C
007B30  37002D     BRA 0x7B8C
007B32  370030     BRA 0x7B94
113:               			{
114:               				case 0:
115:               					Rx_Buff->Start_Chr = RxData;	//StartPack; //U1RXREG;
007B34  78021E     MOV [W14], W4
007B36  784284     MOV.B W4, W5
007B38  90021E     MOV [W14+2], W4
007B3A  784A05     MOV.B W5, [W4]
116:               					break;
007B3C  370033     BRA 0x7BA4
117:               	
118:               				case 1:
119:               					Rx_Buff->Dest_Add = RxData;
007B3E  78021E     MOV [W14], W4
007B40  784284     MOV.B W4, W5
007B42  90021E     MOV [W14+2], W4
007B44  984215     MOV.B W5, [W4+1]
120:               					break;
007B46  37002E     BRA 0x7BA4
121:               	
122:               				case 2:
123:               					Rx_Buff->Mitt_Add = RxData;
007B48  78021E     MOV [W14], W4
007B4A  784284     MOV.B W4, W5
007B4C  90021E     MOV [W14+2], W4
007B4E  984225     MOV.B W5, [W4+2]
124:               					break;
007B50  370029     BRA 0x7BA4
125:               	
126:               				case 3:
127:               					Rx_Buff->Comando = RxData;
007B52  78021E     MOV [W14], W4
007B54  784284     MOV.B W4, W5
007B56  90021E     MOV [W14+2], W4
007B58  984235     MOV.B W5, [W4+3]
128:               					break;
007B5A  370024     BRA 0x7BA4
129:               	
130:               				case 4:
131:               					Rx_Buff->Registro = (int)RxData;
007B5C  78029E     MOV [W14], W5
007B5E  90021E     MOV [W14+2], W4
007B60  980225     MOV W5, [W4+4]
132:               					break;
007B62  370020     BRA 0x7BA4
133:               	
134:               				case 5:
135:               					//Rx_Buff->Registro = ((Rx_Buff->Registro<<8)|(int)RxData);
136:               					Rx_Buff->Registro = (((Rx_Buff->Registro<<8)&0xFF00) | (int)RxData);	// Modifica 25/05/2015 Aggiunta mascheratura byte shift
007B64  90021E     MOV [W14+2], W4
007B66  900224     MOV [W4+4], W4
007B68  DD22C8     SL W4, #8, W5
007B6A  78021E     MOV [W14], W4
007B6C  720285     IOR W4, W5, W5
007B6E  90021E     MOV [W14+2], W4
007B70  980225     MOV W5, [W4+4]
137:               					break;
007B72  370018     BRA 0x7BA4
138:               	
139:               				case 6:
140:               					Rx_Buff->Data = (int)RxData;
007B74  78029E     MOV [W14], W5
007B76  90021E     MOV [W14+2], W4
007B78  980235     MOV W5, [W4+6]
141:               					break;
007B7A  370014     BRA 0x7BA4
142:               	
143:               				case 7:
144:               					//Rx_Buff->Data = ((Rx_Buff->Data <<8)|(int)RxData);
145:               					Rx_Buff->Data = (((Rx_Buff->Data <<8)&0xFF00) | (int)RxData);			// Modifica 25/05/2015 Aggiunta mascheratura byte shift
007B7C  90021E     MOV [W14+2], W4
007B7E  900234     MOV [W4+6], W4
007B80  DD22C8     SL W4, #8, W5
007B82  78021E     MOV [W14], W4
007B84  720285     IOR W4, W5, W5
007B86  90021E     MOV [W14+2], W4
007B88  980235     MOV W5, [W4+6]
146:               					break;
007B8A  37000C     BRA 0x7BA4
147:               	
148:               				case 8:
149:               					Rx_Buff->CRC16 = (int)RxData;
007B8C  78029E     MOV [W14], W5
007B8E  90021E     MOV [W14+2], W4
007B90  980245     MOV W5, [W4+8]
150:               					break;
007B92  370008     BRA 0x7BA4
151:               	
152:               				case 9:
153:               					//Rx_Buff->CRC16 = ((Rx_Buff->CRC16 <<8)|(int)RxData);
154:               					Rx_Buff->CRC16 = (((Rx_Buff->CRC16 <<8)&0xFF00) | (int)RxData);	// Modifica 25/05/2015 Aggiunta mascheratura byte shift
007B94  90021E     MOV [W14+2], W4
007B96  900244     MOV [W4+8], W4
007B98  DD22C8     SL W4, #8, W5
007B9A  78021E     MOV [W14], W4
007B9C  720285     IOR W4, W5, W5
007B9E  90021E     MOV [W14+2], W4
007BA0  980245     MOV W5, [W4+8]
155:               					break;
007BA2  000000     NOP
156:               			}
157:               	
158:               			iPckRx+=1;						// incremento l'indice
007BA4  2095A4     MOV #0x95A, W4
007BA6  784214     MOV.B [W4], W4
007BA8  E84204     INC.B W4, W4
007BAA  784304     MOV.B W4, W6
007BAC  2095A5     MOV #0x95A, W5
007BAE  784A86     MOV.B W6, [W5]
159:               			if(iPckRx > 9)					// se ho completato la sequenza
007BB0  2095A4     MOV #0x95A, W4
007BB2  784214     MOV.B [W4], W4
007BB4  524FE9     SUB.B W4, #0x9, [W15]
007BB6  34000B     BRA LE, 0x7BCE
160:               			{
161:               				iPckRx = 0;					// azzero l'indice di ricezione in quanto presumo che si sia inetrrotta la comunicazione
007BB8  EB4200     CLR.B W4
007BBA  784304     MOV.B W4, W6
007BBC  2095A5     MOV #0x95A, W5
007BBE  784A86     MOV.B W6, [W5]
162:               				TimeOutRx.Enable = 0;		// fermo il timer del time out
007BC0  A90934     BCLR 0x934, #0
163:               				TimeOutRx.Value = 0;		// e ne azzero il conteggio, cosi da essere pronto alla ricezione di un nuovo pacchetto
007BC2  EB0200     CLR W4
007BC4  884984     MOV W4, TimeOutRx
164:               				TimeOutRx.TimeOut = 0;		// e resetto il flag di time out
007BC6  A92934     BCLR 0x934, #1
165:               				Rx_Buff->Valid_Data = 1;	// dico che ho ricevuto un dato valido
007BC8  90021E     MOV [W14+2], W4
007BCA  B3C015     MOV.B #0x1, W5
007BCC  984A25     MOV.B W5, [W4+10]
166:               			}
167:               		}
168:               
169:               	}
170:               }
007BD6  FA8000     ULNK
007BD8  060000     RETURN
171:               
172:               void IntTimeOutRx(void)
173:               {
007BDA  FA0000     LNK #0x0
174:               	if(TimeOutRx.Enable == 1)			// controllo se il timer è attivo
007BDC  8049A4     MOV 0x934, W4
007BDE  620261     AND W4, #0x1, W4
007BE0  520FE0     SUB W4, #0x0, [W15]
007BE2  32000E     BRA Z, 0x7C00
175:               	{
176:               		TimeOutRx.Value += 1;			// gestisco il conteggio del timer
007BE4  804984     MOV TimeOutRx, W4
007BE6  E80204     INC W4, W4
007BE8  884984     MOV W4, TimeOutRx
177:               		if (TimeOutRx.Value >= TimeOutRx.Time)	// gestisco il time out
007BEA  804985     MOV TimeOutRx, W5
007BEC  804994     MOV 0x932, W4
007BEE  528F84     SUB W5, W4, [W15]
007BF0  390007     BRA NC, 0x7C00
178:               		{
179:               			TimeOutRx.Enable = 0;		// fermo il timer del time out
007BF2  A90934     BCLR 0x934, #0
180:               			TimeOutRx.Value = 0;		// e ne azzero il conteggio, cosi da essere pronto alla ricezione di un nuovo pacchetto
007BF4  EB0200     CLR W4
007BF6  884984     MOV W4, TimeOutRx
181:               			iPckRx = 0;					// azzero l'indice di ricezione in quanto presumo che si sia inetrrotta la comunicazione
007BF8  EB4200     CLR.B W4
007BFA  784304     MOV.B W4, W6
007BFC  2095A5     MOV #0x95A, W5
007BFE  784A86     MOV.B W6, [W5]
182:               		}
183:               	}
184:               }
007C00  FA8000     ULNK
007C02  060000     RETURN
185:               
186:               void Recive_Cmd(volatile TypBuffer * Rx_Buff, volatile TypBuffer * LastCmd)
187:               {
007C04  FA0006     LNK #0x6
007C06  980710     MOV W0, [W14+2]
007C08  980721     MOV W1, [W14+4]
188:               	if(Rx_Buff->Valid_Data == 1)		// controllo se ho finito di ricevere un pacchetto
007C0A  90021E     MOV [W14+2], W4
007C0C  904A24     MOV.B [W4+10], W4
007C0E  524FE1     SUB.B W4, #0x1, [W15]
007C10  3A002D     BRA NZ, 0x7C6C
189:               	{
190:               		int CRC16_calcolato = 0;
007C12  EB0200     CLR W4
007C14  780F04     MOV W4, [W14]
191:               
192:               		CopyBuffer(LastCmd, Rx_Buff);	// copio quello che ho ricevuto così da liberare il buffer di ricezione
007C16  90009E     MOV [W14+2], W1
007C18  90002E     MOV [W14+4], W0
007C1A  07FEE6     RCALL CopyBuffer
193:               		iPckRx = 0;						// reinizializzo l'indice 
007C1C  EB4200     CLR.B W4
007C1E  784304     MOV.B W4, W6
007C20  2095A5     MOV #0x95A, W5
007C22  784A86     MOV.B W6, [W5]
194:               		Rx_Buff->Valid_Data = 0;		// resetto la validità del buffer di rx in quanto lo già copiato per analizzarlo
007C24  90021E     MOV [W14+2], W4
007C26  EB4280     CLR.B W5
007C28  984A25     MOV.B W5, [W4+10]
195:               		LastCmd->Valid_Data = 0;		// resetto la validità del dato, sarà il controllo a giudicarne la validità
007C2A  90022E     MOV [W14+4], W4
007C2C  EB4280     CLR.B W5
007C2E  984A25     MOV.B W5, [W4+10]
196:               
197:               		CRC16_calcolato = GenerateCRC(*LastCmd);	// mi calcolo il CRC del pacchetto
007C30  9002AE     MOV [W14+4], W5
007C32  780015     MOV [W5], W0
007C34  900095     MOV [W5+2], W1
007C36  900125     MOV [W5+4], W2
007C38  9001B5     MOV [W5+6], W3
007C3A  900245     MOV [W5+8], W4
007C3C  9002D5     MOV [W5+10], W5
007C3E  07FE91     RCALL GenerateCRC
007C40  780200     MOV W0, W4
007C42  780F04     MOV W4, [W14]
198:               
199:               		if(CRC16_calcolato == LastCmd->CRC16)		// se è uguale a quello ricevuto il pacchetto è ok
007C44  78029E     MOV [W14], W5
007C46  90022E     MOV [W14+4], W4
007C48  900244     MOV [W4+8], W4
007C4A  528F84     SUB W5, W4, [W15]
007C4C  3A000F     BRA NZ, 0x7C6C
200:               		{
201:               			//if((LastCmd->Dest_Add == My_Address) | (LastCmd->Dest_Add == LastCmd->Mitt_Add))	// cotrollo se è indirizzato a me o è in broadCast
202:               			if((LastCmd->Dest_Add == My_Address) || (LastCmd->Dest_Add == LastCmd->Mitt_Add))	// Modifica 10/06/2015
007C4E  90022E     MOV [W14+4], W4
007C50  904294     MOV.B [W4+1], W5
007C52  20A914     MOV #0xA91, W4
007C54  784214     MOV.B [W4], W4
007C56  52CF84     SUB.B W5, W4, [W15]
007C58  320006     BRA Z, 0x7C66
007C5A  90022E     MOV [W14+4], W4
007C5C  904294     MOV.B [W4+1], W5
007C5E  90022E     MOV [W14+4], W4
007C60  904224     MOV.B [W4+2], W4
007C62  52CF84     SUB.B W5, W4, [W15]
007C64  3A0003     BRA NZ, 0x7C6C
203:               			{
204:               				LastCmd->Valid_Data = 1;			// a questo punto devo analizzare il pacchetto
007C66  90022E     MOV [W14+4], W4
007C68  B3C015     MOV.B #0x1, W5
007C6A  984A25     MOV.B W5, [W4+10]
205:               			}
206:               		}
207:               
208:               	}
209:               }
007C6C  FA8000     ULNK
007C6E  060000     RETURN
210:               
211:               void Write_Cmd(volatile TypBuffer * Tx_Buff, char Address, char Comando, int Registro, int Data)
212:               {
007C70  FA000C     LNK #0xC
007C72  980720     MOV W0, [W14+4]
007C74  984761     MOV.B W1, [W14+6]
007C76  984772     MOV.B W2, [W14+7]
007C78  980743     MOV W3, [W14+8]
007C7A  980754     MOV W4, [W14+10]
213:               	int CRC = 0;
007C7C  EB0200     CLR W4
007C7E  780F04     MOV W4, [W14]
214:               	char ReturnValue = 0;
007C80  EB4200     CLR.B W4
007C82  984724     MOV.B W4, [W14+2]
215:               
216:               	Tx_Buff->Start_Chr = StartPack;
007C84  90022E     MOV [W14+4], W4
007C86  B3C555     MOV.B #0x55, W5
007C88  784A05     MOV.B W5, [W4]
217:               	Tx_Buff->Dest_Add = Address;
007C8A  9042EE     MOV.B [W14+6], W5
007C8C  90022E     MOV [W14+4], W4
007C8E  984215     MOV.B W5, [W4+1]
218:               	Tx_Buff->Mitt_Add = My_Address;
007C90  20A915     MOV #0xA91, W5
007C92  784295     MOV.B [W5], W5
007C94  90022E     MOV [W14+4], W4
007C96  984225     MOV.B W5, [W4+2]
219:               	Tx_Buff->Comando = Comando;
007C98  9042FE     MOV.B [W14+7], W5
007C9A  90022E     MOV [W14+4], W4
007C9C  984235     MOV.B W5, [W4+3]
220:               	Tx_Buff->Registro = Registro;
007C9E  9002CE     MOV [W14+8], W5
007CA0  90022E     MOV [W14+4], W4
007CA2  980225     MOV W5, [W4+4]
221:               	Tx_Buff->Data = Data;
007CA4  9002DE     MOV [W14+10], W5
007CA6  90022E     MOV [W14+4], W4
007CA8  980235     MOV W5, [W4+6]
222:               	CRC = GenerateCRC(*Tx_Buff);
007CAA  9002AE     MOV [W14+4], W5
007CAC  780015     MOV [W5], W0
007CAE  900095     MOV [W5+2], W1
007CB0  900125     MOV [W5+4], W2
007CB2  9001B5     MOV [W5+6], W3
007CB4  900245     MOV [W5+8], W4
007CB6  9002D5     MOV [W5+10], W5
007CB8  07FE54     RCALL GenerateCRC
007CBA  780200     MOV W0, W4
007CBC  780F04     MOV W4, [W14]
223:               	Tx_Buff->CRC16 = CRC;
007CBE  78029E     MOV [W14], W5
007CC0  90022E     MOV [W14+4], W4
007CC2  980245     MOV W5, [W4+8]
224:               	Tx_Buff->Valid_Data = 1;
007CC4  90022E     MOV [W14+4], W4
007CC6  B3C015     MOV.B #0x1, W5
007CC8  984A25     MOV.B W5, [W4+10]
225:               
226:               	ReturnValue = WriteBus(Tx_Buff);
007CCA  90002E     MOV [W14+4], W0
007CCC  07FEB2     RCALL WriteBus
007CCE  784200     MOV.B W0, W4
007CD0  984724     MOV.B W4, [W14+2]
227:               }
007CD2  FA8000     ULNK
007CD4  060000     RETURN
228:               
229:               void Write_brc_Cmd(volatile TypBuffer * Tx_Buff, char Comando, int Registro, int Data)
230:               {
007CD6  FA000C     LNK #0xC
007CD8  980720     MOV W0, [W14+4]
007CDA  984761     MOV.B W1, [W14+6]
007CDC  980742     MOV W2, [W14+8]
007CDE  980753     MOV W3, [W14+10]
231:               	volatile int CRC = 0;
007CE0  EB0200     CLR W4
007CE2  780F04     MOV W4, [W14]
232:               	volatile char ReturnValue = 0;
007CE4  EB4200     CLR.B W4
007CE6  984724     MOV.B W4, [W14+2]
233:               
234:               	Tx_Buff->Start_Chr = StartPack;
007CE8  90022E     MOV [W14+4], W4
007CEA  B3C555     MOV.B #0x55, W5
007CEC  784A05     MOV.B W5, [W4]
235:               	Tx_Buff->Dest_Add = My_Address;
007CEE  20A915     MOV #0xA91, W5
007CF0  784295     MOV.B [W5], W5
007CF2  90022E     MOV [W14+4], W4
007CF4  984215     MOV.B W5, [W4+1]
236:               	Tx_Buff->Mitt_Add = My_Address;
007CF6  20A915     MOV #0xA91, W5
007CF8  784295     MOV.B [W5], W5
007CFA  90022E     MOV [W14+4], W4
007CFC  984225     MOV.B W5, [W4+2]
237:               	Tx_Buff->Comando = Comando;
007CFE  9042EE     MOV.B [W14+6], W5
007D00  90022E     MOV [W14+4], W4
007D02  984235     MOV.B W5, [W4+3]
238:               	Tx_Buff->Registro = Registro;
007D04  9002CE     MOV [W14+8], W5
007D06  90022E     MOV [W14+4], W4
007D08  980225     MOV W5, [W4+4]
239:               	Tx_Buff->Data = Data;
007D0A  9002DE     MOV [W14+10], W5
007D0C  90022E     MOV [W14+4], W4
007D0E  980235     MOV W5, [W4+6]
240:               	CRC = GenerateCRC(*Tx_Buff);
007D10  9002AE     MOV [W14+4], W5
007D12  780015     MOV [W5], W0
007D14  900095     MOV [W5+2], W1
007D16  900125     MOV [W5+4], W2
007D18  9001B5     MOV [W5+6], W3
007D1A  900245     MOV [W5+8], W4
007D1C  9002D5     MOV [W5+10], W5
007D1E  07FE21     RCALL GenerateCRC
007D20  780200     MOV W0, W4
007D22  780F04     MOV W4, [W14]
241:               	Tx_Buff->CRC16 = CRC;
007D24  78021E     MOV [W14], W4
007D26  780284     MOV W4, W5
007D28  90022E     MOV [W14+4], W4
007D2A  980245     MOV W5, [W4+8]
242:               	Tx_Buff->Valid_Data = 1;
007D2C  90022E     MOV [W14+4], W4
007D2E  B3C015     MOV.B #0x1, W5
007D30  984A25     MOV.B W5, [W4+10]
243:               
244:               	ReturnValue = WriteBus(Tx_Buff);
007D32  90002E     MOV [W14+4], W0
007D34  07FE7E     RCALL WriteBus
007D36  784200     MOV.B W0, W4
007D38  984724     MOV.B W4, [W14+2]
245:               }
007D3A  FA8000     ULNK
007D3C  060000     RETURN
---  D:/WORK3/Lavori/TERMODINAMICA/Work/FW/1 - Generico/Split/Split v.8.4.22 - Working/DefinePeriferiche.c
1:                 //----------------------------------------------------------------------------------
2:                 //	Progect name:	ProtocolloComunicazione.c
3:                 //	Device:			PIC18F4550 @ 20Mhz (PLL 96 Mhz)
4:                 //	Autor:			Emanuele
5:                 //	Date:			22/05/2011
6:                 //	Description:	Corpo delle funzioni che gestiscono la comunicazione con il sistema
7:                 //----------------------------------------------------------------------------------
8:                 
9:                 //----------------------------------------------------------------------------------
10:                //	Include
11:                //----------------------------------------------------------------------------------
12:                #include "MicroModelSelection.h"
13:                #ifdef GB210
14:                	#include <p24FJ256GB210.h>
15:                #else
16:                	#include <p24FJ256GB110.h>
17:                #endif
18:                #include "DefinePeriferiche.h"
19:                
20:                #define	NULL	0
21:                
22:                VariabiliGlobaliADC();
23:                VariabiliGlobaliDriverComunicazione();
24:                VariabiliGlobaliDriverComunicazioneSec();
25:                VariabiliGlobaliDriverModBus();
26:                VariabiliGlobaliProtocolloComunicazione();
27:                VariabiliGlobaliProtocolloComunicazioneSec();
28:                VariabiliGlobaliProtocolloModBus();
29:                VariabiliGlobaliEEPROM();
30:                VariabiliGlobaliPWM();
31:                VariabiliGlobaliValvolaExp();
32:                
33:                
34:                //----------------------------------------------------------------------------------
35:                //	Funzioni
36:                //----------------------------------------------------------------------------------
37:                void Remap_RP(void)
38:                {
0080DC  FA0000     LNK #0x0
39:                	// Unlook sequence
40:                	OSCCON &= 0xFF00;
0080DE  803A15     MOV OSCCON, W5
0080E0  2FF004     MOV #0xFF00, W4
0080E2  628204     AND W5, W4, W4
0080E4  883A14     MOV W4, OSCCON
41:                	OSCCON |= 0x46;
0080E6  803A15     MOV OSCCON, W5
0080E8  200464     MOV #0x46, W4
0080EA  720205     IOR W4, W5, W4
0080EC  883A14     MOV W4, OSCCON
42:                	OSCCON |= 0x57;
0080EE  803A15     MOV OSCCON, W5
0080F0  200574     MOV #0x57, W4
0080F2  720205     IOR W4, W5, W4
0080F4  883A14     MOV W4, OSCCON
43:                	OSCCONbits.IOLOCK = 0;
0080F6  A9C742     BCLR OSCCON, #6
44:                
45:                	//-------------------------------------------------------------------
46:                	// Configurazione Input
47:                	//-------------------------------------------------------------------
48:                /*	---- INPUT ----
49:                	Ogni input ha una periferica, una volta abilitata, con i 5 bit del registro, si imposta il numero dell'RPIN(X)
50:                	Ex:
51:                	RPINR18bits.U1RX = 4;		// il segnale di input U1Rx (reciver UART1), viene assegnato all'ingresso RPIN4
52:                */
53:                	RPINR0bits.INT1R = 0x1F;		// Ext. interrupt 1
0080F8  803405     MOV RPINR0, W5
0080FA  2C0FF4     MOV #0xC0FF, W4
0080FC  628284     AND W5, W4, W5
0080FE  21F004     MOV #0x1F00, W4
008100  720205     IOR W4, W5, W4
008102  883404     MOV W4, RPINR0
54:                	RPINR1bits.INT2R = 0x1F;		// Ext. interrupt 2
008104  803415     MOV RPINR1, W5
008106  2FFC04     MOV #0xFFC0, W4
008108  628204     AND W5, W4, W4
00810A  B301F4     IOR #0x1F, W4
00810C  883414     MOV W4, RPINR1
55:                	RPINR1bits.INT3R = 0x1F;		// Ext. interrupt 3
00810E  803415     MOV RPINR1, W5
008110  2C0FF4     MOV #0xC0FF, W4
008112  628284     AND W5, W4, W5
008114  21F004     MOV #0x1F00, W4
008116  720205     IOR W4, W5, W4
008118  883414     MOV W4, RPINR1
56:                	RPINR2bits.INT4R = 0x1F;		// Ext. interrupt 4
00811A  803425     MOV RPINR2, W5
00811C  2FFC04     MOV #0xFFC0, W4
00811E  628204     AND W5, W4, W4
008120  B301F4     IOR #0x1F, W4
008122  883424     MOV W4, RPINR2
57:                #ifdef __24FJ256GB210_H
58:                #else	
59:                	RPINR2bits.T1CKR = 0x1F; 
008124  803425     MOV RPINR2, W5
008126  2C0FF4     MOV #0xC0FF, W4
008128  628284     AND W5, W4, W5
00812A  21F004     MOV #0x1F00, W4
00812C  720205     IOR W4, W5, W4
00812E  883424     MOV W4, RPINR2
60:                #endif	
61:                	RPINR3bits.T2CKR = 0x1F;		// Timer 2 ext CK
008130  803435     MOV RPINR3, W5
008132  2FFC04     MOV #0xFFC0, W4
008134  628204     AND W5, W4, W4
008136  B301F4     IOR #0x1F, W4
008138  883434     MOV W4, RPINR3
62:                	RPINR3bits.T3CKR = 41;			// Timer 3 ext CK			==> on RPI41
00813A  803435     MOV RPINR3, W5
00813C  2C0FF4     MOV #0xC0FF, W4
00813E  628284     AND W5, W4, W5
008140  229004     MOV #0x2900, W4
008142  720205     IOR W4, W5, W4
008144  883434     MOV W4, RPINR3
63:                	RPINR4bits.T4CKR = 0x1F;		// Timer 4 ext CK
008146  803445     MOV RPINR4, W5
008148  2FFC04     MOV #0xFFC0, W4
00814A  628204     AND W5, W4, W4
00814C  B301F4     IOR #0x1F, W4
00814E  883444     MOV W4, RPINR4
64:                	RPINR4bits.T5CKR = 0x1F;		// Timer 5 ext CK
008150  803445     MOV RPINR4, W5
008152  2C0FF4     MOV #0xC0FF, W4
008154  628284     AND W5, W4, W5
008156  21F004     MOV #0x1F00, W4
008158  720205     IOR W4, W5, W4
00815A  883444     MOV W4, RPINR4
65:                	RPINR7bits.IC1R = 0x1F;			// Input capture 1
00815C  803475     MOV RPINR7, W5
00815E  2FFC04     MOV #0xFFC0, W4
008160  628204     AND W5, W4, W4
008162  B301F4     IOR #0x1F, W4
008164  883474     MOV W4, RPINR7
66:                	RPINR7bits.IC2R = 0x1F;			// Input capture 2
008166  803475     MOV RPINR7, W5
008168  2C0FF4     MOV #0xC0FF, W4
00816A  628284     AND W5, W4, W5
00816C  21F004     MOV #0x1F00, W4
00816E  720205     IOR W4, W5, W4
008170  883474     MOV W4, RPINR7
67:                	RPINR8bits.IC3R = 0x1F;			// Input capture 3
008172  803485     MOV RPINR8, W5
008174  2FFC04     MOV #0xFFC0, W4
008176  628204     AND W5, W4, W4
008178  B301F4     IOR #0x1F, W4
00817A  883484     MOV W4, RPINR8
68:                	RPINR8bits.IC4R = 0x1F;			// Input capture 4
00817C  803485     MOV RPINR8, W5
00817E  2C0FF4     MOV #0xC0FF, W4
008180  628284     AND W5, W4, W5
008182  21F004     MOV #0x1F00, W4
008184  720205     IOR W4, W5, W4
008186  883484     MOV W4, RPINR8
69:                	RPINR9bits.IC5R = 0x1F;			// Input capture 5
008188  803495     MOV RPINR9, W5
00818A  2FFC04     MOV #0xFFC0, W4
00818C  628204     AND W5, W4, W4
00818E  B301F4     IOR #0x1F, W4
008190  883494     MOV W4, RPINR9
70:                	RPINR9bits.IC6R = 0x1F;			// Input capture 6
008192  803495     MOV RPINR9, W5
008194  2C0FF4     MOV #0xC0FF, W4
008196  628284     AND W5, W4, W5
008198  21F004     MOV #0x1F00, W4
00819A  720205     IOR W4, W5, W4
00819C  883494     MOV W4, RPINR9
71:                	RPINR10bits.IC7R = 0x1F;		// Input capture 7
00819E  8034A5     MOV RPINR10, W5
0081A0  2FFC04     MOV #0xFFC0, W4
0081A2  628204     AND W5, W4, W4
0081A4  B301F4     IOR #0x1F, W4
0081A6  8834A4     MOV W4, RPINR10
72:                	RPINR10bits.IC8R = 0x1F;		// Input capture 8
0081A8  8034A5     MOV RPINR10, W5
0081AA  2C0FF4     MOV #0xC0FF, W4
0081AC  628284     AND W5, W4, W5
0081AE  21F004     MOV #0x1F00, W4
0081B0  720205     IOR W4, W5, W4
0081B2  8834A4     MOV W4, RPINR10
73:                	RPINR11bits.OCFAR = 0x1F;		// Output compare Fault A
0081B4  8034B5     MOV RPINR11, W5
0081B6  2FFC04     MOV #0xFFC0, W4
0081B8  628204     AND W5, W4, W4
0081BA  B301F4     IOR #0x1F, W4
0081BC  8834B4     MOV W4, RPINR11
74:                	RPINR11bits.OCFBR = 0x1F;		// Output compare Fault B
0081BE  8034B5     MOV RPINR11, W5
0081C0  2C0FF4     MOV #0xC0FF, W4
0081C2  628284     AND W5, W4, W5
0081C4  21F004     MOV #0x1F00, W4
0081C6  720205     IOR W4, W5, W4
0081C8  8834B4     MOV W4, RPINR11
75:                	RPINR15bits.IC9R = 0x1F;		// Input capture 9
0081CA  8034F5     MOV RPINR15, W5
0081CC  2C0FF4     MOV #0xC0FF, W4
0081CE  628284     AND W5, W4, W5
0081D0  21F004     MOV #0x1F00, W4
0081D2  720205     IOR W4, W5, W4
0081D4  8834F4     MOV W4, RPINR15
76:                	RPINR17bits.U3RXR = 0x1F;		// UART 3 Recive
0081D6  803515     MOV RPINR17, W5
0081D8  2C0FF4     MOV #0xC0FF, W4
0081DA  628284     AND W5, W4, W5
0081DC  21F004     MOV #0x1F00, W4
0081DE  720205     IOR W4, W5, W4
0081E0  883514     MOV W4, RPINR17
77:                	RPINR18bits.U1RXR = 5;			// UART 1 Recive			==> on RP5
0081E2  803525     MOV RPINR18, W5
0081E4  2FFC04     MOV #0xFFC0, W4
0081E6  628204     AND W5, W4, W4
0081E8  B30054     IOR #0x5, W4
0081EA  883524     MOV W4, RPINR18
78:                	RPINR18bits.U1CTSR = 0x1F;		// UART 1 Clear to send
0081EC  803525     MOV RPINR18, W5
0081EE  2C0FF4     MOV #0xC0FF, W4
0081F0  628284     AND W5, W4, W5
0081F2  21F004     MOV #0x1F00, W4
0081F4  720205     IOR W4, W5, W4
0081F6  883524     MOV W4, RPINR18
79:                	RPINR19bits.U2RXR = 15;			// UART 2 Recive			==> ON RP15
0081F8  803535     MOV RPINR19, W5
0081FA  2FFC04     MOV #0xFFC0, W4
0081FC  628204     AND W5, W4, W4
0081FE  B300F4     IOR #0xF, W4
008200  883534     MOV W4, RPINR19
80:                	RPINR19bits.U2CTSR = 0x1F;		// UART 2 Clear to send
008202  803535     MOV RPINR19, W5
008204  2C0FF4     MOV #0xC0FF, W4
008206  628284     AND W5, W4, W5
008208  21F004     MOV #0x1F00, W4
00820A  720205     IOR W4, W5, W4
00820C  883534     MOV W4, RPINR19
81:                	RPINR20bits.SDI1R = 0x1F;		// SPI 1 Data Input
00820E  803545     MOV RPINR20, W5
008210  2FFC04     MOV #0xFFC0, W4
008212  628204     AND W5, W4, W4
008214  B301F4     IOR #0x1F, W4
008216  883544     MOV W4, RPINR20
82:                	RPINR20bits.SCK1R = 0x1F;		// SPI 1 Clock Input
008218  803545     MOV RPINR20, W5
00821A  2C0FF4     MOV #0xC0FF, W4
00821C  628284     AND W5, W4, W5
00821E  21F004     MOV #0x1F00, W4
008220  720205     IOR W4, W5, W4
008222  883544     MOV W4, RPINR20
83:                	RPINR21bits.SS1R = 0x1F;		// SPI 1 Slave Select Input
008224  803555     MOV RPINR21, W5
008226  2FFC04     MOV #0xFFC0, W4
008228  628204     AND W5, W4, W4
00822A  B301F4     IOR #0x1F, W4
00822C  883554     MOV W4, RPINR21
84:                	RPINR21bits.U3CTSR = 0x1F;		// UART 3 Clear to send
00822E  803555     MOV RPINR21, W5
008230  2C0FF4     MOV #0xC0FF, W4
008232  628284     AND W5, W4, W5
008234  21F004     MOV #0x1F00, W4
008236  720205     IOR W4, W5, W4
008238  883554     MOV W4, RPINR21
85:                	RPINR22bits.SDI2R = 0x1F;		// SPI 2 Data Input
00823A  803565     MOV RPINR22, W5
00823C  2FFC04     MOV #0xFFC0, W4
00823E  628204     AND W5, W4, W4
008240  B301F4     IOR #0x1F, W4
008242  883564     MOV W4, RPINR22
86:                	RPINR22bits.SCK2R = 0x1F;		// SPI 2 Clock Input
008244  803565     MOV RPINR22, W5
008246  2C0FF4     MOV #0xC0FF, W4
008248  628284     AND W5, W4, W5
00824A  21F004     MOV #0x1F00, W4
00824C  720205     IOR W4, W5, W4
00824E  883564     MOV W4, RPINR22
87:                	RPINR23bits.SS2R = 0x1F;		// SPI 2 Slave Select Input
008250  803575     MOV RPINR23, W5
008252  2FFC04     MOV #0xFFC0, W4
008254  628204     AND W5, W4, W4
008256  B301F4     IOR #0x1F, W4
008258  883574     MOV W4, RPINR23
88:                	RPINR27bits.U4RXR = 0x1F;		// UART 4 Recive
00825A  8035B5     MOV RPINR27, W5
00825C  2FFC04     MOV #0xFFC0, W4
00825E  628204     AND W5, W4, W4
008260  B301F4     IOR #0x1F, W4
008262  8835B4     MOV W4, RPINR27
89:                	RPINR27bits.U4CTSR = 0x1F;		// UART 4 Clear to send
008264  8035B5     MOV RPINR27, W5
008266  2C0FF4     MOV #0xC0FF, W4
008268  628284     AND W5, W4, W5
00826A  21F004     MOV #0x1F00, W4
00826C  720205     IOR W4, W5, W4
00826E  8835B4     MOV W4, RPINR27
90:                	RPINR28bits.SDI3R = 0x1F;		// SPI 3 Data Input
008270  8035C5     MOV RPINR28, W5
008272  2FFC04     MOV #0xFFC0, W4
008274  628204     AND W5, W4, W4
008276  B301F4     IOR #0x1F, W4
008278  8835C4     MOV W4, RPINR28
91:                	RPINR28bits.SCK3R = 0x1F;		// SPI 3 Clock Input
00827A  8035C5     MOV RPINR28, W5
00827C  2C0FF4     MOV #0xC0FF, W4
00827E  628284     AND W5, W4, W5
008280  21F004     MOV #0x1F00, W4
008282  720205     IOR W4, W5, W4
008284  8835C4     MOV W4, RPINR28
92:                	RPINR29bits.SS3R = 0x1F;		// SPI 3 Slave Select Input
008286  8035D5     MOV RPINR29, W5
008288  2FFC04     MOV #0xFFC0, W4
00828A  628204     AND W5, W4, W4
00828C  B301F4     IOR #0x1F, W4
00828E  8835D4     MOV W4, RPINR29
93:                
94:                	//-------------------------------------------------------------------
95:                	// Configurazione Output
96:                	//-------------------------------------------------------------------
97:                /*	---- OUTPUT ----
98:                	Ad ogni pin RPORn, può essere assegnato l'id di una uscita di una qualsiasi periferica
99:                	NULL = 0;		// Null
100:               	C1OUT = 1;		// Comparator 1 out
101:               	C2OUT = 2;		// Comparator 2 out
102:               	U1TX = 3;		// UART1 Tx
103:               	U1RTS = 4;		// UART1 RTS
104:               	U2TX = 5;		// UART2 Tx
105:               	U2RTS = 6;		// UART2 RTS
106:               	SDO1 = 7;		// SPI1 Data out
107:               	SCK1OUT = 8;	// SPI1 Clock out
108:               	SS1OUT = 9;		// SPI1 Slave select out
109:               	SDO2 = 10;		// SPI2 Data out
110:               	SCK2OUT = 11;	// SPI2 Clock out
111:               	SS2OUT = 12;	// SPI2 Slave select out
112:               	OC1 = 18;		// Output compare 1
113:               	OC2 = 19;		// Output compare 2
114:               	OC3 = 20;		// Output compare 3
115:               	OC4 = 21;		// Output compare 4
116:               	OC5 = 22;		// Output compare 5
117:               	Ex:
118:               	RP1OR1bits.RP20R = OC1;	// setto sul pin RP20 l'uscita 18, Output compare 1
119:               */
120:               	RPOR0bits.RP0R = NULL;		// RP0
008290  803605     MOV RPOR0, W5
008292  2FFC04     MOV #0xFFC0, W4
008294  628204     AND W5, W4, W4
008296  883604     MOV W4, RPOR0
121:               	RPOR0bits.RP1R = NULL;		// RP1
008298  803605     MOV RPOR0, W5
00829A  2C0FF4     MOV #0xC0FF, W4
00829C  628204     AND W5, W4, W4
00829E  883604     MOV W4, RPOR0
122:               	RPOR1bits.RP2R = NULL;		// RP2
0082A0  803615     MOV RPOR1, W5
0082A2  2FFC04     MOV #0xFFC0, W4
0082A4  628204     AND W5, W4, W4
0082A6  883614     MOV W4, RPOR1
123:               	RPOR1bits.RP3R = NULL;		// RP3
0082A8  803615     MOV RPOR1, W5
0082AA  2C0FF4     MOV #0xC0FF, W4
0082AC  628204     AND W5, W4, W4
0082AE  883614     MOV W4, RPOR1
124:               	RPOR2bits.RP4R = NULL;		// RP4
0082B0  803625     MOV RPOR2, W5
0082B2  2FFC04     MOV #0xFFC0, W4
0082B4  628204     AND W5, W4, W4
0082B6  883624     MOV W4, RPOR2
125:               	RPOR2bits.RP5R = NULL;		// RP5
0082B8  803625     MOV RPOR2, W5
0082BA  2C0FF4     MOV #0xC0FF, W4
0082BC  628204     AND W5, W4, W4
0082BE  883624     MOV W4, RPOR2
126:               	RPOR3bits.RP6R = NULL;		// RP6
0082C0  803635     MOV RPOR3, W5
0082C2  2FFC04     MOV #0xFFC0, W4
0082C4  628204     AND W5, W4, W4
0082C6  883634     MOV W4, RPOR3
127:               	RPOR3bits.RP7R = NULL;		// RP7
0082C8  803635     MOV RPOR3, W5
0082CA  2C0FF4     MOV #0xC0FF, W4
0082CC  628204     AND W5, W4, W4
0082CE  883634     MOV W4, RPOR3
128:               	RPOR4bits.RP8R = NULL;		// RP8
0082D0  803645     MOV RPOR4, W5
0082D2  2FFC04     MOV #0xFFC0, W4
0082D4  628204     AND W5, W4, W4
0082D6  883644     MOV W4, RPOR4
129:               	RPOR4bits.RP9R = NULL;		// RP9
0082D8  803645     MOV RPOR4, W5
0082DA  2C0FF4     MOV #0xC0FF, W4
0082DC  628204     AND W5, W4, W4
0082DE  883644     MOV W4, RPOR4
130:               	RPOR5bits.RP10R = U1TX;		// RP10	=> U1Tx 485
0082E0  803655     MOV RPOR5, W5
0082E2  2FFC04     MOV #0xFFC0, W4
0082E4  628204     AND W5, W4, W4
0082E6  B30034     IOR #0x3, W4
0082E8  883654     MOV W4, RPOR5
131:               	RPOR5bits.RP11R = NULL;		// RP11
0082EA  803655     MOV RPOR5, W5
0082EC  2C0FF4     MOV #0xC0FF, W4
0082EE  628204     AND W5, W4, W4
0082F0  883654     MOV W4, RPOR5
132:               	RPOR6bits.RP12R = NULL;		// RP12
0082F2  803665     MOV RPOR6, W5
0082F4  2FFC04     MOV #0xFFC0, W4
0082F6  628204     AND W5, W4, W4
0082F8  883664     MOV W4, RPOR6
133:               	RPOR6bits.RP13R = NULL;		// RP13
0082FA  803665     MOV RPOR6, W5
0082FC  2C0FF4     MOV #0xC0FF, W4
0082FE  628204     AND W5, W4, W4
008300  883664     MOV W4, RPOR6
134:               	RPOR7bits.RP14R = NULL;		// RP14
008302  803675     MOV RPOR7, W5
008304  2FFC04     MOV #0xFFC0, W4
008306  628204     AND W5, W4, W4
008308  883674     MOV W4, RPOR7
135:               	RPOR7bits.RP15R = NULL;		// RP15
00830A  803675     MOV RPOR7, W5
00830C  2C0FF4     MOV #0xC0FF, W4
00830E  628204     AND W5, W4, W4
008310  883674     MOV W4, RPOR7
136:               	RPOR8bits.RP16R = NULL;		// RP16
008312  803685     MOV RPOR8, W5
008314  2FFC04     MOV #0xFFC0, W4
008316  628204     AND W5, W4, W4
008318  883684     MOV W4, RPOR8
137:               	RPOR8bits.RP17R = NULL;		// RP17
00831A  803685     MOV RPOR8, W5
00831C  2C0FF4     MOV #0xC0FF, W4
00831E  628204     AND W5, W4, W4
008320  883684     MOV W4, RPOR8
138:               	RPOR9bits.RP18R = NULL;		// RP18
008322  803695     MOV RPOR9, W5
008324  2FFC04     MOV #0xFFC0, W4
008326  628204     AND W5, W4, W4
008328  883694     MOV W4, RPOR9
139:               	RPOR9bits.RP19R = NULL;		// RP19
00832A  803695     MOV RPOR9, W5
00832C  2C0FF4     MOV #0xC0FF, W4
00832E  628204     AND W5, W4, W4
008330  883694     MOV W4, RPOR9
140:               	RPOR10bits.RP20R = NULL;	// RP20
008332  8036A5     MOV RPOR10, W5
008334  2FFC04     MOV #0xFFC0, W4
008336  628204     AND W5, W4, W4
008338  8836A4     MOV W4, RPOR10
141:               	RPOR10bits.RP21R = OC_1;		// RP21 => OC1 Fan Output compare PWM
00833A  8036A5     MOV RPOR10, W5
00833C  2C0FF4     MOV #0xC0FF, W4
00833E  628284     AND W5, W4, W5
008340  212004     MOV #0x1200, W4
008342  720205     IOR W4, W5, W4
008344  8836A4     MOV W4, RPOR10
142:               	RPOR11bits.RP22R = NULL;	// RP22
008346  8036B5     MOV RPOR11, W5
008348  2FFC04     MOV #0xFFC0, W4
00834A  628204     AND W5, W4, W4
00834C  8836B4     MOV W4, RPOR11
143:               	RPOR11bits.RP23R = NULL;	// RP23
00834E  8036B5     MOV RPOR11, W5
008350  2C0FF4     MOV #0xC0FF, W4
008352  628204     AND W5, W4, W4
008354  8836B4     MOV W4, RPOR11
144:               	RPOR12bits.RP24R = NULL;	// RP24
008356  8036C5     MOV RPOR12, W5
008358  2FFC04     MOV #0xFFC0, W4
00835A  628204     AND W5, W4, W4
00835C  8836C4     MOV W4, RPOR12
145:               	RPOR12bits.RP25R = NULL;	// RP25
00835E  8036C5     MOV RPOR12, W5
008360  2C0FF4     MOV #0xC0FF, W4
008362  628204     AND W5, W4, W4
008364  8836C4     MOV W4, RPOR12
146:               	RPOR13bits.RP26R = NULL;	// RP26
008366  8036D5     MOV RPOR13, W5
008368  2FFC04     MOV #0xFFC0, W4
00836A  628204     AND W5, W4, W4
00836C  8836D4     MOV W4, RPOR13
147:               	RPOR13bits.RP27R = NULL;	// RP27
00836E  8036D5     MOV RPOR13, W5
008370  2C0FF4     MOV #0xC0FF, W4
008372  628204     AND W5, W4, W4
008374  8836D4     MOV W4, RPOR13
148:               	RPOR14bits.RP28R = NULL;	// RP28
008376  8036E5     MOV RPOR14, W5
008378  2FFC04     MOV #0xFFC0, W4
00837A  628204     AND W5, W4, W4
00837C  8836E4     MOV W4, RPOR14
149:               	RPOR14bits.RP29R = NULL;	// RP29
00837E  8036E5     MOV RPOR14, W5
008380  2C0FF4     MOV #0xC0FF, W4
008382  628204     AND W5, W4, W4
008384  8836E4     MOV W4, RPOR14
150:               	RPOR15bits.RP30R = U2TX;	// RP30	=> U2Tx
008386  8036F5     MOV RPOR15, W5
008388  2FFC04     MOV #0xFFC0, W4
00838A  628204     AND W5, W4, W4
00838C  B30054     IOR #0x5, W4
00838E  8836F4     MOV W4, RPOR15
151:               	RPOR15bits.RP31R = NULL;	// RP31
008390  8036F5     MOV RPOR15, W5
008392  2C0FF4     MOV #0xC0FF, W4
008394  628204     AND W5, W4, W4
008396  8836F4     MOV W4, RPOR15
152:               
153:               	// Look sequence
154:               	OSCCON &= 0xFF00;
008398  803A15     MOV OSCCON, W5
00839A  2FF004     MOV #0xFF00, W4
00839C  628204     AND W5, W4, W4
00839E  883A14     MOV W4, OSCCON
155:               	OSCCON |= 0x46;
0083A0  803A15     MOV OSCCON, W5
0083A2  200464     MOV #0x46, W4
0083A4  720205     IOR W4, W5, W4
0083A6  883A14     MOV W4, OSCCON
156:               	OSCCON |= 0x57;
0083A8  803A15     MOV OSCCON, W5
0083AA  200574     MOV #0x57, W4
0083AC  720205     IOR W4, W5, W4
0083AE  883A14     MOV W4, OSCCON
157:               	OSCCONbits.IOLOCK = 1;
0083B0  A8C742     BSET OSCCON, #6
158:               }
0083B2  FA8000     ULNK
0083B4  060000     RETURN
---  D:/WORK3/Lavori/TERMODINAMICA/Work/FW/1 - Generico/Split/Split v.8.4.22 - Working/Core.c  ----------
1:                 //----------------------------------------------------------------------------------
2:                 //	Progect name:	Core.c
3:                 //	Device:			PIC18F4550 @ 20Mhz (PLL 96 Mhz)
4:                 //	Autor:			Emanuele
5:                 //	Date:			22/05/2011
6:                 //	Description:	Corpo delle funzioni della logica di funzionamento
7:                 //----------------------------------------------------------------------------------
8:                 
9:                 //----------------------------------------------------------------------------------
10:                //	Include
11:                //----------------------------------------------------------------------------------
12:                #include "MicroModelSelection.h"
13:                #ifdef GB210
14:                	#include <p24FJ256GB210.h>
15:                #else
16:                	#include <p24FJ256GB110.h>
17:                #endif
18:                #include <stdio.h>
19:                #include "DefinePeriferiche.h"
20:                #include "Timer.h"
21:                #include "usart.h"
22:                #include "Driver_Comunicazione.h"
23:                #include "Driver_ComunicazioneSec.h"
24:                #include "Driver_ModBus.h"
25:                #include "ProtocolloComunicazione.h"
26:                #include "ProtocolloComunicazioneSec.h"
27:                #include "ProtocolloModBus.h"
28:                #include "Core.h"
29:                #include "PID.h"
30:                #include "delay.h"
31:                
32:                //----------------------------------------------------------------------------------
33:                //	Funzioni
34:                //----------------------------------------------------------------------------------
35:                /*  *****************************************************************************************************************************
36:                	"Copia i dati dalla struct Panel[] a quella Touch[] per mantenere inalterata le funzioni in Core.C che usano Touch[]...
37:                // Valori possibili provenienti dal Touch che finiscono in "Touch[0].FunctionMode":
38:                //	#define	CoreOff						0		// Spento
39:                //	#define CoreAuto					0x0002	// Automatico da touch
40:                //	#define	CoreRiscaldamento			0x0004	// Riscaldmaneto automatico, si calcola tutto e aziona in mase allo stato del box motore
41:                //	#define	CoreRaffrescamento			0x0008	// Raffreddamento automatico, si calcola tutto e aziona in mase allo stato del box motore
42:                //	#define CoreVentilazione			0x0010	// ventilazione automatica, gestisce autonomamente ventilatore e valvola
43:                //	#define CoreSlaveCaldo				0x0011	// segue la temperatura di evaporazione che gli viene impostata
44:                //	#define CoreSlaveFreddo				0x0012	// segue la temp di evporazione che gli viene impostat
45:                //	#define CoreManuale					0x0013	// viene gestito tutto in manuale
46:                // Valori possibili provenienti dal Touch che finiscono in "Touch[0].FanMode":
47:                //	case 0:		// Off
48:                //	case 1:		// Night
49:                //	case 2:		// Speed 1
50:                //	case 3:		// Speed 2
51:                //	case 4:		// Speed 3
52:                //	case 5:		// Speed 4
53:                //	case 6:		// Speed 5
54:                //	case 7:		// Speed 6
55:                //	case 8:		// Speed 7
56:                //	case 9:		// Auto
57:                //
58:                // Valori possibili provenienti dal Panel che finiscono in "Panel[0].FunctionMode":
59:                // 0..1 (0=Raffrescamento, 1=Riscaldamento)
60:                // Valori possibili provenienti dal Panel che finiscono in "Panel[0].FanMode":
61:                // 0..4 (0=OFF, 1,2,3=VEL 4=Auto)
62:                	***************************************************************************************************************************** */
63:                void Panel2Touch(void)  	// <-- smistare dati Modalità/FanMode da Panel in registri FunctionMode e FanMode (vedi CoreOff,CoreAuto,CoreVentilazione ...... 
64:                {
00286E  FA0000     LNK #0x0
65:                	if(Panel[0].Enable)
002870  8060C4     MOV 0xC18, W4
002872  620261     AND W4, #0x1, W4
002874  520FE0     SUB W4, #0x0, [W15]
002876  320031     BRA Z, 0x28DA
66:                	{
67:                		Touch[0].Enable = Panel[0].Enable;
002878  8060C4     MOV 0xC18, W4
00287A  784204     MOV.B W4, W4
00287C  624261     AND.B W4, #0x1, W4
00287E  FB8204     ZE W4, W4
002880  620261     AND W4, #0x1, W4
002882  805E26     MOV 0xBC4, W6
002884  2FFFE5     MOV #0xFFFE, W5
002886  630285     AND W6, W5, W5
002888  720205     IOR W4, W5, W4
00288A  885E24     MOV W4, 0xBC4
68:                		Touch[0].SetPoint = Panel[0].SetPoint;
00288C  806074     MOV Panel, W4
00288E  885D74     MOV W4, Touch
69:                		
70:                /*	Per ora eliminato! Il settaggio "Raffrescamento/Riscaldamento" arriva dallo Slave (Master) che è dotato di unità Touch
71:                		switch(Panel[0].FunctionMode)
72:                		{														// 0=Raffrescamento / 1=Riscaldamento
73:                			case 0:	Touch[0].FunctionMode = CoreRaffrescamento;
74:                					break;
75:                			case 1:	Touch[0].FunctionMode = CoreRiscaldamento;
76:                					break;
77:                			default:Touch[0].FunctionMode = CoreAuto;			// Nel dubbio "CoreAuto"....
78:                					break;
79:                		}
80:                */
81:                		switch(Panel[0].FanMode)
002890  806094     MOV 0xC12, W4
002892  DEA2CF     ASR W4, #15, W5
002894  200076     MOV #0x7, W6
002896  200007     MOV #0x0, W7
002898  520F86     SUB W4, W6, [W15]
00289A  5A8F87     SUBB W5, W7, [W15]
00289C  3E0018     BRA GTU, 0x28CE
00289E  016004     BRA W4
0028A0  370007     BRA 0x28B0
0028A2  370009     BRA 0x28B6
0028A4  37000B     BRA 0x28BC
0028A6  37000D     BRA 0x28C2
0028A8  37000F     BRA 0x28C8
0028AA  37000E     BRA 0x28C8
0028AC  37000D     BRA 0x28C8
0028AE  37000C     BRA 0x28C8
82:                		{
83:                			case 0:	Touch[0].FanMode = 0;						// 0 = OFF
0028B0  EB0200     CLR W4
0028B2  885D94     MOV W4, 0xBB2
84:                					break;
0028B4  37000F     BRA 0x28D4
85:                			case 1:	Touch[0].FanMode = 2;						// 2 = speed 1
0028B6  200024     MOV #0x2, W4
0028B8  885D94     MOV W4, 0xBB2
86:                					break;
0028BA  37000C     BRA 0x28D4
87:                			case 2:	Touch[0].FanMode = 5;						// 5 = speed 4
0028BC  200054     MOV #0x5, W4
0028BE  885D94     MOV W4, 0xBB2
88:                					break;
0028C0  370009     BRA 0x28D4
89:                			case 3:	Touch[0].FanMode = 8;						// 8 = speed 7
0028C2  200084     MOV #0x8, W4
0028C4  885D94     MOV W4, 0xBB2
90:                					break;
0028C6  370006     BRA 0x28D4
91:                			case 4:	
92:                			case 5:	
93:                			case 6:	
94:                			case 7:	
95:                					Touch[0].FanMode = 9;						// 9 = speed Auto
0028C8  200094     MOV #0x9, W4
0028CA  885D94     MOV W4, 0xBB2
96:                					break;
0028CC  370003     BRA 0x28D4
97:                			default:Touch[0].FanMode = 9;						// Nel dubbio "speed Auto"....
0028CE  200094     MOV #0x9, W4
0028D0  885D94     MOV W4, 0xBB2
98:                					break;
0028D2  000000     NOP
99:                		}
100:               
101:               //		Touch[0].Temperature = Panel[0].Temperature;	// Sul Touch non esiste	-> Pressione ambiente in decimi (hPa)
102:               //		Touch[0].Pressure = Panel[0].Pressure;			// Sul Touch non esiste
103:               
104:               		Touch[0].FunctionMode = Me.DefMode;
0028D4  805C34     MOV 0xB86, W4
0028D6  885D84     MOV W4, 0xBB0
0028D8  370001     BRA 0x28DC
105:               	}
106:               	else Touch[0].Enable = 0;
0028DA  A90BC4     BCLR 0xBC4, #0
107:               
108:               }
0028DC  FA8000     ULNK
0028DE  060000     RETURN
109:               
110:               
111:               
112:               /*  *****************************************************************************************************************************
113:               	Gestisco il compressore, start/stop e cambio di stagione
114:               	***************************************************************************************************************************** */
115:               void FunctionMode(void)
116:               {
0028E0  FA0000     LNK #0x0
117:               	if(Touch[0].Enable)		// se il touch 1 è abilitato
0028E2  805E24     MOV 0xBC4, W4
0028E4  620261     AND W4, #0x1, W4
0028E6  520FE0     SUB W4, #0x0, [W15]
0028E8  320090     BRA Z, 0x2A0A
118:               	{
119:               		if(Me.Function_Mode < CoreSlaveCaldo)		// se sono in modalità autonoma
0028EA  805C24     MOV 0xB84, W4
0028EC  520FF0     SUB W4, #0x10, [W15]
0028EE  3C008D     BRA GT, 0x2A0A
120:               		{	Me.Ventil_Mode = Touch[0].FanMode;		// aggiorno lo stato del ventilatore dai touch
0028F0  805D94     MOV 0xBB2, W4
0028F2  885C54     MOV W4, 0xB8A
121:               			Me.SP = Touch[0].SetPoint;				// aggiorno il SP dai touch
0028F4  805D74     MOV Touch, W4
0028F6  885BC4     MOV W4, 0xB78
122:               			switch(Touch[0].FunctionMode)			// aggiorno lo stato di funzionamento dai touch
0028F8  805D84     MOV 0xBB0, W4
0028FA  520FE4     SUB W4, #0x4, [W15]
0028FC  320047     BRA Z, 0x298C
0028FE  520FE8     SUB W4, #0x8, [W15]
002900  320063     BRA Z, 0x29C8
002902  520FE2     SUB W4, #0x2, [W15]
002904  3A007F     BRA NZ, 0x2A04
123:               			{
124:               				case CoreAuto:		// auto
125:               					switch(Me.Old_Function_Mode)
002906  805C44     MOV 0xB88, W4
002908  520FE4     SUB W4, #0x4, [W15]
00290A  320003     BRA Z, 0x2912
00290C  520FE8     SUB W4, #0x8, [W15]
00290E  32001A     BRA Z, 0x2944
002910  370032     BRA 0x2976
126:               					{
127:               						case CoreRiscaldamento:
128:               							if(Me.Temp_Amb > (Me.SP + IsteresiCambioModalita))		// se sono oltre il limite di temp 
002912  805B65     MOV Me, W5
002914  805BC4     MOV 0xB78, W4
002916  B01904     ADD #0x190, W4
002918  528F84     SUB W5, W4, [W15]
00291A  340005     BRA LE, 0x2926
129:               							{	Me.Function_Mode = CoreRaffrescamento;				// raffreddi
00291C  200084     MOV #0x8, W4
00291E  885C24     MOV W4, 0xB84
130:               								Me.Old_Function_Mode = CoreRaffrescamento;
002920  200084     MOV #0x8, W4
002922  885C44     MOV W4, 0xB88
002924  37000E     BRA 0x2942
131:               							}
132:               							else
133:               							{	if(Me.Temp_Amb > (Me.SP + Caldo_Ist_SP))
002926  805B65     MOV Me, W5
002928  805BC4     MOV 0xB78, W4
00292A  B00C84     ADD #0xC8, W4
00292C  528F84     SUB W5, W4, [W15]
00292E  340003     BRA LE, 0x2936
134:               									Me.Function_Mode = CoreOff;
002930  EB0200     CLR W4
002932  885C24     MOV W4, 0xB84
002934  370006     BRA 0x2942
135:               								else if(Me.Temp_Amb < Me.SP)
002936  805B65     MOV Me, W5
002938  805BC4     MOV 0xB78, W4
00293A  528F84     SUB W5, W4, [W15]
00293C  3D0002     BRA GE, 0x2942
136:               									Me.Function_Mode = CoreRiscaldamento;
00293E  200044     MOV #0x4, W4
002940  885C24     MOV W4, 0xB84
137:               							}
138:               							break;
002942  370023     BRA 0x298A
139:               
140:               						case CoreRaffrescamento:
141:               							if(Me.Temp_Amb < (Me.SP - IsteresiCambioModalita))		// se sono oltre il limite di temp 
002944  805B65     MOV Me, W5
002946  805BC4     MOV 0xB78, W4
002948  B11904     SUB #0x190, W4
00294A  528F84     SUB W5, W4, [W15]
00294C  3D0005     BRA GE, 0x2958
142:               							{	Me.Function_Mode = CoreRiscaldamento;				// riscaldo
00294E  200044     MOV #0x4, W4
002950  885C24     MOV W4, 0xB84
143:               								Me.Old_Function_Mode = CoreRiscaldamento;
002952  200044     MOV #0x4, W4
002954  885C44     MOV W4, 0xB88
002956  37000E     BRA 0x2974
144:               							}
145:               							else
146:               							{	if(Me.Temp_Amb < (Me.SP - Freddo_Ist_SP))
002958  805B65     MOV Me, W5
00295A  805BC4     MOV 0xB78, W4
00295C  B10644     SUB #0x64, W4
00295E  528F84     SUB W5, W4, [W15]
002960  3D0003     BRA GE, 0x2968
147:               									Me.Function_Mode = CoreOff;
002962  EB0200     CLR W4
002964  885C24     MOV W4, 0xB84
002966  370006     BRA 0x2974
148:               								else if(Me.Temp_Amb > Me.SP)
002968  805B65     MOV Me, W5
00296A  805BC4     MOV 0xB78, W4
00296C  528F84     SUB W5, W4, [W15]
00296E  340002     BRA LE, 0x2974
149:               									Me.Function_Mode = CoreRaffrescamento;
002970  200084     MOV #0x8, W4
002972  885C24     MOV W4, 0xB84
150:               							}
151:               							break;
002974  37000A     BRA 0x298A
152:               
153:               						default:
154:               							if(Me.Temp_Amb < Me.SP)		// se fa freddo rispetto alla temp richiesta
002976  805B65     MOV Me, W5
002978  805BC4     MOV 0xB78, W4
00297A  528F84     SUB W5, W4, [W15]
00297C  3D0003     BRA GE, 0x2984
155:               								Me.Old_Function_Mode = CoreRiscaldamento;	// CoreRiscaldamento
00297E  200044     MOV #0x4, W4
002980  885C44     MOV W4, 0xB88
002982  370002     BRA 0x2988
156:               							else						// altrimenti raffreddo
157:               								Me.Old_Function_Mode = CoreRaffrescamento;	// CoreRaffrescamento
002984  200084     MOV #0x8, W4
002986  885C44     MOV W4, 0xB88
158:               							break;
002988  000000     NOP
159:               					}
160:               					break;
00298A  37003F     BRA 0x2A0A
161:               
162:               				case CoreRiscaldamento:
163:               					if((Me.Temp_Amb > (Me.SP + Caldo_Ist_SP)) & (Me.Old_Function_Mode == CoreRiscaldamento))
00298C  805B66     MOV Me, W6
00298E  805BC4     MOV 0xB78, W4
002990  200C85     MOV #0xC8, W5
002992  428284     ADD W5, W4, W5
002994  B3C014     MOV.B #0x1, W4
002996  530F85     SUB W6, W5, [W15]
002998  3C0001     BRA GT, 0x299C
00299A  EB4200     CLR.B W4
00299C  805C45     MOV 0xB88, W5
00299E  A22005     BTG W5, #2
0029A0  A7F005     BTSC W5, #15
0029A2  EA0285     NEG W5, W5
0029A4  E90285     DEC W5, W5
0029A6  DE2ACF     LSR W5, #15, W5
0029A8  784285     MOV.B W5, W5
0029AA  624205     AND.B W4, W5, W4
0029AC  524FE0     SUB.B W4, #0x0, [W15]
0029AE  320003     BRA Z, 0x29B6
164:               						Me.Function_Mode = CoreOff;
0029B0  EB0200     CLR W4
0029B2  885C24     MOV W4, 0xB84
0029B4  370006     BRA 0x29C2
165:               					else if(Me.Temp_Amb < Me.SP)
0029B6  805B65     MOV Me, W5
0029B8  805BC4     MOV 0xB78, W4
0029BA  528F84     SUB W5, W4, [W15]
0029BC  3D0002     BRA GE, 0x29C2
166:               						Me.Function_Mode = CoreRiscaldamento;
0029BE  200044     MOV #0x4, W4
0029C0  885C24     MOV W4, 0xB84
167:               					Me.Old_Function_Mode = CoreRiscaldamento;
0029C2  200044     MOV #0x4, W4
0029C4  885C44     MOV W4, 0xB88
168:               					break;
0029C6  370021     BRA 0x2A0A
169:               
170:               				case CoreRaffrescamento:
171:               					if((Me.Temp_Amb < (Me.SP - Freddo_Ist_SP)) & (Me.Old_Function_Mode == CoreRaffrescamento))
0029C8  805B66     MOV Me, W6
0029CA  805BC4     MOV 0xB78, W4
0029CC  2FF9C5     MOV #0xFF9C, W5
0029CE  428284     ADD W5, W4, W5
0029D0  B3C014     MOV.B #0x1, W4
0029D2  530F85     SUB W6, W5, [W15]
0029D4  350001     BRA LT, 0x29D8
0029D6  EB4200     CLR.B W4
0029D8  805C45     MOV 0xB88, W5
0029DA  A23005     BTG W5, #3
0029DC  A7F005     BTSC W5, #15
0029DE  EA0285     NEG W5, W5
0029E0  E90285     DEC W5, W5
0029E2  DE2ACF     LSR W5, #15, W5
0029E4  784285     MOV.B W5, W5
0029E6  624205     AND.B W4, W5, W4
0029E8  524FE0     SUB.B W4, #0x0, [W15]
0029EA  320003     BRA Z, 0x29F2
172:               						Me.Function_Mode = CoreOff;
0029EC  EB0200     CLR W4
0029EE  885C24     MOV W4, 0xB84
0029F0  370006     BRA 0x29FE
173:               					else if(Me.Temp_Amb > Me.SP)
0029F2  805B65     MOV Me, W5
0029F4  805BC4     MOV 0xB78, W4
0029F6  528F84     SUB W5, W4, [W15]
0029F8  340002     BRA LE, 0x29FE
174:               						Me.Function_Mode = CoreRaffrescamento;
0029FA  200084     MOV #0x8, W4
0029FC  885C24     MOV W4, 0xB84
175:               					Me.Old_Function_Mode = CoreRaffrescamento;
0029FE  200084     MOV #0x8, W4
002A00  885C44     MOV W4, 0xB88
176:               					break;
002A02  370003     BRA 0x2A0A
177:               
178:               				default:
179:               					Me.Function_Mode = Touch[0].FunctionMode;
002A04  805D84     MOV 0xBB0, W4
002A06  885C24     MOV W4, 0xB84
180:               					break;
002A08  000000     NOP
181:               			}
182:               
183:               		}
184:               	}
185:               	// estraggo gli errori del box motore
186:               	EngineBox.Error.CompressorHi =			((EngineBox.Errori1 & 0x0001) != 0);
002A0A  805AF4     MOV 0xB5E, W4
002A0C  784204     MOV.B W4, W4
002A0E  624261     AND.B W4, #0x1, W4
002A10  624261     AND.B W4, #0x1, W4
002A12  624261     AND.B W4, #0x1, W4
002A14  FB8204     ZE W4, W4
002A16  620261     AND W4, #0x1, W4
002A18  805A86     MOV 0xB50, W6
002A1A  2FFFE5     MOV #0xFFFE, W5
002A1C  630285     AND W6, W5, W5
002A1E  720205     IOR W4, W5, W4
002A20  885A84     MOV W4, 0xB50
187:               	EngineBox.Error.CompressorLo = 		((EngineBox.Errori1 & 0x0002) != 0);
002A22  805AF4     MOV 0xB5E, W4
002A24  620262     AND W4, #0x2, W4
002A26  A7F004     BTSC W4, #15
002A28  EA0204     NEG W4, W4
002A2A  EA0204     NEG W4, W4
002A2C  DE224F     LSR W4, #15, W4
002A2E  784204     MOV.B W4, W4
002A30  FB8204     ZE W4, W4
002A32  620261     AND W4, #0x1, W4
002A34  420204     ADD W4, W4, W4
002A36  805A86     MOV 0xB50, W6
002A38  2FFFD5     MOV #0xFFFD, W5
002A3A  630285     AND W6, W5, W5
002A3C  720205     IOR W4, W5, W4
002A3E  885A84     MOV W4, 0xB50
188:               	EngineBox.Error.CondensatoreHi = 		((EngineBox.Errori1 & 0x0004) != 0);
002A40  805AF4     MOV 0xB5E, W4
002A42  620264     AND W4, #0x4, W4
002A44  A7F004     BTSC W4, #15
002A46  EA0204     NEG W4, W4
002A48  EA0204     NEG W4, W4
002A4A  DE224F     LSR W4, #15, W4
002A4C  784204     MOV.B W4, W4
002A4E  FB8204     ZE W4, W4
002A50  620261     AND W4, #0x1, W4
002A52  DD2242     SL W4, #2, W4
002A54  805A86     MOV 0xB50, W6
002A56  2FFFB5     MOV #0xFFFB, W5
002A58  630285     AND W6, W5, W5
002A5A  720205     IOR W4, W5, W4
002A5C  885A84     MOV W4, 0xB50
189:               	EngineBox.Error.CondensatoreLo = 		((EngineBox.Errori1 & 0x0008) != 0);
002A5E  805AF4     MOV 0xB5E, W4
002A60  620268     AND W4, #0x8, W4
002A62  A7F004     BTSC W4, #15
002A64  EA0204     NEG W4, W4
002A66  EA0204     NEG W4, W4
002A68  DE224F     LSR W4, #15, W4
002A6A  784204     MOV.B W4, W4
002A6C  FB8204     ZE W4, W4
002A6E  620261     AND W4, #0x1, W4
002A70  DD2243     SL W4, #3, W4
002A72  805A86     MOV 0xB50, W6
002A74  2FFF75     MOV #0xFFF7, W5
002A76  630285     AND W6, W5, W5
002A78  720205     IOR W4, W5, W4
002A7A  885A84     MOV W4, 0xB50
190:               	EngineBox.Error.Gas_Recovery = 		((EngineBox.Errori1 & 0x0010) != 0);
002A7C  805AF4     MOV 0xB5E, W4
002A7E  620270     AND W4, #0x10, W4
002A80  A7F004     BTSC W4, #15
002A82  EA0204     NEG W4, W4
002A84  EA0204     NEG W4, W4
002A86  DE224F     LSR W4, #15, W4
002A88  784204     MOV.B W4, W4
002A8A  FB8204     ZE W4, W4
002A8C  620261     AND W4, #0x1, W4
002A8E  DD2244     SL W4, #4, W4
002A90  805A86     MOV 0xB50, W6
002A92  2FFEF5     MOV #0xFFEF, W5
002A94  630285     AND W6, W5, W5
002A96  720205     IOR W4, W5, W4
002A98  885A84     MOV W4, 0xB50
191:               	EngineBox.Test.FluxReq = 				((EngineBox.Errori1 & 0x0020) != 0);
002A9A  805AF5     MOV 0xB5E, W5
002A9C  200204     MOV #0x20, W4
002A9E  628204     AND W5, W4, W4
002AA0  A7F004     BTSC W4, #15
002AA2  EA0204     NEG W4, W4
002AA4  EA0204     NEG W4, W4
002AA6  DE224F     LSR W4, #15, W4
002AA8  784204     MOV.B W4, W4
002AAA  FB8204     ZE W4, W4
002AAC  620261     AND W4, #0x1, W4
002AAE  805AA6     MOV 0xB54, W6
002AB0  2FFFE5     MOV #0xFFFE, W5
002AB2  630285     AND W6, W5, W5
002AB4  720205     IOR W4, W5, W4
002AB6  885AA4     MOV W4, 0xB54
192:               	EngineBox.Test.EEV_Req = 				((EngineBox.Errori1 & 0x0040) != 0);
002AB8  805AF5     MOV 0xB5E, W5
002ABA  200404     MOV #0x40, W4
002ABC  628204     AND W5, W4, W4
002ABE  A7F004     BTSC W4, #15
002AC0  EA0204     NEG W4, W4
002AC2  EA0204     NEG W4, W4
002AC4  DE224F     LSR W4, #15, W4
002AC6  784204     MOV.B W4, W4
002AC8  FB8204     ZE W4, W4
002ACA  620261     AND W4, #0x1, W4
002ACC  420204     ADD W4, W4, W4
002ACE  805AA6     MOV 0xB54, W6
002AD0  2FFFD5     MOV #0xFFFD, W5
002AD2  630285     AND W6, W5, W5
002AD4  720205     IOR W4, W5, W4
002AD6  885AA4     MOV W4, 0xB54
193:               	EngineBox.Test.EEV_Go = 				((EngineBox.Errori1 & 0x0080) != 0);
002AD8  805AF5     MOV 0xB5E, W5
002ADA  200804     MOV #0x80, W4
002ADC  628204     AND W5, W4, W4
002ADE  A7F004     BTSC W4, #15
002AE0  EA0204     NEG W4, W4
002AE2  EA0204     NEG W4, W4
002AE4  DE224F     LSR W4, #15, W4
002AE6  784204     MOV.B W4, W4
002AE8  FB8204     ZE W4, W4
002AEA  620261     AND W4, #0x1, W4
002AEC  DD2242     SL W4, #2, W4
002AEE  805AA6     MOV 0xB54, W6
002AF0  2FFFB5     MOV #0xFFFB, W5
002AF2  630285     AND W6, W5, W5
002AF4  720205     IOR W4, W5, W4
002AF6  885AA4     MOV W4, 0xB54
194:               	EngineBox.Error.Pressure_Lo = 			((EngineBox.Errori1 & 0x0100) != 0);
002AF8  805AF5     MOV 0xB5E, W5
002AFA  201004     MOV #0x100, W4
002AFC  628204     AND W5, W4, W4
002AFE  A7F004     BTSC W4, #15
002B00  EA0204     NEG W4, W4
002B02  EA0204     NEG W4, W4
002B04  DE224F     LSR W4, #15, W4
002B06  784204     MOV.B W4, W4
002B08  FB8204     ZE W4, W4
002B0A  620261     AND W4, #0x1, W4
002B0C  DD2245     SL W4, #5, W4
002B0E  805A86     MOV 0xB50, W6
002B10  2FFDF5     MOV #0xFFDF, W5
002B12  630285     AND W6, W5, W5
002B14  720205     IOR W4, W5, W4
002B16  885A84     MOV W4, 0xB50
195:               	EngineBox.Error.Pressure_Hi = 			((EngineBox.Errori1 & 0x0200) != 0);
002B18  805AF5     MOV 0xB5E, W5
002B1A  202004     MOV #0x200, W4
002B1C  628204     AND W5, W4, W4
002B1E  A7F004     BTSC W4, #15
002B20  EA0204     NEG W4, W4
002B22  EA0204     NEG W4, W4
002B24  DE224F     LSR W4, #15, W4
002B26  784204     MOV.B W4, W4
002B28  FB8204     ZE W4, W4
002B2A  620261     AND W4, #0x1, W4
002B2C  DD2246     SL W4, #6, W4
002B2E  805A86     MOV 0xB50, W6
002B30  2FFBF5     MOV #0xFFBF, W5
002B32  630285     AND W6, W5, W5
002B34  720205     IOR W4, W5, W4
002B36  885A84     MOV W4, 0xB50
196:               	EngineBox.Error.Recharge_Oil = 		((EngineBox.Errori1 & 0x0400) != 0);
002B38  805AF5     MOV 0xB5E, W5
002B3A  204004     MOV #0x400, W4
002B3C  628204     AND W5, W4, W4
002B3E  A7F004     BTSC W4, #15
002B40  EA0204     NEG W4, W4
002B42  EA0204     NEG W4, W4
002B44  DE224F     LSR W4, #15, W4
002B46  784204     MOV.B W4, W4
002B48  FB8204     ZE W4, W4
002B4A  620261     AND W4, #0x1, W4
002B4C  DD2247     SL W4, #7, W4
002B4E  805A86     MOV 0xB50, W6
002B50  2FF7F5     MOV #0xFF7F, W5
002B52  630285     AND W6, W5, W5
002B54  720205     IOR W4, W5, W4
002B56  885A84     MOV W4, 0xB50
197:               
198:               
199:               	EngineBox.PersErr.CompressorHi =		((EngineBox.Errori2 & 0x0001) != 0);
002B58  805B04     MOV 0xB60, W4
002B5A  784204     MOV.B W4, W4
002B5C  624261     AND.B W4, #0x1, W4
002B5E  624261     AND.B W4, #0x1, W4
002B60  624261     AND.B W4, #0x1, W4
002B62  FB8204     ZE W4, W4
002B64  620261     AND W4, #0x1, W4
002B66  805A96     MOV 0xB52, W6
002B68  2FFFE5     MOV #0xFFFE, W5
002B6A  630285     AND W6, W5, W5
002B6C  720205     IOR W4, W5, W4
002B6E  885A94     MOV W4, 0xB52
200:               	EngineBox.PersErr.CompressorLo =		((EngineBox.Errori2 & 0x0002) != 0);
002B70  805B04     MOV 0xB60, W4
002B72  620262     AND W4, #0x2, W4
002B74  A7F004     BTSC W4, #15
002B76  EA0204     NEG W4, W4
002B78  EA0204     NEG W4, W4
002B7A  DE224F     LSR W4, #15, W4
002B7C  784204     MOV.B W4, W4
002B7E  FB8204     ZE W4, W4
002B80  620261     AND W4, #0x1, W4
002B82  420204     ADD W4, W4, W4
002B84  805A96     MOV 0xB52, W6
002B86  2FFFD5     MOV #0xFFFD, W5
002B88  630285     AND W6, W5, W5
002B8A  720205     IOR W4, W5, W4
002B8C  885A94     MOV W4, 0xB52
201:               	EngineBox.PersErr.CondensatoreHi =		((EngineBox.Errori2 & 0x0004) != 0);
002B8E  805B04     MOV 0xB60, W4
002B90  620264     AND W4, #0x4, W4
002B92  A7F004     BTSC W4, #15
002B94  EA0204     NEG W4, W4
002B96  EA0204     NEG W4, W4
002B98  DE224F     LSR W4, #15, W4
002B9A  784204     MOV.B W4, W4
002B9C  FB8204     ZE W4, W4
002B9E  620261     AND W4, #0x1, W4
002BA0  DD2242     SL W4, #2, W4
002BA2  805A96     MOV 0xB52, W6
002BA4  2FFFB5     MOV #0xFFFB, W5
002BA6  630285     AND W6, W5, W5
002BA8  720205     IOR W4, W5, W4
002BAA  885A94     MOV W4, 0xB52
202:               	EngineBox.PersErr.CondensatoreLo =		((EngineBox.Errori2 & 0x0008) != 0);
002BAC  805B04     MOV 0xB60, W4
002BAE  620268     AND W4, #0x8, W4
002BB0  A7F004     BTSC W4, #15
002BB2  EA0204     NEG W4, W4
002BB4  EA0204     NEG W4, W4
002BB6  DE224F     LSR W4, #15, W4
002BB8  784204     MOV.B W4, W4
002BBA  FB8204     ZE W4, W4
002BBC  620261     AND W4, #0x1, W4
002BBE  DD2243     SL W4, #3, W4
002BC0  805A96     MOV 0xB52, W6
002BC2  2FFF75     MOV #0xFFF7, W5
002BC4  630285     AND W6, W5, W5
002BC6  720205     IOR W4, W5, W4
002BC8  885A94     MOV W4, 0xB52
203:               	EngineBox.PersErr.Gas_Recovery =		((EngineBox.Errori2 & 0x0010) != 0);
002BCA  805B04     MOV 0xB60, W4
002BCC  620270     AND W4, #0x10, W4
002BCE  A7F004     BTSC W4, #15
002BD0  EA0204     NEG W4, W4
002BD2  EA0204     NEG W4, W4
002BD4  DE224F     LSR W4, #15, W4
002BD6  784204     MOV.B W4, W4
002BD8  FB8204     ZE W4, W4
002BDA  620261     AND W4, #0x1, W4
002BDC  DD2244     SL W4, #4, W4
002BDE  805A96     MOV 0xB52, W6
002BE0  2FFEF5     MOV #0xFFEF, W5
002BE2  630285     AND W6, W5, W5
002BE4  720205     IOR W4, W5, W4
002BE6  885A94     MOV W4, 0xB52
204:               	EngineBox.PersErr.Allagamento =		((EngineBox.Errori2 & 0x0020) != 0);
002BE8  805B05     MOV 0xB60, W5
002BEA  200204     MOV #0x20, W4
002BEC  628204     AND W5, W4, W4
002BEE  A7F004     BTSC W4, #15
002BF0  EA0204     NEG W4, W4
002BF2  EA0204     NEG W4, W4
002BF4  DE224F     LSR W4, #15, W4
002BF6  784204     MOV.B W4, W4
002BF8  FB8204     ZE W4, W4
002BFA  620261     AND W4, #0x1, W4
002BFC  DD2245     SL W4, #5, W4
002BFE  805A96     MOV 0xB52, W6
002C00  2FFDF5     MOV #0xFFDF, W5
002C02  630285     AND W6, W5, W5
002C04  720205     IOR W4, W5, W4
002C06  885A94     MOV W4, 0xB52
205:               	EngineBox.PersErr.TermicaCompressore =	((EngineBox.Errori2 & 0x0040) != 0);
002C08  805B05     MOV 0xB60, W5
002C0A  200404     MOV #0x40, W4
002C0C  628204     AND W5, W4, W4
002C0E  A7F004     BTSC W4, #15
002C10  EA0204     NEG W4, W4
002C12  EA0204     NEG W4, W4
002C14  DE224F     LSR W4, #15, W4
002C16  784204     MOV.B W4, W4
002C18  FB8204     ZE W4, W4
002C1A  620261     AND W4, #0x1, W4
002C1C  DD2246     SL W4, #6, W4
002C1E  805A96     MOV 0xB52, W6
002C20  2FFBF5     MOV #0xFFBF, W5
002C22  630285     AND W6, W5, W5
002C24  720205     IOR W4, W5, W4
002C26  885A94     MOV W4, 0xB52
206:               	EngineBox.PersErr.SeaWaterLo =			((EngineBox.Errori2 & 0x0080) != 0);
002C28  805B05     MOV 0xB60, W5
002C2A  200804     MOV #0x80, W4
002C2C  628204     AND W5, W4, W4
002C2E  A7F004     BTSC W4, #15
002C30  EA0204     NEG W4, W4
002C32  EA0204     NEG W4, W4
002C34  DE224F     LSR W4, #15, W4
002C36  784204     MOV.B W4, W4
002C38  FB8204     ZE W4, W4
002C3A  620261     AND W4, #0x1, W4
002C3C  DD2247     SL W4, #7, W4
002C3E  805A96     MOV 0xB52, W6
002C40  2FF7F5     MOV #0xFF7F, W5
002C42  630285     AND W6, W5, W5
002C44  720205     IOR W4, W5, W4
002C46  885A94     MOV W4, 0xB52
207:               	EngineBox.PersErr.SeaWaterHi =			((EngineBox.Errori2 & 0x0100) != 0);
002C48  805B05     MOV 0xB60, W5
002C4A  201004     MOV #0x100, W4
002C4C  628204     AND W5, W4, W4
002C4E  A7F004     BTSC W4, #15
002C50  EA0204     NEG W4, W4
002C52  EA0204     NEG W4, W4
002C54  DE224F     LSR W4, #15, W4
002C56  784204     MOV.B W4, W4
002C58  FB8204     ZE W4, W4
002C5A  620261     AND W4, #0x1, W4
002C5C  DD2248     SL W4, #8, W4
002C5E  805A96     MOV 0xB52, W6
002C60  2FEFF5     MOV #0xFEFF, W5
002C62  630285     AND W6, W5, W5
002C64  720205     IOR W4, W5, W4
002C66  885A94     MOV W4, 0xB52
208:               	EngineBox.PersErr.CaricaRefrig =		((EngineBox.Errori2 & 0x0200) != 0);
002C68  805B05     MOV 0xB60, W5
002C6A  202004     MOV #0x200, W4
002C6C  628204     AND W5, W4, W4
002C6E  A7F004     BTSC W4, #15
002C70  EA0204     NEG W4, W4
002C72  EA0204     NEG W4, W4
002C74  DE224F     LSR W4, #15, W4
002C76  784204     MOV.B W4, W4
002C78  FB8204     ZE W4, W4
002C7A  620261     AND W4, #0x1, W4
002C7C  DD2249     SL W4, #9, W4
002C7E  805A96     MOV 0xB52, W6
002C80  2FDFF5     MOV #0xFDFF, W5
002C82  630285     AND W6, W5, W5
002C84  720205     IOR W4, W5, W4
002C86  885A94     MOV W4, 0xB52
209:               	EngineBox.PersErr.WaterSeaFlux =		((EngineBox.Errori2 & 0x0400) != 0);
002C88  805B05     MOV 0xB60, W5
002C8A  204004     MOV #0x400, W4
002C8C  628204     AND W5, W4, W4
002C8E  A7F004     BTSC W4, #15
002C90  EA0204     NEG W4, W4
002C92  EA0204     NEG W4, W4
002C94  DE224F     LSR W4, #15, W4
002C96  784204     MOV.B W4, W4
002C98  FB8204     ZE W4, W4
002C9A  620261     AND W4, #0x1, W4
002C9C  DD224A     SL W4, #10, W4
002C9E  805A96     MOV 0xB52, W6
002CA0  2FBFF5     MOV #0xFBFF, W5
002CA2  630285     AND W6, W5, W5
002CA4  720205     IOR W4, W5, W4
002CA6  885A94     MOV W4, 0xB52
210:               	EngineBox.PersErr.EEV_Open =			((EngineBox.Errori2 & 0x0800) != 0);
002CA8  805B05     MOV 0xB60, W5
002CAA  208004     MOV #0x800, W4
002CAC  628204     AND W5, W4, W4
002CAE  A7F004     BTSC W4, #15
002CB0  EA0204     NEG W4, W4
002CB2  EA0204     NEG W4, W4
002CB4  DE224F     LSR W4, #15, W4
002CB6  784204     MOV.B W4, W4
002CB8  FB8204     ZE W4, W4
002CBA  620261     AND W4, #0x1, W4
002CBC  DD224B     SL W4, #11, W4
002CBE  805A96     MOV 0xB52, W6
002CC0  2F7FF5     MOV #0xF7FF, W5
002CC2  630285     AND W6, W5, W5
002CC4  720205     IOR W4, W5, W4
002CC6  885A94     MOV W4, 0xB52
211:               	EngineBox.PersErr.EEV_Close =			((EngineBox.Errori2 & 0x1000) != 0);
002CC8  805B05     MOV 0xB60, W5
002CCA  210004     MOV #0x1000, W4
002CCC  628204     AND W5, W4, W4
002CCE  A7F004     BTSC W4, #15
002CD0  EA0204     NEG W4, W4
002CD2  EA0204     NEG W4, W4
002CD4  DE224F     LSR W4, #15, W4
002CD6  784204     MOV.B W4, W4
002CD8  FB8204     ZE W4, W4
002CDA  620261     AND W4, #0x1, W4
002CDC  DD224C     SL W4, #12, W4
002CDE  805A96     MOV 0xB52, W6
002CE0  2EFFF5     MOV #0xEFFF, W5
002CE2  630285     AND W6, W5, W5
002CE4  720205     IOR W4, W5, W4
002CE6  885A94     MOV W4, 0xB52
212:               	EngineBox.PersErr.BatteriaGhiacciata =	((EngineBox.Errori2 & 0x2000) != 0);
002CE8  805B05     MOV 0xB60, W5
002CEA  220004     MOV #0x2000, W4
002CEC  628204     AND W5, W4, W4
002CEE  A7F004     BTSC W4, #15
002CF0  EA0204     NEG W4, W4
002CF2  EA0204     NEG W4, W4
002CF4  DE224F     LSR W4, #15, W4
002CF6  784204     MOV.B W4, W4
002CF8  FB8204     ZE W4, W4
002CFA  620261     AND W4, #0x1, W4
002CFC  DD224D     SL W4, #13, W4
002CFE  805A96     MOV 0xB52, W6
002D00  2DFFF5     MOV #0xDFFF, W5
002D02  630285     AND W6, W5, W5
002D04  720205     IOR W4, W5, W4
002D06  885A94     MOV W4, 0xB52
213:               	EngineBox.PersErr.Fan_Speed =			((EngineBox.Errori2 & 0x4000) != 0);
002D08  805B05     MOV 0xB60, W5
002D0A  240004     MOV #0x4000, W4
002D0C  628204     AND W5, W4, W4
002D0E  A7F004     BTSC W4, #15
002D10  EA0204     NEG W4, W4
002D12  EA0204     NEG W4, W4
002D14  DE224F     LSR W4, #15, W4
002D16  784204     MOV.B W4, W4
002D18  FB8204     ZE W4, W4
002D1A  620261     AND W4, #0x1, W4
002D1C  DD224E     SL W4, #14, W4
002D1E  805A96     MOV 0xB52, W6
002D20  2BFFF5     MOV #0xBFFF, W5
002D22  630285     AND W6, W5, W5
002D24  720205     IOR W4, W5, W4
002D26  885A94     MOV W4, 0xB52
214:               	EngineBox.PersErr.Fan_OverLoad =		((EngineBox.Errori2 & 0x8000) != 0);
002D28  805B04     MOV 0xB60, W4
002D2A  DE224F     LSR W4, #15, W4
002D2C  784204     MOV.B W4, W4
002D2E  FB8204     ZE W4, W4
002D30  DD224F     SL W4, #15, W4
002D32  805A96     MOV 0xB52, W6
002D34  27FFF5     MOV #0x7FFF, W5
002D36  630285     AND W6, W5, W5
002D38  720205     IOR W4, W5, W4
002D3A  885A94     MOV W4, 0xB52
215:               
216:               	// gestione errori
217:               	if(Me.Error.EEV_Close| Me.Error.Fan_OverLoad | Me.Error.Fan_Fault)
002D3C  805D64     MOV 0xBAC, W4
002D3E  DE2243     LSR W4, #3, W4
002D40  624261     AND.B W4, #0x1, W4
002D42  FB8284     ZE W4, W5
002D44  805D64     MOV 0xBAC, W4
002D46  DE2246     LSR W4, #6, W4
002D48  624261     AND.B W4, #0x1, W4
002D4A  FB8204     ZE W4, W4
002D4C  720285     IOR W4, W5, W5
002D4E  805D64     MOV 0xBAC, W4
002D50  DE2245     LSR W4, #5, W4
002D52  624261     AND.B W4, #0x1, W4
002D54  FB8204     ZE W4, W4
002D56  720205     IOR W4, W5, W4
002D58  520FE0     SUB W4, #0x0, [W15]
002D5A  320002     BRA Z, 0x2D60
218:               		Me.Function_Mode = CoreOff;
002D5C  EB0200     CLR W4
002D5E  885C24     MOV W4, 0xB84
219:               
220:               	if(Me.Error.BatteriaGhiacciata)
002D60  805D64     MOV 0xBAC, W4
002D62  620270     AND W4, #0x10, W4
002D64  520FE0     SUB W4, #0x0, [W15]
002D66  320006     BRA Z, 0x2D74
221:               	{	if(Me.Temp_Big > SogliVentNightBatteriaGhiacciata)
002D68  805B85     MOV 0xB70, W5
002D6A  2FF394     MOV #0xFF39, W4
002D6C  528F84     SUB W5, W4, [W15]
002D6E  350013     BRA LT, 0x2D96
222:               			Me.Error.BatteriaGhiacciata = 0;
002D70  A98BAC     BCLR 0xBAC, #4
002D72  370011     BRA 0x2D96
223:               	}
224:               	else
225:               	{	if((Me.Temp_Big < SogliTempBatteriaGhiacciata) & (Me.Fan_Tacho == 0))
002D74  805B86     MOV 0xB70, W6
002D76  B3C014     MOV.B #0x1, W4
002D78  2FE0C5     MOV #0xFE0C, W5
002D7A  530F85     SUB W6, W5, [W15]
002D7C  350001     BRA LT, 0x2D80
002D7E  EB4200     CLR.B W4
002D80  805C95     MOV 0xB92, W5
002D82  A7F005     BTSC W5, #15
002D84  EA0285     NEG W5, W5
002D86  E90285     DEC W5, W5
002D88  DE2ACF     LSR W5, #15, W5
002D8A  784285     MOV.B W5, W5
002D8C  624205     AND.B W4, W5, W4
002D8E  524FE0     SUB.B W4, #0x0, [W15]
002D90  320002     BRA Z, 0x2D96
226:               		{	Me.Error.BatteriaGhiacciata = 1;
002D92  A88BAC     BSET 0xBAC, #4
227:               			Me.Error.EEV_Open = 1;
002D94  A84BAC     BSET 0xBAC, #2
228:               		}
229:               	}
230:               
231:               	if(EngineBox.FunctionMode == EngineBox_CriticalFault)
002D96  805A54     MOV 0xB4A, W4
002D98  520FE6     SUB W4, #0x6, [W15]
002D9A  3A0002     BRA NZ, 0x2DA0
232:               		Me.Function_Mode = CoreOff;
002D9C  EB0200     CLR W4
002D9E  885C24     MOV W4, 0xB84
233:               
234:               	// compongo lo stato dello split
235:               	Me.SplitStatus =	(Me.Error.ClearErrReq			<< 0) | 
002DA0  805D64     MOV 0xBAC, W4
002DA2  784204     MOV.B W4, W4
002DA4  624261     AND.B W4, #0x1, W4
002DA6  FB8284     ZE W4, W5
002DB2  720285     IOR W4, W5, W5
002E08  885CF4     MOV W4, 0xB9E
236:               						(Me.Error.EEV_Open				<< 1) | 
002DA8  805D64     MOV 0xBAC, W4
002DAA  DE2242     LSR W4, #2, W4
002DAC  624261     AND.B W4, #0x1, W4
002DAE  FB8204     ZE W4, W4
002DB0  420204     ADD W4, W4, W4
002DBE  720285     IOR W4, W5, W5
237:               						(Me.Error.EEV_Close				<< 2) | 
002DB4  805D64     MOV 0xBAC, W4
002DB6  DE2243     LSR W4, #3, W4
002DB8  624261     AND.B W4, #0x1, W4
002DBA  FB8204     ZE W4, W4
002DBC  DD2242     SL W4, #2, W4
002DCA  720285     IOR W4, W5, W5
238:               						(Me.Error.BatteriaGhiacciata	<< 3) | 
002DC0  805D64     MOV 0xBAC, W4
002DC2  DE2244     LSR W4, #4, W4
002DC4  624261     AND.B W4, #0x1, W4
002DC6  FB8204     ZE W4, W4
002DC8  DD2243     SL W4, #3, W4
002DD6  720285     IOR W4, W5, W5
239:               						(Me.Error.Fan_Fault				<< 4) | 
002DCC  805D64     MOV 0xBAC, W4
002DCE  DE2245     LSR W4, #5, W4
002DD0  624261     AND.B W4, #0x1, W4
002DD2  FB8204     ZE W4, W4
002DD4  DD2244     SL W4, #4, W4
002DE2  720285     IOR W4, W5, W5
240:               						(Me.Error.Fan_OverLoad			<< 5) |
002DD8  805D64     MOV 0xBAC, W4
002DDA  DE2246     LSR W4, #6, W4
002DDC  624261     AND.B W4, #0x1, W4
002DDE  FB8204     ZE W4, W4
002DE0  DD2245     SL W4, #5, W4
002DEE  720285     IOR W4, W5, W5
241:               						(Me.Error.EEV_Test_End			<< 6) |
002DE4  805D64     MOV 0xBAC, W4
002DE6  DE2247     LSR W4, #7, W4
002DE8  624261     AND.B W4, #0x1, W4
002DEA  FB8204     ZE W4, W4
002DEC  DD2246     SL W4, #6, W4
002DFA  720285     IOR W4, W5, W5
242:               						(Me.Error.Battery_Defrost		<< 7) | 
002DF0  805D64     MOV 0xBAC, W4
002DF2  D10204     LSR W4, W4
002DF4  624261     AND.B W4, #0x1, W4
002DF6  FB8204     ZE W4, W4
002DF8  DD2247     SL W4, #7, W4
002E06  720205     IOR W4, W5, W4
243:               						(Me.Error.ClearDiagnosticSplitErrReq		<< 8);
002DFC  805D64     MOV 0xBAC, W4
002DFE  DE2249     LSR W4, #9, W4
002E00  624261     AND.B W4, #0x1, W4
002E02  FB8204     ZE W4, W4
002E04  DD2248     SL W4, #8, W4
244:               	
245:               	
246:               	if(Me.Error.ClearDiagnosticSplitErrReq && (DiagnosticSplit.Reset_Req_Address == Me.My_Address ))
002E0A  805D65     MOV 0xBAC, W5
002E0C  202004     MOV #0x200, W4
002E0E  628204     AND W5, W4, W4
002E10  520FE0     SUB W4, #0x0, [W15]
002E12  32000D     BRA Z, 0x2E2E
002E14  807215     MOV 0xE42, W5
002E16  20BA44     MOV #0xBA4, W4
002E18  784214     MOV.B [W4], W4
002E1A  FB8204     ZE W4, W4
002E1C  528F84     SUB W5, W4, [W15]
002E1E  3A0007     BRA NZ, 0x2E2E
247:               	{
248:               		Me.Error.Battery_Defrost = 0;
002E20  A92BAC     BCLR 0xBAC, #1
249:               		Me.Error.EEV_Open = 0;
002E22  A94BAC     BCLR 0xBAC, #2
250:               		Me.Error.EEV_Close = 0;
002E24  A96BAC     BCLR 0xBAC, #3
251:               		Me.Error.BatteriaGhiacciata = 0;
002E26  A98BAC     BCLR 0xBAC, #4
252:               		Me.Error.Fan_Fault = 0;
002E28  A9ABAC     BCLR 0xBAC, #5
253:               		Me.Error.Fan_OverLoad = 0;
002E2A  A9CBAC     BCLR 0xBAC, #6
254:               		Me.Error.EEV_Test_End = 0;		
002E2C  A9EBAC     BCLR 0xBAC, #7
255:               	}
256:               	
257:               	
258:               	
259:               }
002E2E  FA8000     ULNK
002E30  060000     RETURN
260:               
261:               /*  *****************************************************************************************************************************
262:               	Recupero la pressione del gas idonea alla modalità corrente
263:               	***************************************************************************************************************************** */
264:               unsigned int PressureGas(int ReqTemp)
265:               {
002E32  FA0002     LNK #0x2
002E34  780F00     MOV W0, [W14]
266:               	if (ReqTemp < -1500)
002E36  2FA244     MOV #0xFA24, W4
002E38  78029E     MOV [W14], W5
002E3A  528F84     SUB W5, W4, [W15]
002E3C  3D0002     BRA GE, 0x2E42
267:               		return 4000;			// sotto i -15, setto 4 Bar
002E3E  20FA04     MOV #0xFA0, W4
002E40  370060     BRA 0x2F02
268:               	else if (ReqTemp <= -1000)	
002E42  2FC194     MOV #0xFC19, W4
002E44  78029E     MOV [W14], W5
002E46  528F84     SUB W5, W4, [W15]
002E48  3D0002     BRA GE, 0x2E4E
269:               		return 4900;			// sotto i -10, setto 6
002E4A  213244     MOV #0x1324, W4
002E4C  37005A     BRA 0x2F02
270:               	else if (ReqTemp <= -500)	
002E4E  2FE0D4     MOV #0xFE0D, W4
002E50  78029E     MOV [W14], W5
002E52  528F84     SUB W5, W4, [W15]
002E54  3D0002     BRA GE, 0x2E5A
271:               		return 6000;			// sotto i -5, setto 6,5
002E56  217704     MOV #0x1770, W4
002E58  370054     BRA 0x2F02
272:               	else if (ReqTemp <= 0)
002E5A  78021E     MOV [W14], W4
002E5C  520FE0     SUB W4, #0x0, [W15]
002E5E  3C0002     BRA GT, 0x2E64
273:               		return 7000;			// sotto i 0, setto 7,0
002E60  21B584     MOV #0x1B58, W4
002E62  37004F     BRA 0x2F02
274:               	else if (ReqTemp <= 300)
002E64  2012C4     MOV #0x12C, W4
002E66  78029E     MOV [W14], W5
002E68  528F84     SUB W5, W4, [W15]
002E6A  3C0002     BRA GT, 0x2E70
275:               		return 7500;			// sotto i 3, setto 7,5
002E6C  21D4C4     MOV #0x1D4C, W4
002E6E  370049     BRA 0x2F02
276:               	else if (ReqTemp <= 500)
002E70  201F44     MOV #0x1F4, W4
002E72  78029E     MOV [W14], W5
002E74  528F84     SUB W5, W4, [W15]
002E76  3C0002     BRA GT, 0x2E7C
277:               		return 8500;			// sotto i 5, setto 8,5
002E78  221344     MOV #0x2134, W4
002E7A  370043     BRA 0x2F02
278:               	else if (ReqTemp <= 750)
002E7C  202EE4     MOV #0x2EE, W4
002E7E  78029E     MOV [W14], W5
002E80  528F84     SUB W5, W4, [W15]
002E82  3C0002     BRA GT, 0x2E88
279:               		return 9000;			// sotto i 7,5, setto 9
002E84  223284     MOV #0x2328, W4
002E86  37003D     BRA 0x2F02
280:               	else if (ReqTemp <= 1000)
002E88  203E84     MOV #0x3E8, W4
002E8A  78029E     MOV [W14], W5
002E8C  528F84     SUB W5, W4, [W15]
002E8E  3C0002     BRA GT, 0x2E94
281:               		return 10000;			// sotto i 10, setto 11
002E90  227104     MOV #0x2710, W4
002E92  370037     BRA 0x2F02
282:               	else if (ReqTemp <= 1500)
002E94  205DC4     MOV #0x5DC, W4
002E96  78029E     MOV [W14], W5
002E98  528F84     SUB W5, W4, [W15]
002E9A  3C0002     BRA GT, 0x2EA0
283:               		return 11700;			// sotto i 15, setto 12
002E9C  22DB44     MOV #0x2DB4, W4
002E9E  370031     BRA 0x2F02
284:               	else if (ReqTemp <= 2000)
002EA0  207D04     MOV #0x7D0, W4
002EA2  78029E     MOV [W14], W5
002EA4  528F84     SUB W5, W4, [W15]
002EA6  3C0002     BRA GT, 0x2EAC
285:               		return 13600;			// sotto i 20, setto 14
002EA8  235204     MOV #0x3520, W4
002EAA  37002B     BRA 0x2F02
286:               	else if (ReqTemp < 2500)
002EAC  209C34     MOV #0x9C3, W4
002EAE  78029E     MOV [W14], W5
002EB0  528F84     SUB W5, W4, [W15]
002EB2  3C0002     BRA GT, 0x2EB8
287:               		return 16500;			// sotto i 25, setto 16,5
002EB4  240744     MOV #0x4074, W4
002EB6  370025     BRA 0x2F02
288:               	else if (ReqTemp < 3000)
002EB8  20BB74     MOV #0xBB7, W4
002EBA  78029E     MOV [W14], W5
002EBC  528F84     SUB W5, W4, [W15]
002EBE  3C0002     BRA GT, 0x2EC4
289:               		return 19000;			// sotto i 30, setto 19
002EC0  24A384     MOV #0x4A38, W4
002EC2  37001F     BRA 0x2F02
290:               	else if (ReqTemp < 3500)
002EC4  20DAB4     MOV #0xDAB, W4
002EC6  78029E     MOV [W14], W5
002EC8  528F84     SUB W5, W4, [W15]
002ECA  3C0002     BRA GT, 0x2ED0
291:               		return 22000;			// sotto i 35, setto 22
002ECC  255F04     MOV #0x55F0, W4
002ECE  370019     BRA 0x2F02
292:               	else if (ReqTemp < 4000)
002ED0  20F9F4     MOV #0xF9F, W4
002ED2  78029E     MOV [W14], W5
002ED4  528F84     SUB W5, W4, [W15]
002ED6  3C0002     BRA GT, 0x2EDC
293:               		return 25500;			// sotto i 40, setto 25,5
002ED8  2639C4     MOV #0x639C, W4
002EDA  370013     BRA 0x2F02
294:               	else if (ReqTemp < 4500)
002EDC  211934     MOV #0x1193, W4
002EDE  78029E     MOV [W14], W5
002EE0  528F84     SUB W5, W4, [W15]
002EE2  3C0002     BRA GT, 0x2EE8
295:               		return 29000;			// sotto i 45, setto 29
002EE4  271484     MOV #0x7148, W4
002EE6  37000D     BRA 0x2F02
296:               	else if (ReqTemp < 5000)
002EE8  213874     MOV #0x1387, W4
002EEA  78029E     MOV [W14], W5
002EEC  528F84     SUB W5, W4, [W15]
002EEE  3C0002     BRA GT, 0x2EF4
297:               		return 33000;			// sotto i 50, setto 33
002EF0  280E84     MOV #0x80E8, W4
002EF2  370007     BRA 0x2F02
298:               	else if (ReqTemp < 5500)
002EF4  2157B4     MOV #0x157B, W4
002EF6  78029E     MOV [W14], W5
002EF8  528F84     SUB W5, W4, [W15]
002EFA  3C0002     BRA GT, 0x2F00
299:               		return 36000;			// sotto i 50, setto 36
002EFC  28CA04     MOV #0x8CA0, W4
002EFE  370001     BRA 0x2F02
300:               	else
301:               		return 40000;			// sotto i 50, setto 40
002F00  29C404     MOV #0x9C40, W4
302:               }
002F02  780004     MOV W4, W0
002F04  FA8000     ULNK
002F06  060000     RETURN
303:               
304:               
305:               /*  *****************************************************************************************************************************
306:               	Ricavo la Temperatura partendo dalla pressione del GAS idonea alla modalità corrente
307:               	***************************************************************************************************************************** */
308:               
309:               unsigned int PressureGasToTempR410A(int ReqPress)
310:               {
002F08  FA0002     LNK #0x2
002F0A  780F00     MOV W0, [W14]
311:               // Valori ricavati da Tabella Pressione-Temperatura GAS R410A con range -25 +70 step 1°C
312:               // Ingresso: Pressione 
313:               // Uscita: Temperatura 
314:               
315:               
316:               	// ritorno valore pressione corrispondente come da tabella GAS R410A
317:               
318:               	if(ReqPress <= 	2500) return	-2500; 	
002F0C  209C44     MOV #0x9C4, W4
002F0E  78029E     MOV [W14], W5
002F10  528F84     SUB W5, W4, [W15]
002F12  3C0002     BRA GT, 0x2F18
002F14  2F63C4     MOV #0xF63C, W4
002F16  3701D5     BRA 0x32C2
319:               	if(ReqPress <= 	2580) return	-2400; 	
002F18  20A144     MOV #0xA14, W4
002F1A  78029E     MOV [W14], W5
002F1C  528F84     SUB W5, W4, [W15]
002F1E  3C0002     BRA GT, 0x2F24
002F20  2F6A04     MOV #0xF6A0, W4
002F22  3701CF     BRA 0x32C2
320:               	if(ReqPress <= 	2660) return	-2300; 	
002F24  20A644     MOV #0xA64, W4
002F26  78029E     MOV [W14], W5
002F28  528F84     SUB W5, W4, [W15]
002F2A  3C0002     BRA GT, 0x2F30
002F2C  2F7044     MOV #0xF704, W4
002F2E  3701C9     BRA 0x32C2
321:               	if(ReqPress <= 	2740) return	-2200; 	
002F30  20AB44     MOV #0xAB4, W4
002F32  78029E     MOV [W14], W5
002F34  528F84     SUB W5, W4, [W15]
002F36  3C0002     BRA GT, 0x2F3C
002F38  2F7684     MOV #0xF768, W4
002F3A  3701C3     BRA 0x32C2
322:               	if(ReqPress <= 	2820) return	-2100; 	
002F3C  20B044     MOV #0xB04, W4
002F3E  78029E     MOV [W14], W5
002F40  528F84     SUB W5, W4, [W15]
002F42  3C0002     BRA GT, 0x2F48
002F44  2F7CC4     MOV #0xF7CC, W4
002F46  3701BD     BRA 0x32C2
323:               	if(ReqPress <= 	3000) return	-2000; 	
002F48  20BB84     MOV #0xBB8, W4
002F4A  78029E     MOV [W14], W5
002F4C  528F84     SUB W5, W4, [W15]
002F4E  3C0002     BRA GT, 0x2F54
002F50  2F8304     MOV #0xF830, W4
002F52  3701B7     BRA 0x32C2
324:               	if(ReqPress <= 	3200) return	-1900; 	
002F54  20C804     MOV #0xC80, W4
002F56  78029E     MOV [W14], W5
002F58  528F84     SUB W5, W4, [W15]
002F5A  3C0002     BRA GT, 0x2F60
002F5C  2F8944     MOV #0xF894, W4
002F5E  3701B1     BRA 0x32C2
325:               	if(ReqPress <= 	3400) return	-1800; 	
002F60  20D484     MOV #0xD48, W4
002F62  78029E     MOV [W14], W5
002F64  528F84     SUB W5, W4, [W15]
002F66  3C0002     BRA GT, 0x2F6C
002F68  2F8F84     MOV #0xF8F8, W4
002F6A  3701AB     BRA 0x32C2
326:               	if(ReqPress <= 	3600) return	-1700; 	
002F6C  20E104     MOV #0xE10, W4
002F6E  78029E     MOV [W14], W5
002F70  528F84     SUB W5, W4, [W15]
002F72  3C0002     BRA GT, 0x2F78
002F74  2F95C4     MOV #0xF95C, W4
002F76  3701A5     BRA 0x32C2
327:               	if(ReqPress <= 	3800) return	-1600; 	
002F78  20ED84     MOV #0xED8, W4
002F7A  78029E     MOV [W14], W5
002F7C  528F84     SUB W5, W4, [W15]
002F7E  3C0002     BRA GT, 0x2F84
002F80  2F9C04     MOV #0xF9C0, W4
002F82  37019F     BRA 0x32C2
328:               	if(ReqPress <= 	4000) return	-1500; 	
002F84  20FA04     MOV #0xFA0, W4
002F86  78029E     MOV [W14], W5
002F88  528F84     SUB W5, W4, [W15]
002F8A  3C0002     BRA GT, 0x2F90
002F8C  2FA244     MOV #0xFA24, W4
002F8E  370199     BRA 0x32C2
329:               	if(ReqPress <= 	4200) return	-1400; 	
002F90  210684     MOV #0x1068, W4
002F92  78029E     MOV [W14], W5
002F94  528F84     SUB W5, W4, [W15]
002F96  3C0002     BRA GT, 0x2F9C
002F98  2FA884     MOV #0xFA88, W4
002F9A  370193     BRA 0x32C2
330:               	if(ReqPress <= 	4400) return	-1300; 	
002F9C  211304     MOV #0x1130, W4
002F9E  78029E     MOV [W14], W5
002FA0  528F84     SUB W5, W4, [W15]
002FA2  3C0002     BRA GT, 0x2FA8
002FA4  2FAEC4     MOV #0xFAEC, W4
002FA6  37018D     BRA 0x32C2
331:               	if(ReqPress <= 	4600) return	-1200; 	
002FA8  211F84     MOV #0x11F8, W4
002FAA  78029E     MOV [W14], W5
002FAC  528F84     SUB W5, W4, [W15]
002FAE  3C0002     BRA GT, 0x2FB4
002FB0  2FB504     MOV #0xFB50, W4
002FB2  370187     BRA 0x32C2
332:               	if(ReqPress <= 	4800) return	-1100; 	
002FB4  212C04     MOV #0x12C0, W4
002FB6  78029E     MOV [W14], W5
002FB8  528F84     SUB W5, W4, [W15]
002FBA  3C0002     BRA GT, 0x2FC0
002FBC  2FBB44     MOV #0xFBB4, W4
002FBE  370181     BRA 0x32C2
333:               	if(ReqPress <= 	5000) return	-1000; 	
002FC0  213884     MOV #0x1388, W4
002FC2  78029E     MOV [W14], W5
002FC4  528F84     SUB W5, W4, [W15]
002FC6  3C0002     BRA GT, 0x2FCC
002FC8  2FC184     MOV #0xFC18, W4
002FCA  37017B     BRA 0x32C2
334:               	if(ReqPress <= 	5200) return	-900; 	
002FCC  214504     MOV #0x1450, W4
002FCE  78029E     MOV [W14], W5
002FD0  528F84     SUB W5, W4, [W15]
002FD2  3C0002     BRA GT, 0x2FD8
002FD4  2FC7C4     MOV #0xFC7C, W4
002FD6  370175     BRA 0x32C2
335:               	if(ReqPress <= 	5400) return	-800; 	
002FD8  215184     MOV #0x1518, W4
002FDA  78029E     MOV [W14], W5
002FDC  528F84     SUB W5, W4, [W15]
002FDE  3C0002     BRA GT, 0x2FE4
002FE0  2FCE04     MOV #0xFCE0, W4
002FE2  37016F     BRA 0x32C2
336:               	if(ReqPress <= 	5600) return	-700; 	
002FE4  215E04     MOV #0x15E0, W4
002FE6  78029E     MOV [W14], W5
002FE8  528F84     SUB W5, W4, [W15]
002FEA  3C0002     BRA GT, 0x2FF0
002FEC  2FD444     MOV #0xFD44, W4
002FEE  370169     BRA 0x32C2
337:               	if(ReqPress <= 	5800) return	-600; 	
002FF0  216A84     MOV #0x16A8, W4
002FF2  78029E     MOV [W14], W5
002FF4  528F84     SUB W5, W4, [W15]
002FF6  3C0002     BRA GT, 0x2FFC
002FF8  2FDA84     MOV #0xFDA8, W4
002FFA  370163     BRA 0x32C2
338:               	if(ReqPress <= 	6000) return	-500; 	
002FFC  217704     MOV #0x1770, W4
002FFE  78029E     MOV [W14], W5
003000  528F84     SUB W5, W4, [W15]
003002  3C0002     BRA GT, 0x3008
003004  2FE0C4     MOV #0xFE0C, W4
003006  37015D     BRA 0x32C2
339:               	if(ReqPress <= 	6200) return	-400; 	
003008  218384     MOV #0x1838, W4
00300A  78029E     MOV [W14], W5
00300C  528F84     SUB W5, W4, [W15]
00300E  3C0002     BRA GT, 0x3014
003010  2FE704     MOV #0xFE70, W4
003012  370157     BRA 0x32C2
340:               	if(ReqPress <= 	6400) return	-300; 	
003014  219004     MOV #0x1900, W4
003016  78029E     MOV [W14], W5
003018  528F84     SUB W5, W4, [W15]
00301A  3C0002     BRA GT, 0x3020
00301C  2FED44     MOV #0xFED4, W4
00301E  370151     BRA 0x32C2
341:               	if(ReqPress <= 	6600) return	-200; 	
003020  219C84     MOV #0x19C8, W4
003022  78029E     MOV [W14], W5
003024  528F84     SUB W5, W4, [W15]
003026  3C0002     BRA GT, 0x302C
003028  2FF384     MOV #0xFF38, W4
00302A  37014B     BRA 0x32C2
342:               	if(ReqPress <= 	6800) return	-100; 	
00302C  21A904     MOV #0x1A90, W4
00302E  78029E     MOV [W14], W5
003030  528F84     SUB W5, W4, [W15]
003032  3C0002     BRA GT, 0x3038
003034  2FF9C4     MOV #0xFF9C, W4
003036  370145     BRA 0x32C2
343:               	if(ReqPress <= 	7000) return	 000; 	
003038  21B584     MOV #0x1B58, W4
00303A  78029E     MOV [W14], W5
00303C  528F84     SUB W5, W4, [W15]
00303E  3C0002     BRA GT, 0x3044
003040  EB0200     CLR W4
003042  37013F     BRA 0x32C2
344:               	if(ReqPress <= 	7300) return	 100; 	
003044  21C844     MOV #0x1C84, W4
003046  78029E     MOV [W14], W5
003048  528F84     SUB W5, W4, [W15]
00304A  3C0002     BRA GT, 0x3050
00304C  200644     MOV #0x64, W4
00304E  370139     BRA 0x32C2
345:               	if(ReqPress <= 	7600) return	 200; 	
003050  21DB04     MOV #0x1DB0, W4
003052  78029E     MOV [W14], W5
003054  528F84     SUB W5, W4, [W15]
003056  3C0002     BRA GT, 0x305C
003058  200C84     MOV #0xC8, W4
00305A  370133     BRA 0x32C2
346:               	if(ReqPress <= 	7900) return	 300; 	
00305C  21EDC4     MOV #0x1EDC, W4
00305E  78029E     MOV [W14], W5
003060  528F84     SUB W5, W4, [W15]
003062  3C0002     BRA GT, 0x3068
003064  2012C4     MOV #0x12C, W4
003066  37012D     BRA 0x32C2
347:               	if(ReqPress <= 	8200) return	 400; 	
003068  220084     MOV #0x2008, W4
00306A  78029E     MOV [W14], W5
00306C  528F84     SUB W5, W4, [W15]
00306E  3C0002     BRA GT, 0x3074
003070  201904     MOV #0x190, W4
003072  370127     BRA 0x32C2
348:               	if(ReqPress <= 	8500) return	 500; 	
003074  221344     MOV #0x2134, W4
003076  78029E     MOV [W14], W5
003078  528F84     SUB W5, W4, [W15]
00307A  3C0002     BRA GT, 0x3080
00307C  201F44     MOV #0x1F4, W4
00307E  370121     BRA 0x32C2
349:               	if(ReqPress <= 	8800) return	 600; 	
003080  222604     MOV #0x2260, W4
003082  78029E     MOV [W14], W5
003084  528F84     SUB W5, W4, [W15]
003086  3C0002     BRA GT, 0x308C
003088  202584     MOV #0x258, W4
00308A  37011B     BRA 0x32C2
350:               	if(ReqPress <=	9100) return	 700; 
00308C  2238C4     MOV #0x238C, W4
00308E  78029E     MOV [W14], W5
003090  528F84     SUB W5, W4, [W15]
003092  3C0002     BRA GT, 0x3098
003094  202BC4     MOV #0x2BC, W4
003096  370115     BRA 0x32C2
351:               	if(ReqPress <=	9400) return	 800; 
003098  224B84     MOV #0x24B8, W4
00309A  78029E     MOV [W14], W5
00309C  528F84     SUB W5, W4, [W15]
00309E  3C0002     BRA GT, 0x30A4
0030A0  203204     MOV #0x320, W4
0030A2  37010F     BRA 0x32C2
352:               	if(ReqPress <=	9700) return	 900; 
0030A4  225E44     MOV #0x25E4, W4
0030A6  78029E     MOV [W14], W5
0030A8  528F84     SUB W5, W4, [W15]
0030AA  3C0002     BRA GT, 0x30B0
0030AC  203844     MOV #0x384, W4
0030AE  370109     BRA 0x32C2
353:               	if(ReqPress <=	10000) return	1000; 
0030B0  227104     MOV #0x2710, W4
0030B2  78029E     MOV [W14], W5
0030B4  528F84     SUB W5, W4, [W15]
0030B6  3C0002     BRA GT, 0x30BC
0030B8  203E84     MOV #0x3E8, W4
0030BA  370103     BRA 0x32C2
354:               	if(ReqPress <=	10350) return	1100; 
0030BC  2286E4     MOV #0x286E, W4
0030BE  78029E     MOV [W14], W5
0030C0  528F84     SUB W5, W4, [W15]
0030C2  3C0002     BRA GT, 0x30C8
0030C4  2044C4     MOV #0x44C, W4
0030C6  3700FD     BRA 0x32C2
355:               	if(ReqPress <=	10700) return	1200; 
0030C8  229CC4     MOV #0x29CC, W4
0030CA  78029E     MOV [W14], W5
0030CC  528F84     SUB W5, W4, [W15]
0030CE  3C0002     BRA GT, 0x30D4
0030D0  204B04     MOV #0x4B0, W4
0030D2  3700F7     BRA 0x32C2
356:               	if(ReqPress <=	10950) return	1300; 
0030D4  22AC64     MOV #0x2AC6, W4
0030D6  78029E     MOV [W14], W5
0030D8  528F84     SUB W5, W4, [W15]
0030DA  3C0002     BRA GT, 0x30E0
0030DC  205144     MOV #0x514, W4
0030DE  3700F1     BRA 0x32C2
357:               	if(ReqPress <=	11300) return	1400; 
0030E0  22C244     MOV #0x2C24, W4
0030E2  78029E     MOV [W14], W5
0030E4  528F84     SUB W5, W4, [W15]
0030E6  3C0002     BRA GT, 0x30EC
0030E8  205784     MOV #0x578, W4
0030EA  3700EB     BRA 0x32C2
358:               	if(ReqPress <=	11650) return	1500; 
0030EC  22D824     MOV #0x2D82, W4
0030EE  78029E     MOV [W14], W5
0030F0  528F84     SUB W5, W4, [W15]
0030F2  3C0002     BRA GT, 0x30F8
0030F4  205DC4     MOV #0x5DC, W4
0030F6  3700E5     BRA 0x32C2
359:               	if(ReqPress <=	12000) return	1600; 
0030F8  22EE04     MOV #0x2EE0, W4
0030FA  78029E     MOV [W14], W5
0030FC  528F84     SUB W5, W4, [W15]
0030FE  3C0002     BRA GT, 0x3104
003100  206404     MOV #0x640, W4
003102  3700DF     BRA 0x32C2
360:               	if(ReqPress <=	12350) return	1700; 
003104  2303E4     MOV #0x303E, W4
003106  78029E     MOV [W14], W5
003108  528F84     SUB W5, W4, [W15]
00310A  3C0002     BRA GT, 0x3110
00310C  206A44     MOV #0x6A4, W4
00310E  3700D9     BRA 0x32C2
361:               	if(ReqPress <=	12700) return	1800; 
003110  2319C4     MOV #0x319C, W4
003112  78029E     MOV [W14], W5
003114  528F84     SUB W5, W4, [W15]
003116  3C0002     BRA GT, 0x311C
003118  207084     MOV #0x708, W4
00311A  3700D3     BRA 0x32C2
362:               	if(ReqPress <=	13050) return	1900; 
00311C  232FA4     MOV #0x32FA, W4
00311E  78029E     MOV [W14], W5
003120  528F84     SUB W5, W4, [W15]
003122  3C0002     BRA GT, 0x3128
003124  2076C4     MOV #0x76C, W4
003126  3700CD     BRA 0x32C2
363:               	if(ReqPress <=	13500) return	2000; 
003128  234BC4     MOV #0x34BC, W4
00312A  78029E     MOV [W14], W5
00312C  528F84     SUB W5, W4, [W15]
00312E  3C0002     BRA GT, 0x3134
003130  207D04     MOV #0x7D0, W4
003132  3700C7     BRA 0x32C2
364:               	if(ReqPress <=	13950) return	2100; 
003134  2367E4     MOV #0x367E, W4
003136  78029E     MOV [W14], W5
003138  528F84     SUB W5, W4, [W15]
00313A  3C0002     BRA GT, 0x3140
00313C  208344     MOV #0x834, W4
00313E  3700C1     BRA 0x32C2
365:               	if(ReqPress <=	14400) return	2200; 
003140  238404     MOV #0x3840, W4
003142  78029E     MOV [W14], W5
003144  528F84     SUB W5, W4, [W15]
003146  3C0002     BRA GT, 0x314C
003148  208984     MOV #0x898, W4
00314A  3700BB     BRA 0x32C2
366:               	if(ReqPress <=	14850) return	2300; 
00314C  23A024     MOV #0x3A02, W4
00314E  78029E     MOV [W14], W5
003150  528F84     SUB W5, W4, [W15]
003152  3C0002     BRA GT, 0x3158
003154  208FC4     MOV #0x8FC, W4
003156  3700B5     BRA 0x32C2
367:               	if(ReqPress <=	15300) return	2400; 
003158  23BC44     MOV #0x3BC4, W4
00315A  78029E     MOV [W14], W5
00315C  528F84     SUB W5, W4, [W15]
00315E  3C0002     BRA GT, 0x3164
003160  209604     MOV #0x960, W4
003162  3700AF     BRA 0x32C2
368:               	if(ReqPress <=	15750) return	2500; 
003164  23D864     MOV #0x3D86, W4
003166  78029E     MOV [W14], W5
003168  528F84     SUB W5, W4, [W15]
00316A  3C0002     BRA GT, 0x3170
00316C  209C44     MOV #0x9C4, W4
00316E  3700A9     BRA 0x32C2
369:               	if(ReqPress <=	16200) return	2600; 
003170  23F484     MOV #0x3F48, W4
003172  78029E     MOV [W14], W5
003174  528F84     SUB W5, W4, [W15]
003176  3C0002     BRA GT, 0x317C
003178  20A284     MOV #0xA28, W4
00317A  3700A3     BRA 0x32C2
370:               	if(ReqPress <=	16650) return	2700; 
00317C  2410A4     MOV #0x410A, W4
00317E  78029E     MOV [W14], W5
003180  528F84     SUB W5, W4, [W15]
003182  3C0002     BRA GT, 0x3188
003184  20A8C4     MOV #0xA8C, W4
003186  37009D     BRA 0x32C2
371:               	if(ReqPress <=	17100) return 	2800;	
003188  242CC4     MOV #0x42CC, W4
00318A  78029E     MOV [W14], W5
00318C  528F84     SUB W5, W4, [W15]
00318E  3C0002     BRA GT, 0x3194
003190  20AF04     MOV #0xAF0, W4
003192  370097     BRA 0x32C2
372:               	if(ReqPress <=	17550) return 	2900;	
003194  2448E4     MOV #0x448E, W4
003196  78029E     MOV [W14], W5
003198  528F84     SUB W5, W4, [W15]
00319A  3C0002     BRA GT, 0x31A0
00319C  20B544     MOV #0xB54, W4
00319E  370091     BRA 0x32C2
373:               	if(ReqPress <=	18000) return 	3000;	
0031A0  246504     MOV #0x4650, W4
0031A2  78029E     MOV [W14], W5
0031A4  528F84     SUB W5, W4, [W15]
0031A6  3C0002     BRA GT, 0x31AC
0031A8  20BB84     MOV #0xBB8, W4
0031AA  37008B     BRA 0x32C2
374:               	if(ReqPress <=	18500) return 	3100;	
0031AC  248444     MOV #0x4844, W4
0031AE  78029E     MOV [W14], W5
0031B0  528F84     SUB W5, W4, [W15]
0031B2  3C0002     BRA GT, 0x31B8
0031B4  20C1C4     MOV #0xC1C, W4
0031B6  370085     BRA 0x32C2
375:               	if(ReqPress <=	19000) return 	3200;	
0031B8  24A384     MOV #0x4A38, W4
0031BA  78029E     MOV [W14], W5
0031BC  528F84     SUB W5, W4, [W15]
0031BE  3C0002     BRA GT, 0x31C4
0031C0  20C804     MOV #0xC80, W4
0031C2  37007F     BRA 0x32C2
376:               	if(ReqPress <=	19500) return 	3300;	
0031C4  24C2C4     MOV #0x4C2C, W4
0031C6  78029E     MOV [W14], W5
0031C8  528F84     SUB W5, W4, [W15]
0031CA  3C0002     BRA GT, 0x31D0
0031CC  20CE44     MOV #0xCE4, W4
0031CE  370079     BRA 0x32C2
377:               	if(ReqPress <=	20000) return 	3400;	
0031D0  24E204     MOV #0x4E20, W4
0031D2  78029E     MOV [W14], W5
0031D4  528F84     SUB W5, W4, [W15]
0031D6  3C0002     BRA GT, 0x31DC
0031D8  20D484     MOV #0xD48, W4
0031DA  370073     BRA 0x32C2
378:               	if(ReqPress <=	20500) return 	3500;	
0031DC  250144     MOV #0x5014, W4
0031DE  78029E     MOV [W14], W5
0031E0  528F84     SUB W5, W4, [W15]
0031E2  3C0002     BRA GT, 0x31E8
0031E4  20DAC4     MOV #0xDAC, W4
0031E6  37006D     BRA 0x32C2
379:               	if(ReqPress <=	21000) return 	3600;	
0031E8  252084     MOV #0x5208, W4
0031EA  78029E     MOV [W14], W5
0031EC  528F84     SUB W5, W4, [W15]
0031EE  3C0002     BRA GT, 0x31F4
0031F0  20E104     MOV #0xE10, W4
0031F2  370067     BRA 0x32C2
380:               	if(ReqPress <=	21500) return 	3700;	
0031F4  253FC4     MOV #0x53FC, W4
0031F6  78029E     MOV [W14], W5
0031F8  528F84     SUB W5, W4, [W15]
0031FA  3C0002     BRA GT, 0x3200
0031FC  20E744     MOV #0xE74, W4
0031FE  370061     BRA 0x32C2
381:               	if(ReqPress <=	22000) return 	3800;	
003200  255F04     MOV #0x55F0, W4
003202  78029E     MOV [W14], W5
003204  528F84     SUB W5, W4, [W15]
003206  3C0002     BRA GT, 0x320C
003208  20ED84     MOV #0xED8, W4
00320A  37005B     BRA 0x32C2
382:               	if(ReqPress <=	22500) return 	3900;	
00320C  257E44     MOV #0x57E4, W4
00320E  78029E     MOV [W14], W5
003210  528F84     SUB W5, W4, [W15]
003212  3C0002     BRA GT, 0x3218
003214  20F3C4     MOV #0xF3C, W4
003216  370055     BRA 0x32C2
383:               	if(ReqPress <=	23000) return 	4000;	
003218  259D84     MOV #0x59D8, W4
00321A  78029E     MOV [W14], W5
00321C  528F84     SUB W5, W4, [W15]
00321E  3C0002     BRA GT, 0x3224
003220  20FA04     MOV #0xFA0, W4
003222  37004F     BRA 0x32C2
384:               	if(ReqPress <=	23700) return 	4100;	
003224  25C944     MOV #0x5C94, W4
003226  78029E     MOV [W14], W5
003228  528F84     SUB W5, W4, [W15]
00322A  3C0002     BRA GT, 0x3230
00322C  210044     MOV #0x1004, W4
00322E  370049     BRA 0x32C2
385:               	if(ReqPress <=	24400) return 	4200;	
003230  25F504     MOV #0x5F50, W4
003232  78029E     MOV [W14], W5
003234  528F84     SUB W5, W4, [W15]
003236  3C0002     BRA GT, 0x323C
003238  210684     MOV #0x1068, W4
00323A  370043     BRA 0x32C2
386:               	if(ReqPress <=	25100) return 	4300;	
00323C  2620C4     MOV #0x620C, W4
00323E  78029E     MOV [W14], W5
003240  528F84     SUB W5, W4, [W15]
003242  3C0002     BRA GT, 0x3248
003244  210CC4     MOV #0x10CC, W4
003246  37003D     BRA 0x32C2
387:               	if(ReqPress <=	25800) return 	4400;	
003248  264C84     MOV #0x64C8, W4
00324A  78029E     MOV [W14], W5
00324C  528F84     SUB W5, W4, [W15]
00324E  3C0002     BRA GT, 0x3254
003250  211304     MOV #0x1130, W4
003252  370037     BRA 0x32C2
388:               	if(ReqPress <=	26500) return 	4500;	
003254  267844     MOV #0x6784, W4
003256  78029E     MOV [W14], W5
003258  528F84     SUB W5, W4, [W15]
00325A  3C0002     BRA GT, 0x3260
00325C  211944     MOV #0x1194, W4
00325E  370031     BRA 0x32C2
389:               	if(ReqPress <=	27200) return 	4600;	
003260  26A404     MOV #0x6A40, W4
003262  78029E     MOV [W14], W5
003264  528F84     SUB W5, W4, [W15]
003266  3C0002     BRA GT, 0x326C
003268  211F84     MOV #0x11F8, W4
00326A  37002B     BRA 0x32C2
390:               	if(ReqPress <=	27900) return 	4700;	
00326C  26CFC4     MOV #0x6CFC, W4
00326E  78029E     MOV [W14], W5
003270  528F84     SUB W5, W4, [W15]
003272  3C0002     BRA GT, 0x3278
003274  2125C4     MOV #0x125C, W4
003276  370025     BRA 0x32C2
391:               	if(ReqPress <=	28600) return 	4800;	
003278  26FB84     MOV #0x6FB8, W4
00327A  78029E     MOV [W14], W5
00327C  528F84     SUB W5, W4, [W15]
00327E  3C0002     BRA GT, 0x3284
003280  212C04     MOV #0x12C0, W4
003282  37001F     BRA 0x32C2
392:               	if(ReqPress <=	29300) return 	4900;	
003284  272744     MOV #0x7274, W4
003286  78029E     MOV [W14], W5
003288  528F84     SUB W5, W4, [W15]
00328A  3C0002     BRA GT, 0x3290
00328C  213244     MOV #0x1324, W4
00328E  370019     BRA 0x32C2
393:               	if(ReqPress <=	30000) return 	5000;	
003290  275304     MOV #0x7530, W4
003292  78029E     MOV [W14], W5
003294  528F84     SUB W5, W4, [W15]
003296  3C0002     BRA GT, 0x329C
003298  213884     MOV #0x1388, W4
00329A  370013     BRA 0x32C2
394:               	if(ReqPress <=	30830) return 	5100;	
00329C  2786E4     MOV #0x786E, W4
00329E  78029E     MOV [W14], W5
0032A0  528F84     SUB W5, W4, [W15]
0032A2  3C0002     BRA GT, 0x32A8
0032A4  213EC4     MOV #0x13EC, W4
0032A6  37000D     BRA 0x32C2
395:               	if(ReqPress <=	31660) return 	5200;	
0032A8  27BAC4     MOV #0x7BAC, W4
0032AA  78029E     MOV [W14], W5
0032AC  528F84     SUB W5, W4, [W15]
0032AE  3C0002     BRA GT, 0x32B4
0032B0  214504     MOV #0x1450, W4
0032B2  370007     BRA 0x32C2
396:               	if(ReqPress <=	32490) return 	5300;	
0032B4  27EEA4     MOV #0x7EEA, W4
0032B6  78029E     MOV [W14], W5
0032B8  528F84     SUB W5, W4, [W15]
0032BA  3C0002     BRA GT, 0x32C0
0032BC  214B44     MOV #0x14B4, W4
0032BE  370001     BRA 0x32C2
397:               	if(ReqPress <=	33320) return 	5400;	
0032C0  215184     MOV #0x1518, W4
398:               	if(ReqPress <=	34150) return 	5500;	
399:               	if(ReqPress <=	34980) return 	5600;	
400:               	if(ReqPress <=	35810) return 	5700;	
401:               	if(ReqPress <=	36640) return 	5800;	
402:               	if(ReqPress <=	37470) return 	5900;	
403:               	if(ReqPress <=	38300) return 	6000;	
404:               	if(ReqPress <=	39130) return 	6100;	
405:               	if(ReqPress <=	40000) return 	6200;	
406:               	if(ReqPress <=	40870) return 	6300;	
407:               	if(ReqPress <=	41740) return 	6400;	
408:               	if(ReqPress <=	42610) return 	6500;	
409:               	if(ReqPress <=	43480) return 	6600;	
410:               	if(ReqPress <=	44350) return 	6700;	
411:               	if(ReqPress <=	45220) return 	6800;	
412:               	if(ReqPress <=	46090) return 	6900;	
413:               	if(ReqPress <=	47000) return 	7000;	
414:               
415:               	if(ReqPress >	47000) return 	7000;	
416:               
417:               	return 0;
418:               	
419:               }
0032C2  780004     MOV W4, W0
0032C4  FA8000     ULNK
0032C6  060000     RETURN
420:               
421:               unsigned int TempToPressureGasR410A(int ReqTemp)
422:               {
0032C8  FA0004     LNK #0x4
0032CA  980710     MOV W0, [W14+2]
423:               // Valori ricavati da Tabella Pressione-Temperatura GAS R407C con range -25 +70 step 1°C
424:               // Ingresso: Temperatura 
425:               // Uscita: Pressione 
426:               
427:               	int TempConv;
428:               	unsigned int RetVal;
429:               	
430:               	TempConv = ReqTemp/100;				// Converto Temperatura da centesimi in gradi
0032CC  90029E     MOV [W14+2], W5
0032CE  200644     MOV #0x64, W4
0032D0  090011     REPEAT #0x11
0032D2  D80284     DIV.SW W5, W4
0032D4  780200     MOV W0, W4
0032D6  780F04     MOV W4, [W14]
431:                
432:               
433:               	// ritorno valore pressione corrispondente come da tabella GAS R410A
434:               
435:               	if(TempConv <= -25) return 2500; 
0032D8  78021E     MOV [W14], W4
0032DA  420FF8     ADD W4, #0x18, [W15]
0032DC  3D0002     BRA GE, 0x32E2
0032DE  209C44     MOV #0x9C4, W4
0032E0  370203     BRA 0x36E8
436:               	if(TempConv == -24) return 2580; 
0032E2  78021E     MOV [W14], W4
0032E4  420FF8     ADD W4, #0x18, [W15]
0032E6  3A0002     BRA NZ, 0x32EC
0032E8  20A144     MOV #0xA14, W4
0032EA  3701FE     BRA 0x36E8
437:               	if(TempConv == -23) return 2660; 
0032EC  78021E     MOV [W14], W4
0032EE  420FF7     ADD W4, #0x17, [W15]
0032F0  3A0002     BRA NZ, 0x32F6
0032F2  20A644     MOV #0xA64, W4
0032F4  3701F9     BRA 0x36E8
438:               	if(TempConv == -22) return 2740; 
0032F6  78021E     MOV [W14], W4
0032F8  420FF6     ADD W4, #0x16, [W15]
0032FA  3A0002     BRA NZ, 0x3300
0032FC  20AB44     MOV #0xAB4, W4
0032FE  3701F4     BRA 0x36E8
439:               	if(TempConv == -21) return 2820; 
003300  78021E     MOV [W14], W4
003302  420FF5     ADD W4, #0x15, [W15]
003304  3A0002     BRA NZ, 0x330A
003306  20B044     MOV #0xB04, W4
003308  3701EF     BRA 0x36E8
440:               	if(TempConv == -20) return 3000; 
00330A  78021E     MOV [W14], W4
00330C  420FF4     ADD W4, #0x14, [W15]
00330E  3A0002     BRA NZ, 0x3314
003310  20BB84     MOV #0xBB8, W4
003312  3701EA     BRA 0x36E8
441:               	if(TempConv == -19) return 3200; 
003314  78021E     MOV [W14], W4
003316  420FF3     ADD W4, #0x13, [W15]
003318  3A0002     BRA NZ, 0x331E
00331A  20C804     MOV #0xC80, W4
00331C  3701E5     BRA 0x36E8
442:               	if(TempConv == -18) return 3400; 
00331E  78021E     MOV [W14], W4
003320  420FF2     ADD W4, #0x12, [W15]
003322  3A0002     BRA NZ, 0x3328
003324  20D484     MOV #0xD48, W4
003326  3701E0     BRA 0x36E8
443:               	if(TempConv == -17) return 3600; 
003328  78021E     MOV [W14], W4
00332A  420FF1     ADD W4, #0x11, [W15]
00332C  3A0002     BRA NZ, 0x3332
00332E  20E104     MOV #0xE10, W4
003330  3701DB     BRA 0x36E8
444:               	if(TempConv == -16) return 3800; 
003332  78021E     MOV [W14], W4
003334  420FF0     ADD W4, #0x10, [W15]
003336  3A0002     BRA NZ, 0x333C
003338  20ED84     MOV #0xED8, W4
00333A  3701D6     BRA 0x36E8
445:               	if(TempConv == -15) return 4000; 
00333C  78021E     MOV [W14], W4
00333E  420FEF     ADD W4, #0xF, [W15]
003340  3A0002     BRA NZ, 0x3346
003342  20FA04     MOV #0xFA0, W4
003344  3701D1     BRA 0x36E8
446:               	if(TempConv == -14) return 4200; 
003346  78021E     MOV [W14], W4
003348  420FEE     ADD W4, #0xE, [W15]
00334A  3A0002     BRA NZ, 0x3350
00334C  210684     MOV #0x1068, W4
00334E  3701CC     BRA 0x36E8
447:               	if(TempConv == -13) return 4400; 
003350  78021E     MOV [W14], W4
003352  420FED     ADD W4, #0xD, [W15]
003354  3A0002     BRA NZ, 0x335A
003356  211304     MOV #0x1130, W4
003358  3701C7     BRA 0x36E8
448:               	if(TempConv == -12) return 4600; 
00335A  78021E     MOV [W14], W4
00335C  420FEC     ADD W4, #0xC, [W15]
00335E  3A0002     BRA NZ, 0x3364
003360  211F84     MOV #0x11F8, W4
003362  3701C2     BRA 0x36E8
449:               	if(TempConv == -11) return 4800; 
003364  78021E     MOV [W14], W4
003366  420FEB     ADD W4, #0xB, [W15]
003368  3A0002     BRA NZ, 0x336E
00336A  212C04     MOV #0x12C0, W4
00336C  3701BD     BRA 0x36E8
450:               	if(TempConv == -10) return 5000; 
00336E  78021E     MOV [W14], W4
003370  420FEA     ADD W4, #0xA, [W15]
003372  3A0002     BRA NZ, 0x3378
003374  213884     MOV #0x1388, W4
003376  3701B8     BRA 0x36E8
451:               	if(TempConv == -9)	return 5200; 
003378  78021E     MOV [W14], W4
00337A  420FE9     ADD W4, #0x9, [W15]
00337C  3A0002     BRA NZ, 0x3382
00337E  214504     MOV #0x1450, W4
003380  3701B3     BRA 0x36E8
452:               	if(TempConv == -8)	return 5400; 
003382  78021E     MOV [W14], W4
003384  420FE8     ADD W4, #0x8, [W15]
003386  3A0002     BRA NZ, 0x338C
003388  215184     MOV #0x1518, W4
00338A  3701AE     BRA 0x36E8
453:               	if(TempConv == -7)	return 5600; 
00338C  78021E     MOV [W14], W4
00338E  420FE7     ADD W4, #0x7, [W15]
003390  3A0002     BRA NZ, 0x3396
003392  215E04     MOV #0x15E0, W4
003394  3701A9     BRA 0x36E8
454:               	if(TempConv == -6)	return 5800; 
003396  78021E     MOV [W14], W4
003398  420FE6     ADD W4, #0x6, [W15]
00339A  3A0002     BRA NZ, 0x33A0
00339C  216A84     MOV #0x16A8, W4
00339E  3701A4     BRA 0x36E8
455:               	if(TempConv == -5)	return 6000; 
0033A0  78021E     MOV [W14], W4
0033A2  420FE5     ADD W4, #0x5, [W15]
0033A4  3A0002     BRA NZ, 0x33AA
0033A6  217704     MOV #0x1770, W4
0033A8  37019F     BRA 0x36E8
456:               	if(TempConv == -4)	return 6200; 
0033AA  78021E     MOV [W14], W4
0033AC  420FE4     ADD W4, #0x4, [W15]
0033AE  3A0002     BRA NZ, 0x33B4
0033B0  218384     MOV #0x1838, W4
0033B2  37019A     BRA 0x36E8
457:               	if(TempConv == -3)	return 6400; 
0033B4  78021E     MOV [W14], W4
0033B6  420FE3     ADD W4, #0x3, [W15]
0033B8  3A0002     BRA NZ, 0x33BE
0033BA  219004     MOV #0x1900, W4
0033BC  370195     BRA 0x36E8
458:               	if(TempConv == -2)	return 6600; 
0033BE  78021E     MOV [W14], W4
0033C0  420FE2     ADD W4, #0x2, [W15]
0033C2  3A0002     BRA NZ, 0x33C8
0033C4  219C84     MOV #0x19C8, W4
0033C6  370190     BRA 0x36E8
459:               	if(TempConv == -1)	return 6800; 
0033C8  78021E     MOV [W14], W4
0033CA  420FE1     ADD W4, #0x1, [W15]
0033CC  3A0002     BRA NZ, 0x33D2
0033CE  21A904     MOV #0x1A90, W4
0033D0  37018B     BRA 0x36E8
460:               	if(TempConv ==  0)	return 7000; 
0033D2  78021E     MOV [W14], W4
0033D4  520FE0     SUB W4, #0x0, [W15]
0033D6  3A0002     BRA NZ, 0x33DC
0033D8  21B584     MOV #0x1B58, W4
0033DA  370186     BRA 0x36E8
461:               	if(TempConv ==  1)	return 7300; 
0033DC  78021E     MOV [W14], W4
0033DE  520FE1     SUB W4, #0x1, [W15]
0033E0  3A0002     BRA NZ, 0x33E6
0033E2  21C844     MOV #0x1C84, W4
0033E4  370181     BRA 0x36E8
462:               	if(TempConv ==  2)	return 7600; 
0033E6  78021E     MOV [W14], W4
0033E8  520FE2     SUB W4, #0x2, [W15]
0033EA  3A0002     BRA NZ, 0x33F0
0033EC  21DB04     MOV #0x1DB0, W4
0033EE  37017C     BRA 0x36E8
463:               	if(TempConv ==  3)	return 7900; 
0033F0  78021E     MOV [W14], W4
0033F2  520FE3     SUB W4, #0x3, [W15]
0033F4  3A0002     BRA NZ, 0x33FA
0033F6  21EDC4     MOV #0x1EDC, W4
0033F8  370177     BRA 0x36E8
464:               	if(TempConv ==  4)	return 8200; 
0033FA  78021E     MOV [W14], W4
0033FC  520FE4     SUB W4, #0x4, [W15]
0033FE  3A0002     BRA NZ, 0x3404
003400  220084     MOV #0x2008, W4
003402  370172     BRA 0x36E8
465:               	if(TempConv ==  5)	return 8500; 
003404  78021E     MOV [W14], W4
003406  520FE5     SUB W4, #0x5, [W15]
003408  3A0002     BRA NZ, 0x340E
00340A  221344     MOV #0x2134, W4
00340C  37016D     BRA 0x36E8
466:               	if(TempConv ==  6)	return 8800; 
00340E  78021E     MOV [W14], W4
003410  520FE6     SUB W4, #0x6, [W15]
003412  3A0002     BRA NZ, 0x3418
003414  222604     MOV #0x2260, W4
003416  370168     BRA 0x36E8
467:               	if(TempConv ==  7)	return 9100; 
003418  78021E     MOV [W14], W4
00341A  520FE7     SUB W4, #0x7, [W15]
00341C  3A0002     BRA NZ, 0x3422
00341E  2238C4     MOV #0x238C, W4
003420  370163     BRA 0x36E8
468:               	if(TempConv ==  8)	return 9400; 
003422  78021E     MOV [W14], W4
003424  520FE8     SUB W4, #0x8, [W15]
003426  3A0002     BRA NZ, 0x342C
003428  224B84     MOV #0x24B8, W4
00342A  37015E     BRA 0x36E8
469:               	if(TempConv ==  9)	return 9700; 
00342C  78021E     MOV [W14], W4
00342E  520FE9     SUB W4, #0x9, [W15]
003430  3A0002     BRA NZ, 0x3436
003432  225E44     MOV #0x25E4, W4
003434  370159     BRA 0x36E8
470:               	if(TempConv == 10)	return 10000; 
003436  78021E     MOV [W14], W4
003438  520FEA     SUB W4, #0xA, [W15]
00343A  3A0002     BRA NZ, 0x3440
00343C  227104     MOV #0x2710, W4
00343E  370154     BRA 0x36E8
471:               	if(TempConv == 11)	return 10350; 
003440  78021E     MOV [W14], W4
003442  520FEB     SUB W4, #0xB, [W15]
003444  3A0002     BRA NZ, 0x344A
003446  2286E4     MOV #0x286E, W4
003448  37014F     BRA 0x36E8
472:               	if(TempConv == 12)	return 10700; 
00344A  78021E     MOV [W14], W4
00344C  520FEC     SUB W4, #0xC, [W15]
00344E  3A0002     BRA NZ, 0x3454
003450  229CC4     MOV #0x29CC, W4
003452  37014A     BRA 0x36E8
473:               	if(TempConv == 13)	return 10950; 
003454  78021E     MOV [W14], W4
003456  520FED     SUB W4, #0xD, [W15]
003458  3A0002     BRA NZ, 0x345E
00345A  22AC64     MOV #0x2AC6, W4
00345C  370145     BRA 0x36E8
474:               	if(TempConv == 14)	return 11300; 
00345E  78021E     MOV [W14], W4
003460  520FEE     SUB W4, #0xE, [W15]
003462  3A0002     BRA NZ, 0x3468
003464  22C244     MOV #0x2C24, W4
003466  370140     BRA 0x36E8
475:               	if(TempConv == 15)	return 11650; 
003468  78021E     MOV [W14], W4
00346A  520FEF     SUB W4, #0xF, [W15]
00346C  3A0002     BRA NZ, 0x3472
00346E  22D824     MOV #0x2D82, W4
003470  37013B     BRA 0x36E8
476:               	if(TempConv == 16)	return 12000; 
003472  78021E     MOV [W14], W4
003474  520FF0     SUB W4, #0x10, [W15]
003476  3A0002     BRA NZ, 0x347C
003478  22EE04     MOV #0x2EE0, W4
00347A  370136     BRA 0x36E8
477:               	if(TempConv == 17)	return 12350; 
00347C  78021E     MOV [W14], W4
00347E  520FF1     SUB W4, #0x11, [W15]
003480  3A0002     BRA NZ, 0x3486
003482  2303E4     MOV #0x303E, W4
003484  370131     BRA 0x36E8
478:               	if(TempConv == 18)	return 12700; 
003486  78021E     MOV [W14], W4
003488  520FF2     SUB W4, #0x12, [W15]
00348A  3A0002     BRA NZ, 0x3490
00348C  2319C4     MOV #0x319C, W4
00348E  37012C     BRA 0x36E8
479:               	if(TempConv == 19)	return 13050; 
003490  78021E     MOV [W14], W4
003492  520FF3     SUB W4, #0x13, [W15]
003494  3A0002     BRA NZ, 0x349A
003496  232FA4     MOV #0x32FA, W4
003498  370127     BRA 0x36E8
480:               	if(TempConv == 20)	return 13500; 
00349A  78021E     MOV [W14], W4
00349C  520FF4     SUB W4, #0x14, [W15]
00349E  3A0002     BRA NZ, 0x34A4
0034A0  234BC4     MOV #0x34BC, W4
0034A2  370122     BRA 0x36E8
481:               	if(TempConv == 21)	return 13950; 
0034A4  78021E     MOV [W14], W4
0034A6  520FF5     SUB W4, #0x15, [W15]
0034A8  3A0002     BRA NZ, 0x34AE
0034AA  2367E4     MOV #0x367E, W4
0034AC  37011D     BRA 0x36E8
482:               	if(TempConv == 22)	return 14400; 
0034AE  78021E     MOV [W14], W4
0034B0  520FF6     SUB W4, #0x16, [W15]
0034B2  3A0002     BRA NZ, 0x34B8
0034B4  238404     MOV #0x3840, W4
0034B6  370118     BRA 0x36E8
483:               	if(TempConv == 23)	return 14850; 
0034B8  78021E     MOV [W14], W4
0034BA  520FF7     SUB W4, #0x17, [W15]
0034BC  3A0002     BRA NZ, 0x34C2
0034BE  23A024     MOV #0x3A02, W4
0034C0  370113     BRA 0x36E8
484:               	if(TempConv == 24)	return 15300; 
0034C2  78021E     MOV [W14], W4
0034C4  520FF8     SUB W4, #0x18, [W15]
0034C6  3A0002     BRA NZ, 0x34CC
0034C8  23BC44     MOV #0x3BC4, W4
0034CA  37010E     BRA 0x36E8
485:               	if(TempConv == 25)	return 15750; 
0034CC  78021E     MOV [W14], W4
0034CE  520FF9     SUB W4, #0x19, [W15]
0034D0  3A0002     BRA NZ, 0x34D6
0034D2  23D864     MOV #0x3D86, W4
0034D4  370109     BRA 0x36E8
486:               	if(TempConv == 26)	return 16200; 
0034D6  78021E     MOV [W14], W4
0034D8  520FFA     SUB W4, #0x1A, [W15]
0034DA  3A0002     BRA NZ, 0x34E0
0034DC  23F484     MOV #0x3F48, W4
0034DE  370104     BRA 0x36E8
487:               	if(TempConv == 27)	return 16650; 
0034E0  78021E     MOV [W14], W4
0034E2  520FFB     SUB W4, #0x1B, [W15]
0034E4  3A0002     BRA NZ, 0x34EA
0034E6  2410A4     MOV #0x410A, W4
0034E8  3700FF     BRA 0x36E8
488:               	if(TempConv == 28)	return 17100; 
0034EA  78021E     MOV [W14], W4
0034EC  520FFC     SUB W4, #0x1C, [W15]
0034EE  3A0002     BRA NZ, 0x34F4
0034F0  242CC4     MOV #0x42CC, W4
0034F2  3700FA     BRA 0x36E8
489:               	if(TempConv == 29)	return 17550; 
0034F4  78021E     MOV [W14], W4
0034F6  520FFD     SUB W4, #0x1D, [W15]
0034F8  3A0002     BRA NZ, 0x34FE
0034FA  2448E4     MOV #0x448E, W4
0034FC  3700F5     BRA 0x36E8
490:               	if(TempConv == 30)	return 18000; 
0034FE  78021E     MOV [W14], W4
003500  520FFE     SUB W4, #0x1E, [W15]
003502  3A0002     BRA NZ, 0x3508
003504  246504     MOV #0x4650, W4
003506  3700F0     BRA 0x36E8
491:               	if(TempConv == 31)	return 18500; 
003508  78021E     MOV [W14], W4
00350A  520FFF     SUB W4, #0x1F, [W15]
00350C  3A0002     BRA NZ, 0x3512
00350E  248444     MOV #0x4844, W4
003510  3700EB     BRA 0x36E8
492:               	if(TempConv == 32)	return 19000; 
003512  200204     MOV #0x20, W4
003514  78029E     MOV [W14], W5
003516  528F84     SUB W5, W4, [W15]
003518  3A0002     BRA NZ, 0x351E
00351A  24A384     MOV #0x4A38, W4
00351C  3700E5     BRA 0x36E8
493:               	if(TempConv == 33)	return 19500;
00351E  200214     MOV #0x21, W4
003520  78029E     MOV [W14], W5
003522  528F84     SUB W5, W4, [W15]
003524  3A0002     BRA NZ, 0x352A
003526  24C2C4     MOV #0x4C2C, W4
003528  3700DF     BRA 0x36E8
494:               	if(TempConv == 34)	return 20000;
00352A  200224     MOV #0x22, W4
00352C  78029E     MOV [W14], W5
00352E  528F84     SUB W5, W4, [W15]
003530  3A0002     BRA NZ, 0x3536
003532  24E204     MOV #0x4E20, W4
003534  3700D9     BRA 0x36E8
495:               	if(TempConv == 35)	return 20500;
003536  200234     MOV #0x23, W4
003538  78029E     MOV [W14], W5
00353A  528F84     SUB W5, W4, [W15]
00353C  3A0002     BRA NZ, 0x3542
00353E  250144     MOV #0x5014, W4
003540  3700D3     BRA 0x36E8
496:               	if(TempConv == 36)	return 21000;
003542  200244     MOV #0x24, W4
003544  78029E     MOV [W14], W5
003546  528F84     SUB W5, W4, [W15]
003548  3A0002     BRA NZ, 0x354E
00354A  252084     MOV #0x5208, W4
00354C  3700CD     BRA 0x36E8
497:               	if(TempConv == 37)	return 21500;
00354E  200254     MOV #0x25, W4
003550  78029E     MOV [W14], W5
003552  528F84     SUB W5, W4, [W15]
003554  3A0002     BRA NZ, 0x355A
003556  253FC4     MOV #0x53FC, W4
003558  3700C7     BRA 0x36E8
498:               	if(TempConv == 38)	return 22000;
00355A  200264     MOV #0x26, W4
00355C  78029E     MOV [W14], W5
00355E  528F84     SUB W5, W4, [W15]
003560  3A0002     BRA NZ, 0x3566
003562  255F04     MOV #0x55F0, W4
003564  3700C1     BRA 0x36E8
499:               	if(TempConv == 39)	return 22500;
003566  200274     MOV #0x27, W4
003568  78029E     MOV [W14], W5
00356A  528F84     SUB W5, W4, [W15]
00356C  3A0002     BRA NZ, 0x3572
00356E  257E44     MOV #0x57E4, W4
003570  3700BB     BRA 0x36E8
500:               	if(TempConv == 40)	return 23000;
003572  200284     MOV #0x28, W4
003574  78029E     MOV [W14], W5
003576  528F84     SUB W5, W4, [W15]
003578  3A0002     BRA NZ, 0x357E
00357A  259D84     MOV #0x59D8, W4
00357C  3700B5     BRA 0x36E8
501:               	if(TempConv == 41)	return 23700;
00357E  200294     MOV #0x29, W4
003580  78029E     MOV [W14], W5
003582  528F84     SUB W5, W4, [W15]
003584  3A0002     BRA NZ, 0x358A
003586  25C944     MOV #0x5C94, W4
003588  3700AF     BRA 0x36E8
502:               	if(TempConv == 42)	return 24400;
00358A  2002A4     MOV #0x2A, W4
00358C  78029E     MOV [W14], W5
00358E  528F84     SUB W5, W4, [W15]
003590  3A0002     BRA NZ, 0x3596
003592  25F504     MOV #0x5F50, W4
003594  3700A9     BRA 0x36E8
503:               	if(TempConv == 43)	return 25100;
003596  2002B4     MOV #0x2B, W4
003598  78029E     MOV [W14], W5
00359A  528F84     SUB W5, W4, [W15]
00359C  3A0002     BRA NZ, 0x35A2
00359E  2620C4     MOV #0x620C, W4
0035A0  3700A3     BRA 0x36E8
504:               	if(TempConv == 44)	return 25800;
0035A2  2002C4     MOV #0x2C, W4
0035A4  78029E     MOV [W14], W5
0035A6  528F84     SUB W5, W4, [W15]
0035A8  3A0002     BRA NZ, 0x35AE
0035AA  264C84     MOV #0x64C8, W4
0035AC  37009D     BRA 0x36E8
505:               	if(TempConv == 45)	return 26500;
0035AE  2002D4     MOV #0x2D, W4
0035B0  78029E     MOV [W14], W5
0035B2  528F84     SUB W5, W4, [W15]
0035B4  3A0002     BRA NZ, 0x35BA
0035B6  267844     MOV #0x6784, W4
0035B8  370097     BRA 0x36E8
506:               	if(TempConv == 46)	return 27200;
0035BA  2002E4     MOV #0x2E, W4
0035BC  78029E     MOV [W14], W5
0035BE  528F84     SUB W5, W4, [W15]
0035C0  3A0002     BRA NZ, 0x35C6
0035C2  26A404     MOV #0x6A40, W4
0035C4  370091     BRA 0x36E8
507:               	if(TempConv == 47)	return 27900;
0035C6  2002F4     MOV #0x2F, W4
0035C8  78029E     MOV [W14], W5
0035CA  528F84     SUB W5, W4, [W15]
0035CC  3A0002     BRA NZ, 0x35D2
0035CE  26CFC4     MOV #0x6CFC, W4
0035D0  37008B     BRA 0x36E8
508:               	if(TempConv == 48)	return 28600;
0035D2  200304     MOV #0x30, W4
0035D4  78029E     MOV [W14], W5
0035D6  528F84     SUB W5, W4, [W15]
0035D8  3A0002     BRA NZ, 0x35DE
0035DA  26FB84     MOV #0x6FB8, W4
0035DC  370085     BRA 0x36E8
509:               	if(TempConv == 49)	return 29300;
0035DE  200314     MOV #0x31, W4
0035E0  78029E     MOV [W14], W5
0035E2  528F84     SUB W5, W4, [W15]
0035E4  3A0002     BRA NZ, 0x35EA
0035E6  272744     MOV #0x7274, W4
0035E8  37007F     BRA 0x36E8
510:               	if(TempConv == 50)	return 30000;
0035EA  200324     MOV #0x32, W4
0035EC  78029E     MOV [W14], W5
0035EE  528F84     SUB W5, W4, [W15]
0035F0  3A0002     BRA NZ, 0x35F6
0035F2  275304     MOV #0x7530, W4
0035F4  370079     BRA 0x36E8
511:               	if(TempConv == 51)	return 30830;
0035F6  200334     MOV #0x33, W4
0035F8  78029E     MOV [W14], W5
0035FA  528F84     SUB W5, W4, [W15]
0035FC  3A0002     BRA NZ, 0x3602
0035FE  2786E4     MOV #0x786E, W4
003600  370073     BRA 0x36E8
512:               	if(TempConv == 52)	return 31660;
003602  200344     MOV #0x34, W4
003604  78029E     MOV [W14], W5
003606  528F84     SUB W5, W4, [W15]
003608  3A0002     BRA NZ, 0x360E
00360A  27BAC4     MOV #0x7BAC, W4
00360C  37006D     BRA 0x36E8
513:               	if(TempConv == 53)	return 32490;
00360E  200354     MOV #0x35, W4
003610  78029E     MOV [W14], W5
003612  528F84     SUB W5, W4, [W15]
003614  3A0002     BRA NZ, 0x361A
003616  27EEA4     MOV #0x7EEA, W4
003618  370067     BRA 0x36E8
514:               	if(TempConv == 54)	return 33320;
00361A  200364     MOV #0x36, W4
00361C  78029E     MOV [W14], W5
00361E  528F84     SUB W5, W4, [W15]
003620  3A0002     BRA NZ, 0x3626
003622  282284     MOV #0x8228, W4
003624  370061     BRA 0x36E8
515:               	if(TempConv == 55)	return 34150;
003626  200374     MOV #0x37, W4
003628  78029E     MOV [W14], W5
00362A  528F84     SUB W5, W4, [W15]
00362C  3A0002     BRA NZ, 0x3632
00362E  285664     MOV #0x8566, W4
003630  37005B     BRA 0x36E8
516:               	if(TempConv == 56)	return 34980;
003632  200384     MOV #0x38, W4
003634  78029E     MOV [W14], W5
003636  528F84     SUB W5, W4, [W15]
003638  3A0002     BRA NZ, 0x363E
00363A  288A44     MOV #0x88A4, W4
00363C  370055     BRA 0x36E8
517:               	if(TempConv == 57)	return 35810;
00363E  200394     MOV #0x39, W4
003640  78029E     MOV [W14], W5
003642  528F84     SUB W5, W4, [W15]
003644  3A0002     BRA NZ, 0x364A
003646  28BE24     MOV #0x8BE2, W4
003648  37004F     BRA 0x36E8
518:               	if(TempConv == 58)	return 36640;
00364A  2003A4     MOV #0x3A, W4
00364C  78029E     MOV [W14], W5
00364E  528F84     SUB W5, W4, [W15]
003650  3A0002     BRA NZ, 0x3656
003652  28F204     MOV #0x8F20, W4
003654  370049     BRA 0x36E8
519:               	if(TempConv == 59)	return 37470;
003656  2003B4     MOV #0x3B, W4
003658  78029E     MOV [W14], W5
00365A  528F84     SUB W5, W4, [W15]
00365C  3A0002     BRA NZ, 0x3662
00365E  2925E4     MOV #0x925E, W4
003660  370043     BRA 0x36E8
520:               	if(TempConv == 60)	return 38300;
003662  2003C4     MOV #0x3C, W4
003664  78029E     MOV [W14], W5
003666  528F84     SUB W5, W4, [W15]
003668  3A0002     BRA NZ, 0x366E
00366A  2959C4     MOV #0x959C, W4
00366C  37003D     BRA 0x36E8
521:               	if(TempConv == 61)	return 39130;
00366E  2003D4     MOV #0x3D, W4
003670  78029E     MOV [W14], W5
003672  528F84     SUB W5, W4, [W15]
003674  3A0002     BRA NZ, 0x367A
003676  298DA4     MOV #0x98DA, W4
003678  370037     BRA 0x36E8
522:               	if(TempConv == 62)	return 40000;
00367A  2003E4     MOV #0x3E, W4
00367C  78029E     MOV [W14], W5
00367E  528F84     SUB W5, W4, [W15]
003680  3A0002     BRA NZ, 0x3686
003682  29C404     MOV #0x9C40, W4
003684  370031     BRA 0x36E8
523:               	if(TempConv == 63)	return 40870;
003686  2003F4     MOV #0x3F, W4
003688  78029E     MOV [W14], W5
00368A  528F84     SUB W5, W4, [W15]
00368C  3A0002     BRA NZ, 0x3692
00368E  29FA64     MOV #0x9FA6, W4
003690  37002B     BRA 0x36E8
524:               	if(TempConv == 64)	return 41740;
003692  200404     MOV #0x40, W4
003694  78029E     MOV [W14], W5
003696  528F84     SUB W5, W4, [W15]
003698  3A0002     BRA NZ, 0x369E
00369A  2A30C4     MOV #0xA30C, W4
00369C  370025     BRA 0x36E8
525:               	if(TempConv == 65)	return 42610;
00369E  200414     MOV #0x41, W4
0036A0  78029E     MOV [W14], W5
0036A2  528F84     SUB W5, W4, [W15]
0036A4  3A0002     BRA NZ, 0x36AA
0036A6  2A6724     MOV #0xA672, W4
0036A8  37001F     BRA 0x36E8
526:               	if(TempConv == 66)	return 43480;
0036AA  200424     MOV #0x42, W4
0036AC  78029E     MOV [W14], W5
0036AE  528F84     SUB W5, W4, [W15]
0036B0  3A0002     BRA NZ, 0x36B6
0036B2  2A9D84     MOV #0xA9D8, W4
0036B4  370019     BRA 0x36E8
527:               	if(TempConv == 67)	return 44350;
0036B6  200434     MOV #0x43, W4
0036B8  78029E     MOV [W14], W5
0036BA  528F84     SUB W5, W4, [W15]
0036BC  3A0002     BRA NZ, 0x36C2
0036BE  2AD3E4     MOV #0xAD3E, W4
0036C0  370013     BRA 0x36E8
528:               	if(TempConv == 68)	return 45220;
0036C2  200444     MOV #0x44, W4
0036C4  78029E     MOV [W14], W5
0036C6  528F84     SUB W5, W4, [W15]
0036C8  3A0002     BRA NZ, 0x36CE
0036CA  2B0A44     MOV #0xB0A4, W4
0036CC  37000D     BRA 0x36E8
529:               	if(TempConv == 69)	return 46090;
0036CE  200454     MOV #0x45, W4
0036D0  78029E     MOV [W14], W5
0036D2  528F84     SUB W5, W4, [W15]
0036D4  3A0002     BRA NZ, 0x36DA
0036D6  2B40A4     MOV #0xB40A, W4
0036D8  370007     BRA 0x36E8
530:               	if(TempConv == 70)	return 47000;
0036DA  200464     MOV #0x46, W4
0036DC  78029E     MOV [W14], W5
0036DE  528F84     SUB W5, W4, [W15]
0036E0  3A0002     BRA NZ, 0x36E6
0036E2  2B7984     MOV #0xB798, W4
0036E4  370001     BRA 0x36E8
531:               	
532:               	return 0;
0036E6  EB0200     CLR W4
533:               	
534:               }
0036E8  780004     MOV W4, W0
0036EA  FA8000     ULNK
0036EC  060000     RETURN
535:               
536:               /*  *****************************************************************************************************************************
537:               	Aggiorno le variabili ElabValvola, in particolare l'abilitazione ed il fault.
538:               	Successivamente se è tutto ok e deve lavorare mi calcolo la temperatura di evaporazione della batteria
539:               	***************************************************************************************************************************** */
540:               void TempEvaporazione(void)
541:               {
0036EE  FA0004     LNK #0x4
542:               	int AppoggioCalcolo = 0;
0036F0  EB0200     CLR W4
0036F2  780F04     MOV W4, [W14]
543:               	int x = 0;
0036F4  EB0200     CLR W4
0036F6  980714     MOV W4, [W14+2]
544:               
545:               	if(Me.Function_Mode < CoreSlaveCaldo)
0036F8  805C24     MOV 0xB84, W4
0036FA  520FF0     SUB W4, #0x10, [W15]
0036FC  3C004D     BRA GT, 0x3798
546:               	{
547:               		switch(Me.Function_Mode)
0036FE  805C24     MOV 0xB84, W4
003700  520FE4     SUB W4, #0x4, [W15]
003702  320025     BRA Z, 0x374E
003704  520FE8     SUB W4, #0x8, [W15]
003706  3A0048     BRA NZ, 0x3798
548:               		{
549:               			case CoreRaffrescamento:		// Freddo Condizionamento
550:               				if(Me.Temp_Amb > (Me.SP + Freddo_Ist_SP))
003708  805B65     MOV Me, W5
00370A  805BC4     MOV 0xB78, W4
00370C  B00644     ADD #0x64, W4
00370E  528F84     SUB W5, W4, [W15]
003710  340003     BRA LE, 0x3718
551:               					Me.Evap_Temp = Freddo_TempBatt_MaxPwr;
003712  2FE0C4     MOV #0xFE0C, W4
003714  885BF4     MOV W4, 0xB7E
552:               				else
553:               				{	if(Me.Temp_Amb < (Me.SP - Freddo_Ist_SP))
003718  805B65     MOV Me, W5
00371A  805BC4     MOV 0xB78, W4
00371C  B10644     SUB #0x64, W4
00371E  528F84     SUB W5, W4, [W15]
003720  3D0004     BRA GE, 0x372A
554:               						Me.Evap_Temp = Me.SP - Freddo_OffSetBatt_MinPwr;
003722  805BC4     MOV 0xB78, W4
003724  B11F44     SUB #0x1F4, W4
003726  885BF4     MOV W4, 0xB7E
555:               					else
556:               					{	x = ((Me.SP-Freddo_OffSetBatt_MinPwr) - Freddo_TempBatt_MaxPwr) /(Freddo_Ist_SP*2);
00372A  805BC5     MOV 0xB78, W5
00372C  200C84     MOV #0xC8, W4
00372E  090011     REPEAT #0x11
003730  D80284     DIV.SW W5, W4
003732  780200     MOV W0, W4
003734  980714     MOV W4, [W14+2]
557:               						AppoggioCalcolo = (Me.SP + Freddo_Ist_SP) - Me.Temp_Amb;
003736  805BC4     MOV 0xB78, W4
003738  200645     MOV #0x64, W5
00373A  428284     ADD W5, W4, W5
00373C  805B64     MOV Me, W4
00373E  528F04     SUB W5, W4, [W14]
558:               						Me.Evap_Temp = Freddo_TempBatt_MaxPwr + (AppoggioCalcolo*x);
003740  78029E     MOV [W14], W5
003742  90021E     MOV [W14+2], W4
003744  B9AA04     MUL.SS W5, W4, W4
003746  780204     MOV W4, W4
003748  B11F44     SUB #0x1F4, W4
00374A  885BF4     MOV W4, 0xB7E
559:               					}
560:               				}
561:               				break;
003716  370040     BRA 0x3798
003728  370037     BRA 0x3798
00374C  370025     BRA 0x3798
562:               	
563:               			case CoreRiscaldamento:			// Caldo Riscaldamento
564:               				if(Me.Temp_Amb < (Me.SP - Caldo_Ist_SP))
00374E  805B65     MOV Me, W5
003750  805BC4     MOV 0xB78, W4
003752  B10C84     SUB #0xC8, W4
003754  528F84     SUB W5, W4, [W15]
003756  3D0003     BRA GE, 0x375E
565:               					Me.Evap_Temp = Caldo_TempBatt_MaxPwr;
003758  211624     MOV #0x1162, W4
00375A  885BF4     MOV W4, 0xB7E
566:               				else
567:               				{	if(Me.Temp_Amb > (Me.SP + Caldo_Ist_SP))
00375E  805B65     MOV Me, W5
003760  805BC4     MOV 0xB78, W4
003762  B00C84     ADD #0xC8, W4
003764  528F84     SUB W5, W4, [W15]
003766  340003     BRA LE, 0x376E
568:               						Me.Evap_Temp = Me.SP + Caldo_OffSetBatt_MinPwr;
003768  805BC4     MOV 0xB78, W4
00376A  885BF4     MOV W4, 0xB7E
569:               					else
570:               					{	x = (Caldo_TempBatt_MaxPwr - (Me.SP+Caldo_OffSetBatt_MinPwr)) /(Caldo_Ist_SP*2);
00376E  805BC4     MOV 0xB78, W4
003770  211625     MOV #0x1162, W5
003772  528284     SUB W5, W4, W5
003774  201904     MOV #0x190, W4
003776  090011     REPEAT #0x11
003778  D80284     DIV.SW W5, W4
00377A  780200     MOV W0, W4
00377C  980714     MOV W4, [W14+2]
571:               						AppoggioCalcolo = Me.Temp_Amb - (Me.SP - Caldo_Ist_SP);
00377E  805B65     MOV Me, W5
003780  805BC4     MOV 0xB78, W4
003782  200C86     MOV #0xC8, W6
003784  530204     SUB W6, W4, W4
003786  428F04     ADD W5, W4, [W14]
572:               						Me.Evap_Temp = Caldo_TempBatt_MaxPwr - (AppoggioCalcolo*x);
003788  78029E     MOV [W14], W5
00378A  90021E     MOV [W14+2], W4
00378C  B9AA04     MUL.SS W5, W4, W4
00378E  780204     MOV W4, W4
003790  211625     MOV #0x1162, W5
003792  528204     SUB W5, W4, W4
003794  885BF4     MOV W4, 0xB7E
573:               					}
574:               				}
575:               				break;
00375C  37001D     BRA 0x3798
00376C  370015     BRA 0x3798
003796  000000     NOP
576:               		}
577:               	}
578:               	Me.Evap_Press = TempToPressureGasR410A(Me.Evap_Temp); //PressureGas(Me.Evap_Temp);
003798  805BF4     MOV 0xB7E, W4
00379A  780004     MOV W4, W0
00379C  07FD95     RCALL TempToPressureGasR410A
00379E  780200     MOV W0, W4
0037A0  885C04     MOV W4, 0xB80
579:               }
0037A2  FA8000     ULNK
0037A4  060000     RETURN
580:               
581:               
582:               void PutStringToBUS2(int Val1, int Val2, int Val3, int Val4, int Val5, int Val6)
583:               {
0037A6  FA0030     LNK #0x30
0037A8  981720     MOV W0, [W14+36]
0037AA  981731     MOV W1, [W14+38]
0037AC  981742     MOV W2, [W14+40]
0037AE  981753     MOV W3, [W14+42]
0037B0  981764     MOV W4, [W14+44]
0037B2  981775     MOV W5, [W14+46]
584:               	static int cnt = 0;
585:               	unsigned char txm[32];	
586:               	int n,x;				
587:               	
588:               	set_baudrateU2LoSpeed();		// Imposta Baud LowSpeed
0037B4  200674     MOV #0x67, W4
0037B6  8811C4     MOV W4, U2BRG
589:               	
590:               	cnt++;	
0037B8  807B04     MOV cnt, W4
0037BA  E80204     INC W4, W4
0037BC  887B04     MOV W4, cnt
591:               	if(cnt==1)	
0037BE  807B04     MOV cnt, W4
0037C0  520FE1     SUB W4, #0x1, [W15]
0037C2  3A0014     BRA NZ, 0x37EC
592:               	{	
593:               		n = sprintf(txm, "CLEARDATA\r\n");   
0037C4  470264     ADD W14, #0x4, W4
0037C6  2000C2     MOV #0xC, W2
0037C8  2927E1     MOV #0x927E, W1
0037CA  780004     MOV W4, W0
0037CC  07E7C2     RCALL _memcpy
0037CE  2000B4     MOV #0xB, W4
0037D0  980714     MOV W4, [W14+2]
594:               		for(x=0; x<n; x++) putch2(txm[x]);           
0037D2  EB0200     CLR W4
0037D4  780F04     MOV W4, [W14]
0037D6  370006     BRA 0x37E4
0037D8  470264     ADD W14, #0x4, W4
0037DA  42021E     ADD W4, [W14], W4
0037DC  784214     MOV.B [W4], W4
0037DE  784004     MOV.B W4, W0
0037E0  072A01     RCALL putch2
0037E2  E80F1E     INC [W14], [W14]
0037E4  90021E     MOV [W14+2], W4
0037E6  78029E     MOV [W14], W5
0037E8  528F84     SUB W5, W4, [W15]
0037EA  35FFF6     BRA LT, 0x37D8
595:               
596:                  	
597:               	}
598:               	n = sprintf(txm, "DATA,");
0037EC  470264     ADD W14, #0x4, W4
0037EE  200062     MOV #0x6, W2
0037F0  2928A1     MOV #0x928A, W1
0037F2  780004     MOV W4, W0
0037F4  07E7AE     RCALL _memcpy
0037F6  200054     MOV #0x5, W4
0037F8  980714     MOV W4, [W14+2]
599:               	for(x=0; x<n; x++) putch2(txm[x]);   	
0037FA  EB0200     CLR W4
0037FC  780F04     MOV W4, [W14]
0037FE  370006     BRA 0x380C
003800  470264     ADD W14, #0x4, W4
003802  42021E     ADD W4, [W14], W4
003804  784214     MOV.B [W4], W4
003806  784004     MOV.B W4, W0
003808  0729ED     RCALL putch2
00380A  E80F1E     INC [W14], [W14]
00380C  90021E     MOV [W14+2], W4
00380E  78029E     MOV [W14], W5
003810  528F84     SUB W5, W4, [W15]
003812  35FFF6     BRA LT, 0x3800
600:               	n = sprintf(txm, "%i, ", Val1);
003814  470264     ADD W14, #0x4, W4
003816  9012AE     MOV [W14+36], W5
003818  781F85     MOV W5, [W15++]
00381A  292905     MOV #0x9290, W5
00381C  781F85     MOV W5, [W15++]
00381E  780004     MOV W4, W0
003820  07E79F     RCALL __sprintf_cdnopuxX
003822  5787E4     SUB W15, #0x4, W15
003824  780200     MOV W0, W4
003826  980714     MOV W4, [W14+2]
601:               	for(x=0; x<n; x++) putch2(txm[x]);   
003828  EB0200     CLR W4
00382A  780F04     MOV W4, [W14]
00382C  370006     BRA 0x383A
00382E  470264     ADD W14, #0x4, W4
003830  42021E     ADD W4, [W14], W4
003832  784214     MOV.B [W4], W4
003834  784004     MOV.B W4, W0
003836  0729D6     RCALL putch2
003838  E80F1E     INC [W14], [W14]
00383A  90021E     MOV [W14+2], W4
00383C  78029E     MOV [W14], W5
00383E  528F84     SUB W5, W4, [W15]
003840  35FFF6     BRA LT, 0x382E
602:               	n = sprintf(txm, "%i, ", Val2);
003842  470264     ADD W14, #0x4, W4
003844  9012BE     MOV [W14+38], W5
003846  781F85     MOV W5, [W15++]
003848  292905     MOV #0x9290, W5
00384A  781F85     MOV W5, [W15++]
00384C  780004     MOV W4, W0
00384E  07E788     RCALL __sprintf_cdnopuxX
003850  5787E4     SUB W15, #0x4, W15
003852  780200     MOV W0, W4
003854  980714     MOV W4, [W14+2]
603:               	for(x=0; x<n; x++) putch2(txm[x]);  
003856  EB0200     CLR W4
003858  780F04     MOV W4, [W14]
00385A  370006     BRA 0x3868
00385C  470264     ADD W14, #0x4, W4
00385E  42021E     ADD W4, [W14], W4
003860  784214     MOV.B [W4], W4
003862  784004     MOV.B W4, W0
003864  0729BF     RCALL putch2
003866  E80F1E     INC [W14], [W14]
003868  90021E     MOV [W14+2], W4
00386A  78029E     MOV [W14], W5
00386C  528F84     SUB W5, W4, [W15]
00386E  35FFF6     BRA LT, 0x385C
604:                	n = sprintf(txm, "%i, ", Val3);
003870  470264     ADD W14, #0x4, W4
003872  9012CE     MOV [W14+40], W5
003874  781F85     MOV W5, [W15++]
003876  292905     MOV #0x9290, W5
003878  781F85     MOV W5, [W15++]
00387A  780004     MOV W4, W0
00387C  07E771     RCALL __sprintf_cdnopuxX
00387E  5787E4     SUB W15, #0x4, W15
003880  780200     MOV W0, W4
003882  980714     MOV W4, [W14+2]
605:               	for(x=0; x<n; x++) putch2(txm[x]);    	
003884  EB0200     CLR W4
003886  780F04     MOV W4, [W14]
003888  370006     BRA 0x3896
00388A  470264     ADD W14, #0x4, W4
00388C  42021E     ADD W4, [W14], W4
00388E  784214     MOV.B [W4], W4
003890  784004     MOV.B W4, W0
003892  0729A8     RCALL putch2
003894  E80F1E     INC [W14], [W14]
003896  90021E     MOV [W14+2], W4
003898  78029E     MOV [W14], W5
00389A  528F84     SUB W5, W4, [W15]
00389C  35FFF6     BRA LT, 0x388A
606:                	n = sprintf(txm, "%i, ", Val4);
00389E  470264     ADD W14, #0x4, W4
0038A0  9012DE     MOV [W14+42], W5
0038A2  781F85     MOV W5, [W15++]
0038A4  292905     MOV #0x9290, W5
0038A6  781F85     MOV W5, [W15++]
0038A8  780004     MOV W4, W0
0038AA  07E75A     RCALL __sprintf_cdnopuxX
0038AC  5787E4     SUB W15, #0x4, W15
0038AE  780200     MOV W0, W4
0038B0  980714     MOV W4, [W14+2]
607:               	for(x=0; x<n; x++) putch2(txm[x]); 
0038B2  EB0200     CLR W4
0038B4  780F04     MOV W4, [W14]
0038B6  370006     BRA 0x38C4
0038B8  470264     ADD W14, #0x4, W4
0038BA  42021E     ADD W4, [W14], W4
0038BC  784214     MOV.B [W4], W4
0038BE  784004     MOV.B W4, W0
0038C0  072991     RCALL putch2
0038C2  E80F1E     INC [W14], [W14]
0038C4  90021E     MOV [W14+2], W4
0038C6  78029E     MOV [W14], W5
0038C8  528F84     SUB W5, W4, [W15]
0038CA  35FFF6     BRA LT, 0x38B8
608:                	n = sprintf(txm, "%i, ", Val5);
0038CC  470264     ADD W14, #0x4, W4
0038CE  9012EE     MOV [W14+44], W5
0038D0  781F85     MOV W5, [W15++]
0038D2  292905     MOV #0x9290, W5
0038D4  781F85     MOV W5, [W15++]
0038D6  780004     MOV W4, W0
0038D8  07E743     RCALL __sprintf_cdnopuxX
0038DA  5787E4     SUB W15, #0x4, W15
0038DC  780200     MOV W0, W4
0038DE  980714     MOV W4, [W14+2]
609:               	for(x=0; x<n; x++) putch2(txm[x]);
0038E0  EB0200     CLR W4
0038E2  780F04     MOV W4, [W14]
0038E4  370006     BRA 0x38F2
0038E6  470264     ADD W14, #0x4, W4
0038E8  42021E     ADD W4, [W14], W4
0038EA  784214     MOV.B [W4], W4
0038EC  784004     MOV.B W4, W0
0038EE  07297A     RCALL putch2
0038F0  E80F1E     INC [W14], [W14]
0038F2  90021E     MOV [W14+2], W4
0038F4  78029E     MOV [W14], W5
0038F6  528F84     SUB W5, W4, [W15]
0038F8  35FFF6     BRA LT, 0x38E6
610:                	n = sprintf(txm, "%i, ", Val6);
0038FA  470264     ADD W14, #0x4, W4
0038FC  9012FE     MOV [W14+46], W5
0038FE  781F85     MOV W5, [W15++]
003900  292905     MOV #0x9290, W5
003902  781F85     MOV W5, [W15++]
003904  780004     MOV W4, W0
003906  07E72C     RCALL __sprintf_cdnopuxX
003908  5787E4     SUB W15, #0x4, W15
00390A  780200     MOV W0, W4
00390C  980714     MOV W4, [W14+2]
611:               	for(x=0; x<n; x++) putch2(txm[x]);    
00390E  EB0200     CLR W4
003910  780F04     MOV W4, [W14]
003912  370006     BRA 0x3920
003914  470264     ADD W14, #0x4, W4
003916  42021E     ADD W4, [W14], W4
003918  784214     MOV.B [W4], W4
00391A  784004     MOV.B W4, W0
00391C  072963     RCALL putch2
00391E  E80F1E     INC [W14], [W14]
003920  90021E     MOV [W14+2], W4
003922  78029E     MOV [W14], W5
003924  528F84     SUB W5, W4, [W15]
003926  35FFF6     BRA LT, 0x3914
612:                	n = sprintf(txm, "\r\n");
003928  470264     ADD W14, #0x4, W4
00392A  200032     MOV #0x3, W2
00392C  292951     MOV #0x9295, W1
00392E  780004     MOV W4, W0
003930  07E710     RCALL _memcpy
003932  200024     MOV #0x2, W4
003934  980714     MOV W4, [W14+2]
613:               	for(x=0; x<n; x++) putch2(txm[x]); 	
003936  EB0200     CLR W4
003938  780F04     MOV W4, [W14]
00393A  370006     BRA 0x3948
00393C  470264     ADD W14, #0x4, W4
00393E  42021E     ADD W4, [W14], W4
003940  784214     MOV.B [W4], W4
003942  784004     MOV.B W4, W0
003944  07294F     RCALL putch2
003946  E80F1E     INC [W14], [W14]
003948  90021E     MOV [W14+2], W4
00394A  78029E     MOV [W14], W5
00394C  528F84     SUB W5, W4, [W15]
00394E  35FFF6     BRA LT, 0x393C
614:               	
615:               	if(cnt==100)	
003950  807B05     MOV cnt, W5
003952  200644     MOV #0x64, W4
003954  528F84     SUB W5, W4, [W15]
003956  3A0016     BRA NZ, 0x3984
616:               	{
617:               		cnt=0;
003958  EB0200     CLR W4
00395A  887B04     MOV W4, cnt
618:               		for(x=0; x<n; x++) putch2(txm[x]);      			 
00395C  EB0200     CLR W4
00395E  780F04     MOV W4, [W14]
003960  370006     BRA 0x396E
003962  470264     ADD W14, #0x4, W4
003964  42021E     ADD W4, [W14], W4
003966  784214     MOV.B [W4], W4
003968  784004     MOV.B W4, W0
00396A  07293C     RCALL putch2
00396C  E80F1E     INC [W14], [W14]
00396E  90021E     MOV [W14+2], W4
003970  78029E     MOV [W14], W5
003972  528F84     SUB W5, W4, [W15]
003974  35FFF6     BRA LT, 0x3962
619:               		n = sprintf(txm, "ROW,SET,2\r\n");
003976  470264     ADD W14, #0x4, W4
003978  2000C2     MOV #0xC, W2
00397A  292981     MOV #0x9298, W1
00397C  780004     MOV W4, W0
00397E  07E6E9     RCALL _memcpy
003980  2000B4     MOV #0xB, W4
003982  980714     MOV W4, [W14+2]
620:               	}	
621:               
622:               	set_baudrateU2HiSpeed();		// Ripristina Baud HiSpeed	
003984  200444     MOV #0x44, W4
003986  8811C4     MOV W4, U2BRG
623:               	
624:               }
003988  FA8000     ULNK
00398A  060000     RETURN
625:               
626:               /*  *****************************************************************************************************************************
627:               	Regolo l'apertura della valvola in base alle informazioni di feedBeak, per mantenere la temperatura di evaporazione corretta
628:               	***************************************************************************************************************************** */
629:               void RegolaValvola(void)
630:               {	
00398C  FA0008     LNK #0x8
00398E  781F88     MOV W8, [W15++]
631:               	int Errore = 0;
003990  EB0200     CLR W4
003992  780F04     MOV W4, [W14]
632:               	int ErrIniet = 0;		// errore sul SP di iniezione (tra valvola e batteria
003994  EB0200     CLR W4
003996  980714     MOV W4, [W14+2]
633:               	int ErrSurr = 0;		// errore del surriscaldamento
003998  EB0200     CLR W4
00399A  980724     MOV W4, [W14+4]
634:               	int Prop = 0;			// coefficente proporzionale di variazione della valvola
00399C  EB0200     CLR W4
00399E  980734     MOV W4, [W14+6]
635:               	static char ErrCompFlag=0;
636:               	static int TempExpValve_Req=0;
637:               	static int LimiteMinCaldo=0;
638:               	static int LimiteMaxCaldo=0;
639:               	static int LimiteMinFreddo=0;
640:               	static int LimiteMaxFreddo=0;
641:               	//static int ConsideraPress=0;
642:               	//static int T_Surriscaldamento_Gas_Freddo=0;
643:               
644:               
645:               	//goto barbatrucco;
646:               	
647:               	// Gestione originale Valvola espansione
648:               	
649:               	TimerTestEEV.Enable = EngineBox.Test.EEV_Go & EngineBox.Test.EEV_Req;
0039A0  805AA4     MOV 0xB54, W4
0039A2  DE2242     LSR W4, #2, W4
0039A4  624261     AND.B W4, #0x1, W4
0039A6  784284     MOV.B W4, W5
0039A8  805AA4     MOV 0xB54, W4
0039AA  D10204     LSR W4, W4
0039AC  624261     AND.B W4, #0x1, W4
0039AE  62C204     AND.B W5, W4, W4
0039B0  624261     AND.B W4, #0x1, W4
0039B2  FB8204     ZE W4, W4
0039B4  620261     AND W4, #0x1, W4
0039B6  8058F6     MOV 0xB1E, W6
0039B8  2FFFE5     MOV #0xFFFE, W5
0039BA  630285     AND W6, W5, W5
0039BC  720205     IOR W4, W5, W4
0039BE  8858F4     MOV W4, 0xB1E
650:               
651:               	if(!EngineBox.Test.EEV_Req)
0039C0  805AA4     MOV 0xB54, W4
0039C2  620262     AND W4, #0x2, W4
0039C4  520FE0     SUB W4, #0x0, [W15]
0039C6  3A0001     BRA NZ, 0x39CA
652:               		Me.Error.EEV_Test_End = 0;						// azzero il flag di fine test EEV
0039C8  A9EBAC     BCLR 0xBAC, #7
653:               
654:               	if(!EngineBox.Error.CompressorHi && !EngineBox.Error.CompressorLo && !EngineBox.Error.Pressure_Hi)
0039CA  805A84     MOV 0xB50, W4
0039CC  620261     AND W4, #0x1, W4
0039CE  520FE0     SUB W4, #0x0, [W15]
0039D0  3A000D     BRA NZ, 0x39EC
0039D2  805A84     MOV 0xB50, W4
0039D4  620262     AND W4, #0x2, W4
0039D6  520FE0     SUB W4, #0x0, [W15]
0039D8  3A0009     BRA NZ, 0x39EC
0039DA  805A85     MOV 0xB50, W5
0039DC  200404     MOV #0x40, W4
0039DE  628204     AND W5, W4, W4
0039E0  520FE0     SUB W4, #0x0, [W15]
0039E2  3A0004     BRA NZ, 0x39EC
655:               		ErrCompFlag=0;	
0039E4  EB4200     CLR.B W4
0039E6  784304     MOV.B W4, W6
0039E8  20F545     MOV #0xF54, W5
0039EA  784A86     MOV.B W6, [W5]
656:               
657:               	if(EngineBox.Test.EEV_Req)							// se ho richiesto il test delle valvole
0039EC  805AA4     MOV 0xB54, W4
0039EE  620262     AND W4, #0x2, W4
0039F0  520FE0     SUB W4, #0x0, [W15]
0039F2  320057     BRA Z, 0x3AA2
658:               	{	if(EngineBox.Test.EEV_Go)						// verifico se devo partire
0039F4  805AA4     MOV 0xB54, W4
0039F6  620264     AND W4, #0x4, W4
0039F8  520FE0     SUB W4, #0x0, [W15]
0039FA  32004C     BRA Z, 0x3A94
659:               		{	if(CyclTestEEV < NumeroCicliTestEEV)
0039FC  20B264     MOV #0xB26, W4
0039FE  784214     MOV.B [W4], W4
003A00  524FE4     SUB.B W4, #0x4, [W15]
003A02  3C020E     BRA GT, 0x3E20
660:               			{	if((Me.ExpValve_Req == ValvolaChiusa) & TimerTestEEV.TimeOut)	// attendo 2 secondi che si richiuda la valvola e va in pressione
003A04  805CB4     MOV 0xB96, W4
003A06  A7F004     BTSC W4, #15
003A08  EA0204     NEG W4, W4
003A0A  E90204     DEC W4, W4
003A0C  DE224F     LSR W4, #15, W4
003A0E  8058F5     MOV 0xB1E, W5
003A10  D10285     LSR W5, W5
003A12  62C2E1     AND.B W5, #0x1, W5
003A14  FB8285     ZE W5, W5
003A16  620205     AND W4, W5, W4
003A18  520FE0     SUB W4, #0x0, [W15]
003A1A  320007     BRA Z, 0x3A2A
661:               				{	TimerTestEEV.Time = WaitOpenTime;	// imposto il timer per l'apertura
003A1C  200144     MOV #0x14, W4
003A1E  8858E4     MOV W4, 0xB1C
662:               					TimerTestEEV.Value = 0;
003A20  EB0200     CLR W4
003A22  8858D4     MOV W4, TimerTestEEV
663:               					TimerTestEEV.TimeOut = 0;
003A24  A92B1E     BCLR 0xB1E, #1
664:               					Me.ExpValve_Req = ValvolaAperta;	// apro la valvola
003A26  203C04     MOV #0x3C0, W4
003A28  885CB4     MOV W4, 0xB96
665:               				}
666:               				if((Me.ExpValve_Req == ValvolaAperta) & TimerTestEEV.TimeOut)	// dopo 10 sec che la valovla è spalancata
003A2A  805CB5     MOV 0xB96, W5
003A2C  203C04     MOV #0x3C0, W4
003A2E  6A8204     XOR W5, W4, W4
003A30  A7F004     BTSC W4, #15
003A32  EA0204     NEG W4, W4
003A34  E90204     DEC W4, W4
003A36  DE224F     LSR W4, #15, W4
003A38  8058F5     MOV 0xB1E, W5
003A3A  D10285     LSR W5, W5
003A3C  62C2E1     AND.B W5, #0x1, W5
003A3E  FB8285     ZE W5, W5
003A40  620205     AND W4, W5, W4
003A42  520FE0     SUB W4, #0x0, [W15]
003A44  3201ED     BRA Z, 0x3E20
667:               				{	Me.Error.EEV_Close = ((Me.Temp_Big - SogliaGusatoEEV) > Me.Temp_Small);
003A46  805B84     MOV 0xB70, W4
003A48  2FC186     MOV #0xFC18, W6
003A4A  430304     ADD W6, W4, W6
003A4C  805B95     MOV 0xB72, W5
003A4E  B3C014     MOV.B #0x1, W4
003A50  530F85     SUB W6, W5, [W15]
003A52  3C0001     BRA GT, 0x3A56
003A54  EB4200     CLR.B W4
003A56  FB8204     ZE W4, W4
003A58  620261     AND W4, #0x1, W4
003A5A  DD2243     SL W4, #3, W4
003A5C  805D66     MOV 0xBAC, W6
003A5E  2FFF75     MOV #0xFFF7, W5
003A60  630285     AND W6, W5, W5
003A62  720205     IOR W4, W5, W4
003A64  885D64     MOV W4, 0xBAC
668:               					if(!Me.Error.EEV_Close)				// se non è in errore salto il ciclo di controllo
003A66  805D64     MOV 0xBAC, W4
003A68  620268     AND W4, #0x8, W4
003A6A  520FE0     SUB W4, #0x0, [W15]
003A6C  3A0005     BRA NZ, 0x3A78
669:               					{	CyclTestEEV = NumeroCicliTestEEV;
003A6E  B3C054     MOV.B #0x5, W4
003A70  784304     MOV.B W4, W6
003A72  20B265     MOV #0xB26, W5
003A74  784A86     MOV.B W6, [W5]
670:               						Me.Error.EEV_Test_End =1;		// imposto lo stato di fine ciclo di errore
003A76  A8EBAC     BSET 0xBAC, #7
671:               					}
672:               					TimerTestEEV.Time = WaitCloseTime;	// imposto il timer per la chiusura
003A78  2000A4     MOV #0xA, W4
003A7A  8858E4     MOV W4, 0xB1C
673:               					TimerTestEEV.Value = 0;
003A7C  EB0200     CLR W4
003A7E  8858D4     MOV W4, TimerTestEEV
674:               					TimerTestEEV.TimeOut = 0;
003A80  A92B1E     BCLR 0xB1E, #1
675:               					Me.ExpValve_Req = ValvolaChiusa;	// chiuso la valvola
003A82  EB0200     CLR W4
003A84  885CB4     MOV W4, 0xB96
676:               					CyclTestEEV +=1;					// incremento il numero del ciclo
003A86  20B264     MOV #0xB26, W4
003A88  784214     MOV.B [W4], W4
003A8A  E84204     INC.B W4, W4
003A8C  784304     MOV.B W4, W6
003A8E  20B265     MOV #0xB26, W5
003A90  784A86     MOV.B W6, [W5]
003A92  3701C6     BRA 0x3E20
677:               				}
678:               			}
679:               		}
680:               		else											// o se sono nella fase di prestart
681:               		{	Me.ExpValve_Req = ValvolaChiusa;			// nel caso valvole chiuse
003A94  EB0200     CLR W4
003A96  885CB4     MOV W4, 0xB96
682:               			CyclTestEEV = 0;							// resetto il contatore con i cicli di errore
003A98  EB4200     CLR.B W4
003A9A  784304     MOV.B W4, W6
003A9C  20B265     MOV #0xB26, W5
003A9E  784A86     MOV.B W6, [W5]
003AA0  3701BF     BRA 0x3E20
683:               		}
684:               	}
685:               	else if(EngineBox.Test.FluxReq)					// in caso di test di flusso del condensatore
003AA2  805AA4     MOV 0xB54, W4
003AA4  620261     AND W4, #0x1, W4
003AA6  520FE0     SUB W4, #0x0, [W15]
003AA8  320003     BRA Z, 0x3AB0
686:               		Me.ExpValve_Req = EEV_FluxTest;					// imposto la valvola al 50%
003AAA  200644     MOV #0x64, W4
003AAC  885CB4     MOV W4, 0xB96
003AAE  3701B8     BRA 0x3E20
687:               	else if(EngineBox.Error.CondensatoreHi | EngineBox.Error.CondensatoreLo |
003AB0  805A84     MOV 0xB50, W4
003AB2  DE2242     LSR W4, #2, W4
003AB4  624261     AND.B W4, #0x1, W4
003AB6  FB8284     ZE W4, W5
003AB8  805A84     MOV 0xB50, W4
003ABA  DE2243     LSR W4, #3, W4
003ABC  624261     AND.B W4, #0x1, W4
003ABE  FB8204     ZE W4, W4
003AC0  720285     IOR W4, W5, W5
003AC8  FB8204     ZE W4, W4
003ACA  720285     IOR W4, W5, W5
003AFE  520FE0     SUB W4, #0x0, [W15]
003B00  320003     BRA Z, 0x3B08
688:               			EngineBox.Error.Gas_Recovery | EngineBox.Error.Pressure_Lo | /*EngineBox.Error.Pressure_Hi | */
003AC2  805A84     MOV 0xB50, W4
003AC4  DE2244     LSR W4, #4, W4
003AC6  624261     AND.B W4, #0x1, W4
003ACC  805A84     MOV 0xB50, W4
003ACE  DE2245     LSR W4, #5, W4
003AD0  624261     AND.B W4, #0x1, W4
003AD2  FB8204     ZE W4, W4
003AD4  720285     IOR W4, W5, W5
003ADC  FB8204     ZE W4, W4
003ADE  720285     IOR W4, W5, W5
689:               			EngineBox.PersErr.TermicaCompressore | EngineBox.PersErr.SeaWaterLo | EngineBox.PersErr.SeaWaterHi | 
003AD6  805A94     MOV 0xB52, W4
003AD8  DE2246     LSR W4, #6, W4
003ADA  624261     AND.B W4, #0x1, W4
003AE0  805A94     MOV 0xB52, W4
003AE2  DE2247     LSR W4, #7, W4
003AE4  624261     AND.B W4, #0x1, W4
003AE6  FB8204     ZE W4, W4
003AE8  720285     IOR W4, W5, W5
003AEA  805A94     MOV 0xB52, W4
003AEC  DE2248     LSR W4, #8, W4
003AEE  624261     AND.B W4, #0x1, W4
003AF0  FB8204     ZE W4, W4
003AF2  720285     IOR W4, W5, W5
003AFA  FB8204     ZE W4, W4
003AFC  720205     IOR W4, W5, W4
690:               			EngineBox.PersErr.CaricaRefrig)	// in caso di problema 
003AF4  805A94     MOV 0xB52, W4
003AF6  DE2249     LSR W4, #9, W4
003AF8  624261     AND.B W4, #0x1, W4
691:               			Me.ExpValve_Req = ValvolaAperta;	// spalanco completamente la valvola
003B02  203C04     MOV #0x3C0, W4
003B04  885CB4     MOV W4, 0xB96
003B06  37018C     BRA 0x3E20
692:               	else if((EngineBox.Error.CompressorHi | EngineBox.Error.CompressorLo | EngineBox.Error.Pressure_Hi) & !ErrCompFlag)
003B08  805A84     MOV 0xB50, W4
003B0A  784204     MOV.B W4, W4
003B0C  624261     AND.B W4, #0x1, W4
003B0E  FB8284     ZE W4, W5
003B10  805A84     MOV 0xB50, W4
003B12  D10204     LSR W4, W4
003B14  624261     AND.B W4, #0x1, W4
003B16  FB8204     ZE W4, W4
003B18  720285     IOR W4, W5, W5
003B1A  805A84     MOV 0xB50, W4
003B1C  DE2246     LSR W4, #6, W4
003B1E  624261     AND.B W4, #0x1, W4
003B20  FB8204     ZE W4, W4
003B22  720285     IOR W4, W5, W5
003B24  20F544     MOV #0xF54, W4
003B26  784214     MOV.B [W4], W4
003B28  FB8204     ZE W4, W4
003B2A  E90204     DEC W4, W4
003B2C  DE224F     LSR W4, #15, W4
003B2E  628204     AND W5, W4, W4
003B30  520FE0     SUB W4, #0x0, [W15]
003B32  320023     BRA Z, 0x3B7A
693:               	{
694:               		ErrCompFlag=1;	
003B34  B3C014     MOV.B #0x1, W4
003B36  784304     MOV.B W4, W6
003B38  20F545     MOV #0xF54, W5
003B3A  784A86     MOV.B W6, [W5]
695:               		if(EngineBox.Error.CompressorHi | EngineBox.Error.CompressorLo)
003B3C  805A84     MOV 0xB50, W4
003B3E  784204     MOV.B W4, W4
003B40  624261     AND.B W4, #0x1, W4
003B42  FB8284     ZE W4, W5
003B44  805A84     MOV 0xB50, W4
003B46  D10204     LSR W4, W4
003B48  624261     AND.B W4, #0x1, W4
003B4A  FB8204     ZE W4, W4
003B4C  720205     IOR W4, W5, W4
003B4E  520FE0     SUB W4, #0x0, [W15]
003B50  320003     BRA Z, 0x3B58
696:               			TempExpValve_Req = Me.ExpValve_Req + (ValvolaAperta*K_percErrValv/100);	
003B52  805CB4     MOV 0xB96, W4
003B54  B01204     ADD #0x120, W4
003B56  887AB4     MOV W4, TempExpValve_Req
697:               		if(EngineBox.Error.Pressure_Hi)
003B58  805A85     MOV 0xB50, W5
003B5A  200404     MOV #0x40, W4
003B5C  628204     AND W5, W4, W4
003B5E  520FE0     SUB W4, #0x0, [W15]
003B60  320003     BRA Z, 0x3B68
698:               			TempExpValve_Req = Me.ExpValve_Req + (ValvolaAperta*K_percErrValvPress/100);	
003B62  805CB4     MOV 0xB96, W4
003B64  52027F     SUB W4, #0x1F, W4
003B66  887AB4     MOV W4, TempExpValve_Req
699:               		
700:               		if(TempExpValve_Req>ValvolaAperta)
003B68  807AB5     MOV TempExpValve_Req, W5
003B6A  203C04     MOV #0x3C0, W4
003B6C  528F84     SUB W5, W4, [W15]
003B6E  340002     BRA LE, 0x3B74
701:               			TempExpValve_Req=ValvolaAperta;	//Se sforo limite valvola aperta correggo a limite
003B70  203C04     MOV #0x3C0, W4
003B72  887AB4     MOV W4, TempExpValve_Req
702:               
703:               		Me.ExpValve_Req = TempExpValve_Req;
003B74  807AB4     MOV TempExpValve_Req, W4
003B76  885CB4     MOV W4, 0xB96
003B78  370153     BRA 0x3E20
704:               	}
705:               	else if(EngineBox.Error.Recharge_Oil)	// Se avvio ciclo di recupero dell'olio (meno prioritario rispetto a tutti gli altri errori)
003B7A  805A85     MOV 0xB50, W5
003B7C  200804     MOV #0x80, W4
003B7E  628204     AND W5, W4, W4
003B80  520FE0     SUB W4, #0x0, [W15]
003B82  320003     BRA Z, 0x3B8A
706:               			Me.ExpValve_Req = ValvolaAperta;	// spalanco completamente la valvola			
003B84  203C04     MOV #0x3C0, W4
003B86  885CB4     MOV W4, 0xB96
003B88  37014B     BRA 0x3E20
707:               	else if((Me.Function_Mode < CoreManuale) && !(EngineBox.Error.CompressorHi | EngineBox.Error.CompressorLo | 
003B8A  805C24     MOV 0xB84, W4
003B8C  520FF2     SUB W4, #0x12, [W15]
003B8E  3C0148     BRA GT, 0x3E20
003B90  805A84     MOV 0xB50, W4
003B92  784204     MOV.B W4, W4
003B94  624261     AND.B W4, #0x1, W4
003B96  FB8284     ZE W4, W5
003B98  805A84     MOV 0xB50, W4
003B9A  D10204     LSR W4, W4
003B9C  624261     AND.B W4, #0x1, W4
003B9E  FB8204     ZE W4, W4
003BA0  720285     IOR W4, W5, W5
003BA8  FB8204     ZE W4, W4
003BAA  720285     IOR W4, W5, W5
003BF2  520FE0     SUB W4, #0x0, [W15]
003BF4  3A0115     BRA NZ, 0x3E20
708:               			EngineBox.Test.EEV_Req | EngineBox.Error.CondensatoreHi | EngineBox.Error.CondensatoreLo | 
003BA2  805AA4     MOV 0xB54, W4
003BA4  D10204     LSR W4, W4
003BA6  624261     AND.B W4, #0x1, W4
003BAC  805A84     MOV 0xB50, W4
003BAE  DE2242     LSR W4, #2, W4
003BB0  624261     AND.B W4, #0x1, W4
003BB2  FB8204     ZE W4, W4
003BB4  720285     IOR W4, W5, W5
003BB6  805A84     MOV 0xB50, W4
003BB8  DE2243     LSR W4, #3, W4
003BBA  624261     AND.B W4, #0x1, W4
003BBC  FB8204     ZE W4, W4
003BBE  720285     IOR W4, W5, W5
003BC6  FB8204     ZE W4, W4
003BC8  720285     IOR W4, W5, W5
709:               			EngineBox.Error.Gas_Recovery | EngineBox.PersErr.TermicaCompressore | EngineBox.PersErr.SeaWaterLo | 
003BC0  805A84     MOV 0xB50, W4
003BC2  DE2244     LSR W4, #4, W4
003BC4  624261     AND.B W4, #0x1, W4
003BCA  805A94     MOV 0xB52, W4
003BCC  DE2246     LSR W4, #6, W4
003BCE  624261     AND.B W4, #0x1, W4
003BD0  FB8204     ZE W4, W4
003BD2  720285     IOR W4, W5, W5
003BD4  805A94     MOV 0xB52, W4
003BD6  DE2247     LSR W4, #7, W4
003BD8  624261     AND.B W4, #0x1, W4
003BDA  FB8204     ZE W4, W4
003BDC  720285     IOR W4, W5, W5
003BE4  FB8204     ZE W4, W4
003BE6  720285     IOR W4, W5, W5
710:               			EngineBox.PersErr.SeaWaterHi | EngineBox.PersErr.CaricaRefrig))
003BDE  805A94     MOV 0xB52, W4
003BE0  DE2248     LSR W4, #8, W4
003BE2  624261     AND.B W4, #0x1, W4
003BE8  805A94     MOV 0xB52, W4
003BEA  DE2249     LSR W4, #9, W4
003BEC  624261     AND.B W4, #0x1, W4
003BEE  FB8204     ZE W4, W4
003BF0  720205     IOR W4, W5, W4
711:               	{	switch(EngineBox.FunctionMode)
003BF6  805A54     MOV 0xB4A, W4
003BF8  DEA2CF     ASR W4, #15, W5
003BFA  200066     MOV #0x6, W6
003BFC  200007     MOV #0x0, W7
003BFE  520F86     SUB W4, W6, [W15]
003C00  5A8F87     SUBB W5, W7, [W15]
003C02  3E010B     BRA GTU, 0x3E1A
003C04  016004     BRA W4
003C06  370006     BRA 0x3C14
003C08  3700F9     BRA 0x3DFC
003C0A  370004     BRA 0x3C14
003C0C  3700FA     BRA 0x3E02
003C0E  370002     BRA 0x3C14
003C10  3700FE     BRA 0x3E0E
003C12  370100     BRA 0x3E14
712:               		{
713:               			case EngineBox_Off:
714:               			case EngineBox_Freddo:
715:               			case EngineBox_Caldo:
716:               				switch(EngineBox.FunctionMode)
003C14  805A54     MOV 0xB4A, W4
003C16  520FE2     SUB W4, #0x2, [W15]
003C18  32009A     BRA Z, 0x3D4E
003C1A  520FE4     SUB W4, #0x4, [W15]
003C1C  320003     BRA Z, 0x3C24
003C1E  520FE0     SUB W4, #0x0, [W15]
003C20  3200E9     BRA Z, 0x3DF4
717:               				{
718:               					case EngineBox_Caldo:								// se il box motore sta riscaldando
719:               						if((Me.Function_Mode == CoreRiscaldamento) |
003C24  805C24     MOV 0xB84, W4
003C26  A22004     BTG W4, #2
003C28  A7F004     BTSC W4, #15
003C2A  EA0204     NEG W4, W4
003C2C  E90204     DEC W4, W4
003C2E  DE224F     LSR W4, #15, W4
003C30  784284     MOV.B W4, W5
003C40  72C204     IOR.B W5, W4, W4
003C42  524FE0     SUB.B W4, #0x0, [W15]
003C44  320081     BRA Z, 0x3D48
720:               							(Me.Function_Mode == CoreSlaveCaldo))		// e la camera chiede riscaldamento
003C32  805C24     MOV 0xB84, W4
003C34  6A0271     XOR W4, #0x11, W4
003C36  A7F004     BTSC W4, #15
003C38  EA0204     NEG W4, W4
003C3A  E90204     DEC W4, W4
003C3C  DE224F     LSR W4, #15, W4
003C3E  784204     MOV.B W4, W4
721:               						{
722:               							TimerExpValvola.Time = WaitExpValvolaCaldo;	// inizializzo il timer di regolazione alla velocità caldo
003C46  207D04     MOV #0x7D0, W4
003C48  887124     MOV W4, 0xE24
723:               							if(TimerExpValvola.TimeOut == 1)	// Esegue regolazione ogni xx sec??                                                  	
003C4A  807134     MOV 0xE26, W4
003C4C  620262     AND W4, #0x2, W4
003C4E  520FE0     SUB W4, #0x0, [W15]
003C50  32007D     BRA Z, 0x3D4C
724:               							{	                   
725:               								if(Me.Temp_AirOut < Me.Evap_Temp)
003C52  805B75     MOV 0xB6E, W5
003C54  805BF4     MOV 0xB7E, W4
003C56  528F84     SUB W5, W4, [W15]
003C58  3D0005     BRA GE, 0x3C64
726:               								{
727:               									LimiteMinCaldo	= AperturaMidCaldo;					
003C5A  200C84     MOV #0xC8, W4
003C5C  887AC4     MOV W4, LimiteMinCaldo
728:               									LimiteMaxCaldo	= AperturaMaxCaldo;
003C5E  203C04     MOV #0x3C0, W4
003C60  887AD4     MOV W4, LimiteMaxCaldo
003C62  370004     BRA 0x3C6C
729:               								}
730:               								else
731:               								{
732:               									LimiteMinCaldo	= AperturaMinCaldo;					
003C64  200644     MOV #0x64, W4
003C66  887AC4     MOV W4, LimiteMinCaldo
733:               									LimiteMaxCaldo	= AperturaMidCaldo;
003C68  200C84     MOV #0xC8, W4
003C6A  887AD4     MOV W4, LimiteMaxCaldo
734:               								}
735:               								if(Me.Temp_Amb < Me.SP)
003C6C  805B65     MOV Me, W5
003C6E  805BC4     MOV 0xB78, W4
003C70  528F84     SUB W5, W4, [W15]
003C72  3D0002     BRA GE, 0x3C78
736:               									LimiteMinCaldo	= AperturaMidCaldo;					
003C74  200C84     MOV #0xC8, W4
003C76  887AC4     MOV W4, LimiteMinCaldo
737:               	
738:               								Me.Setp_PressLiqP_Caldo = TempToPressureGasR410A(EngineBox.Temp_Acqua_Mare); //PressureGas(EngineBox.Temp_Acqua_Mare);	// Calcolo pressione di lavoro della valvola in base a temperatura acqua di mare secondo tbella conversione temperature / presisoni.
003C78  805974     MOV 0xB2E, W4
003C7A  780004     MOV W4, W0
003C7C  07FB25     RCALL TempToPressureGasR410A
003C7E  780200     MOV W0, W4
003C80  885C14     MOV W4, 0xB82
739:               								if(Me.Setp_PressLiqP_Caldo>K_Lim_Max_Press_Liq_Caldo) 				// Se la pressione del liquido calcolata supera il limite massimo consentito
003C82  805C15     MOV 0xB82, W5
003C84  227104     MOV #0x2710, W4
003C86  528F84     SUB W5, W4, [W15]
003C88  340002     BRA LE, 0x3C8E
740:               									Me.Setp_PressLiqP_Caldo=K_Lim_Max_Press_Liq_Caldo;				// correggo al limite
003C8A  227104     MOV #0x2710, W4
003C8C  885C14     MOV W4, 0xB82
741:               
742:               								if(Errore>0)	//Se errore >0
003C8E  78021E     MOV [W14], W4
003C90  520FE0     SUB W4, #0x0, [W15]
003C92  34002A     BRA LE, 0x3CE8
743:               								{
744:               									if(Errore>500)	//Se Errore >500 mBar
003C94  201F44     MOV #0x1F4, W4
003C96  78029E     MOV [W14], W5
003C98  528F84     SUB W5, W4, [W15]
003C9A  340006     BRA LE, 0x3CA8
745:               										Decrementa(&Me.ExpValve_Req, IncOutValvole, LimiteMinCaldo);		// Chiudo valvola fino a MIN per abbassare la pressione
003C9C  807AC4     MOV LimiteMinCaldo, W4
003C9E  780104     MOV W4, W2
003CA0  200011     MOV #0x1, W1
003CA2  20B960     MOV #0xB96, W0
003CA4  070F1F     RCALL Decrementa
003CA6  37004E     BRA 0x3D44
746:               									else
747:               									{
748:               										Errore = Me.Evap_Temp - Me.Temp_AirOut;
003CA8  805BF5     MOV 0xB7E, W5
003CAA  805B74     MOV 0xB6E, W4
003CAC  528F04     SUB W5, W4, [W14]
749:               										if(Errore>0)
003CAE  78021E     MOV [W14], W4
003CB0  520FE0     SUB W4, #0x0, [W15]
003CB2  34000A     BRA LE, 0x3CC8
750:               										{	
751:               											if(Errore>200)
003CB4  200C84     MOV #0xC8, W4
003CB6  78029E     MOV [W14], W5
003CB8  528F84     SUB W5, W4, [W15]
003CBA  340044     BRA LE, 0x3D44
752:               											Incrementa(&Me.ExpValve_Req, IncOutValvole, LimiteMaxCaldo);		// Apro valvola fino a MAX per alzare la temperatura
003CBC  807AD4     MOV LimiteMaxCaldo, W4
003CBE  780104     MOV W4, W2
003CC0  200011     MOV #0x1, W1
003CC2  20B960     MOV #0xB96, W0
003CC4  070EE1     RCALL Incrementa
003CC6  37003E     BRA 0x3D44
753:               										}
754:               										else
755:               										{
756:               											Errore = Me.Temp_AirOut - Me.Evap_Temp;
003CC8  805B75     MOV 0xB6E, W5
003CCA  805BF4     MOV 0xB7E, W4
003CCC  528F04     SUB W5, W4, [W14]
757:               											if(Errore>0)
003CCE  78021E     MOV [W14], W4
003CD0  520FE0     SUB W4, #0x0, [W15]
003CD2  340038     BRA LE, 0x3D44
758:               											{	
759:               												if(Errore>200)
003CD4  200C84     MOV #0xC8, W4
003CD6  78029E     MOV [W14], W5
003CD8  528F84     SUB W5, W4, [W15]
003CDA  340034     BRA LE, 0x3D44
760:               												Decrementa(&Me.ExpValve_Req, IncOutValvole, LimiteMinCaldo);		// Chiudo valvola fino a MIN per abbassare la temperatura
003CDC  807AC4     MOV LimiteMinCaldo, W4
003CDE  780104     MOV W4, W2
003CE0  200011     MOV #0x1, W1
003CE2  20B960     MOV #0xB96, W0
003CE4  070EFF     RCALL Decrementa
003CE6  37002E     BRA 0x3D44
761:               											}
762:               										}
763:               									}
764:               								}
765:               								else
766:               								{
767:               								Errore = Me.Setp_PressLiqP_Caldo - EngineBox.Pressione_Liq_P;	//Calcolo errore
003CE8  805C14     MOV 0xB82, W4
003CEA  780284     MOV W4, W5
003CEC  8059B4     MOV 0xB36, W4
003CEE  528204     SUB W5, W4, W4
003CF0  780F04     MOV W4, [W14]
768:               									if(Errore>500)	//Se Errore >500 mBar
003CF2  201F44     MOV #0x1F4, W4
003CF4  78029E     MOV [W14], W5
003CF6  528F84     SUB W5, W4, [W15]
003CF8  340006     BRA LE, 0x3D06
769:               										Incrementa(&Me.ExpValve_Req, IncOutValvole, LimiteMaxCaldo);		// Apro valvola fino a MAX per alzare la pressione													
003CFA  807AD4     MOV LimiteMaxCaldo, W4
003CFC  780104     MOV W4, W2
003CFE  200011     MOV #0x1, W1
003D00  20B960     MOV #0xB96, W0
003D02  070EC2     RCALL Incrementa
003D04  37001F     BRA 0x3D44
770:               									else
771:               									{
772:               										Errore = Me.Evap_Temp - Me.Temp_AirOut;
003D06  805BF5     MOV 0xB7E, W5
003D08  805B74     MOV 0xB6E, W4
003D0A  528F04     SUB W5, W4, [W14]
773:               										if(Errore>0)
003D0C  78021E     MOV [W14], W4
003D0E  520FE0     SUB W4, #0x0, [W15]
003D10  34000A     BRA LE, 0x3D26
774:               										{	
775:               											if(Errore>200)
003D12  200C84     MOV #0xC8, W4
003D14  78029E     MOV [W14], W5
003D16  528F84     SUB W5, W4, [W15]
003D18  340015     BRA LE, 0x3D44
776:               											Incrementa(&Me.ExpValve_Req, IncOutValvole, LimiteMaxCaldo);		// Apro valvola fino a MAX per alzare la temperatura
003D1A  807AD4     MOV LimiteMaxCaldo, W4
003D1C  780104     MOV W4, W2
003D1E  200011     MOV #0x1, W1
003D20  20B960     MOV #0xB96, W0
003D22  070EB2     RCALL Incrementa
003D24  37000F     BRA 0x3D44
777:               										}
778:               										else
779:               										{
780:               											Errore = Me.Temp_AirOut - Me.Evap_Temp;
003D26  805B75     MOV 0xB6E, W5
003D28  805BF4     MOV 0xB7E, W4
003D2A  528F04     SUB W5, W4, [W14]
781:               											if(Errore>0)
003D2C  78021E     MOV [W14], W4
003D2E  520FE0     SUB W4, #0x0, [W15]
003D30  340009     BRA LE, 0x3D44
782:               											{	
783:               												if(Errore>200)
003D32  200C84     MOV #0xC8, W4
003D34  78029E     MOV [W14], W5
003D36  528F84     SUB W5, W4, [W15]
003D38  340005     BRA LE, 0x3D44
784:               												Decrementa(&Me.ExpValve_Req, IncOutValvole, LimiteMinCaldo);		// Chiudo valvola fino a MIN per abbassare la temperatura
003D3A  807AC4     MOV LimiteMinCaldo, W4
003D3C  780104     MOV W4, W2
003D3E  200011     MOV #0x1, W1
003D40  20B960     MOV #0xB96, W0
003D42  070ED0     RCALL Decrementa
785:               											}
786:               										}
787:               									}
788:               								}
789:               								TimerExpValvola.TimeOut = 0;
003D44  A92E26     BCLR 0xE26, #1
003D46  370002     BRA 0x3D4C
790:                							}
791:               						}
792:               						else											// se le modalità non sono concorde
793:               							Me.ExpValve_Req = ValvolaChiusaEngBoxCaldo;	// Valvola con apertura di 30 passa
003D48  200284     MOV #0x28, W4
003D4A  885CB4     MOV W4, 0xB96
794:               						break;
003D4C  370056     BRA 0x3DFA
795:               	
796:               						
797:               					case EngineBox_Freddo:
798:               						if((Me.Function_Mode == CoreRaffrescamento) |
003D4E  805C24     MOV 0xB84, W4
003D50  A23004     BTG W4, #3
003D52  A7F004     BTSC W4, #15
003D54  EA0204     NEG W4, W4
003D56  E90204     DEC W4, W4
003D58  DE224F     LSR W4, #15, W4
003D5A  784284     MOV.B W4, W5
003D6A  72C204     IOR.B W5, W4, W4
003D6C  524FE0     SUB.B W4, #0x0, [W15]
003D6E  32003F     BRA Z, 0x3DEE
799:               							(Me.Function_Mode == CoreSlaveFreddo))		// Devo raffrescare
003D5C  805C24     MOV 0xB84, W4
003D5E  6A0272     XOR W4, #0x12, W4
003D60  A7F004     BTSC W4, #15
003D62  EA0204     NEG W4, W4
003D64  E90204     DEC W4, W4
003D66  DE224F     LSR W4, #15, W4
003D68  784204     MOV.B W4, W4
800:               						{
801:               barbatrucco:							
802:               						//---------------------------------------------
803:               						// Nuova gestione valvola con regolatore PID
804:               						//---------------------------------------------
805:               						#ifdef	DEBUGPID
806:               							ValvePID.SetP = Me.Temp_Big; //K_SetPoint;	// Setpoint! (Valore desiderato di SuperHeat) 
807:               							ValvePID.RetVal = 0; //-Me.Superheat;		// Retroaction Value (settare a "0" per taratura PID ad anello aperto!)
808:               						#else	
809:               							ValvePID.SetP = K_SetPoint;					// Setpoint! (Valore desiderato di SuperHeat) 
003D70  202584     MOV #0x258, W4
003D72  8872F4     MOV W4, ValvePID
810:               																		// Per taratura PID utilizzazre un canale analogico 
811:               																		// (es. Me.Temp_Big) per simulare risposta a gradino
812:               							ValvePID.RetVal = (int)((float)Me.Superheat * K_gainSuperHeat);										// Retroaction Value (settare a "0" per taratura PID ad anello aperto!)
003D74  805D44     MOV 0xBA8, W4
003D76  DEA2CF     ASR W4, #15, W5
003D78  BE0004     MOV.D W4, W0
003D7A  07E3A1     RCALL ___floatsisf
003D7C  BE0200     MOV.D W0, W4
003D7E  BE0004     MOV.D W4, W0
003D80  07E362     RCALL ___fixsfsi
003D82  BE0200     MOV.D W0, W4
003D84  780204     MOV W4, W4
003D86  887304     MOV W4, 0xE60
813:               						#endif
814:               
815:               
816:               						#ifdef	DEBUGPID			
817:               							EngineBox.Pressione_Gas_G = Me.Pres_Big;
818:               						#endif	
819:               
820:               
821:               							if(TimerExecPID.TimeOut)
003D88  805924     MOV 0xB24, W4
003D8A  620262     AND W4, #0x2, W4
003D8C  520FE0     SUB W4, #0x0, [W15]
003D8E  320031     BRA Z, 0x3DF2
822:               							{
823:               								TimerExecPID.TimeOut=0;
003D90  A92B24     BCLR 0xB24, #1
824:               								TimerExecPID.Value=0;
003D92  EB0200     CLR W4
003D94  885904     MOV W4, TimerExecPID
825:               								UpdatePID(&ValvePID);
003D96  20E5E0     MOV #0xE5E, W0
003D98  07207C     RCALL UpdatePID
826:               								Me.ExpValve_Req = PIDOut2Valve(ValvePID.PVal, K_PoMin, K_PoMax, K_ValveMin, K_ValveMax);
003D9A  807315     MOV 0xE62, W5
003D9C  203C04     MOV #0x3C0, W4
003D9E  200143     MOV #0x14, W3
003DA0  2251C2     MOV #0x251C, W2
003DA2  EB0080     CLR W1
003DA4  780005     MOV W5, W0
003DA6  071FCB     RCALL PIDOut2Valve
003DA8  780200     MOV W0, W4
003DAA  885CB4     MOV W4, 0xB96
827:                                               //Me.ExpValve_Req = Filter(&FilterExpValve, Me.ExpValve_Req, K_Campioni_Filter);
828:                                               //DEBUG
829:                                               PutStringToBUS2(ValvePID.PVal, Me.ExpValve_Req, Me.Temp_Big, ValvePID.RetVal, (int)(ValvePID.VKiPID*100.0), (int)(ValvePID.VKdPID*100.0));
003DAC  8074E4     MOV 0xE9C, W4
003DAE  8074F5     MOV 0xE9E, W5
003DB0  200002     MOV #0x0, W2
003DB2  242C83     MOV #0x42C8, W3
003DB4  BE0004     MOV.D W4, W0
003DB6  07E432     RCALL ___mulsf3
003DB8  BE0200     MOV.D W0, W4
003DBA  BE0004     MOV.D W4, W0
003DBC  07E344     RCALL ___fixsfsi
003DBE  BE0200     MOV.D W0, W4
003DC0  780404     MOV W4, W8
003DC2  8074C4     MOV 0xE98, W4
003DC4  8074D5     MOV 0xE9A, W5
003DC6  200002     MOV #0x0, W2
003DC8  242C83     MOV #0x42C8, W3
003DCA  BE0004     MOV.D W4, W0
003DCC  07E427     RCALL ___mulsf3
003DCE  BE0200     MOV.D W0, W4
003DD0  BE0004     MOV.D W4, W0
003DD2  07E339     RCALL ___fixsfsi
003DD4  BE0200     MOV.D W0, W4
003DD6  780204     MOV W4, W4
003DD8  807301     MOV 0xE60, W1
003DDA  805B80     MOV 0xB70, W0
003DDC  805CB7     MOV 0xB96, W7
003DDE  807316     MOV 0xE62, W6
003DE0  780288     MOV W8, W5
003DE2  780181     MOV W1, W3
003DE4  780100     MOV W0, W2
003DE6  780087     MOV W7, W1
003DE8  780006     MOV W6, W0
003DEA  07FCDD     RCALL PutStringToBUS2
003DEC  370002     BRA 0x3DF2
830:               						#ifdef	DEBUGPID				
831:               								//PutStringToBUS2(ValvePID.PVal, ValvePID.RetVal, Me.Temp_Big, Me.Temp_Small);
832:               								PutStringToBUS2(ValvePID.PVal, Me.ExpValve_Req, Me.Temp_Big, ValvePID.RetVal);
833:               						#endif
834:               							}
835:               							
836:               						}
837:               						else										// se le modalità non sono concorde
838:               							Me.ExpValve_Req = ValvolaChiusa;		// la chiudo completamente
003DEE  EB0200     CLR W4
003DF0  885CB4     MOV W4, 0xB96
839:               						break;
003DF2  370003     BRA 0x3DFA
840:               	
841:               					case EngineBox_Off:							// se il box motore è fermo 
842:               							Me.ExpValve_Req = ValvolaChiusa;		// la chiudo completamente
003DF4  EB0200     CLR W4
003DF6  885CB4     MOV W4, 0xB96
843:               						break;
003DF8  000000     NOP
844:               				}
845:               				break;
003C22  3700FE     BRA 0x3E20
003DFA  370012     BRA 0x3E20
846:               				
847:               				
848:               				
849:               				
850:               
851:               			case EngineBox_GoOff:								// il box motore si sta spegnendo
852:               				Me.ExpValve_Req = K_ValveGoOff; //ValvolaAperta;
003DFC  201E04     MOV #0x1E0, W4
003DFE  885CB4     MOV W4, 0xB96
853:               				break;
003E00  37000F     BRA 0x3E20
854:               
855:               			case EngineBox_GoFreddo:							// il box motore si sta spegnendo
856:               //barbatrucco2:				
857:               				//Me.ExpValve_Req = InitValvolaFreddo;
858:               				PID_SetOut(&ValvePID, InitValvolaFreddo);		// Inizializzo uscita PID per avere "InitValvolaFreddo"
003E02  2015E1     MOV #0x15E, W1
003E04  20E5E0     MOV #0xE5E, W0
003E06  071FF5     RCALL PID_SetOut
859:               				Me.ExpValve_Req = InitValvolaFreddo;
003E08  2015E4     MOV #0x15E, W4
003E0A  885CB4     MOV W4, 0xB96
860:                               break;
003E0C  370009     BRA 0x3E20
861:               
862:               			case EngineBox_GoCaldo:							// il box motore si sta spegnendo
863:               				Me.ExpValve_Req = InitValvolaCaldo;
003E0E  200B44     MOV #0xB4, W4
003E10  885CB4     MOV W4, 0xB96
864:               				break;
003E12  370006     BRA 0x3E20
865:               
866:               			case EngineBox_CriticalFault:						// Se arriva il Fault "CriticalFault" dal Master
867:               				Me.ExpValve_Req = ValvolaAperta;
003E14  203C04     MOV #0x3C0, W4
003E16  885CB4     MOV W4, 0xB96
868:               				break;
003E18  370003     BRA 0x3E20
869:               		
870:               			default:	// se nessuna delle precedenti
871:               				Me.ExpValve_Req = ValvolaChiusa;
003E1A  EB0200     CLR W4
003E1C  885CB4     MOV W4, 0xB96
872:               				break;
003E1E  000000     NOP
873:               		}
874:               	}
875:               }
003E20  78044F     MOV [--W15], W8
003E22  FA8000     ULNK
003E24  060000     RETURN
---  D:/WORK3/Lavori/TERMODINAMICA/Work/FW/1 - Generico/Split/Split v.8.4.22 - Working/ADC.c  -----------
1:                 //----------------------------------------------------------------------------------
2:                 //	Progect name:	ADC.c
3:                 //	Device:			PIC24FJ256GB110 @ 32Mhz (FRCPLL)
4:                 //	Autor:			Emanuele
5:                 //	Date:			04/01/2014
6:                 //	Description:	Corpo delle funzioni pilota per l'acquisizione analogico digitale
7:                 //----------------------------------------------------------------------------------
8:                 
9:                 //----------------------------------------------------------------------------------
10:                //	Include
11:                //----------------------------------------------------------------------------------
12:                #include "MicroModelSelection.h"
13:                #ifdef GB210
14:                	#include <p24FJ256GB210.h>
15:                #else
16:                	#include <p24FJ256GB110.h>
17:                #endif
18:                #include <stdio.h>
19:                #include <math.h>
20:                #include "Delay.h"
21:                #include "DefinePeriferiche.h"
22:                #include "ADC.h"
23:                
24:                //----------------------------------------------------------------------------------
25:                //	Funzioni
26:                //----------------------------------------------------------------------------------
27:                void AD_Read(void)
28:                {
005B40  FA0000     LNK #0x0
005B42  BE9F88     MOV.D W8, [W15++]
29:                	AD1CON2bits.CSCNA = 1;		// Scan/input 0=> use the chanel selectet by CH0SA
005B44  A84323     BSET 0x323, #2
30:                								//            1=> Scan input selected in AD1CSSL reg
31:                	AD1CHSbits.CH0NA = 0;		// selected negative input for mux A to AGnd
005B46  A9E328     BCLR AD1CHS, #7
32:                	AD1CHSbits.CH0SA = 0;		// selected input for mux A
005B48  801945     MOV AD1CHS, W5
005B4A  2FFE04     MOV #0xFFE0, W4
005B4C  628204     AND W5, W4, W4
005B4E  881944     MOV W4, AD1CHS
33:                	AD1CSSL = 0x013F;			// set acquisition chanel mask
005B50  2013F4     MOV #0x13F, W4
005B52  881984     MOV W4, AD1CSSL
34:                	AD1CSSH = 0;
005B54  EB0200     CLR W4
005B56  881994     MOV W4, AD1CSSH
35:                	AD1CON2bits.SMPI = 9;		// Interrupt request. Ogni quante conversione avviene l'interrupt (0-16)
005B58  801914     MOV AD1CON2, W4
005B5A  A02004     BSET W4, #2
005B5C  A13004     BCLR W4, #3
005B5E  A14004     BCLR W4, #4
005B60  A05004     BSET W4, #5
005B62  881914     MOV W4, AD1CON2
36:                
37:                	IFS0bits.AD1IF = 0;			// ripulisco il flag di interrupot dell'ADC
005B64  A9A085     BCLR 0x85, #5
38:                	AD1CON1bits.ASAM = 1;		// auto start sampling
005B66  A84320     BSET AD1CON1, #2
39:                
40:                	// then go to conversion
41:                	while (!IFS0bits.AD1IF){};	// Conversdione finita?
005B68  000000     NOP
005B6A  800425     MOV IFS0, W5
005B6C  220004     MOV #0x2000, W4
005B6E  628204     AND W5, W4, W4
005B70  520FE0     SUB W4, #0x0, [W15]
005B72  32FFFB     BRA Z, 0x5B6A
42:                	AD1CON1bits.ASAM = 0;		// Si, stoppo campinonamente e conversione
005B74  A94320     BCLR AD1CON1, #2
43:                /*
44:                	Adc_T_Grande = ADC1BUF0;
45:                	Adc_T_Piccolo = ADC1BUF1;
46:                	Adc_T_Out = ADC1BUF2;
47:                	Adc_T_Amb = ADC1BUF3;
48:                	Adc_P_Grande = ADC1BUF4;
49:                	Adc_P_Piccolo = ADC1BUF5;
50:                	Adc_I_Fan = ADC1BUF6;
51:                */
52:                	Sum_Adc_T_Grande += ADC1BUF0;		// sommo il valore letto dall'adc nel cumulativo
005B76  801804     MOV ADC1BUF0, W4
005B78  200005     MOV #0x0, W5
005B7A  BE0004     MOV.D W4, W0
005B7C  07D4A3     RCALL ___floatunsisf
005B7E  BE0300     MOV.D W0, W6
005B80  804314     MOV Sum_Adc_T_Grande, W4
005B82  804325     MOV 0x864, W5
005B84  BE0104     MOV.D W4, W2
005B86  BE0006     MOV.D W6, W0
005B88  07D3BB     RCALL ___addsf3
005B8A  BE0200     MOV.D W0, W4
005B8C  884314     MOV W4, Sum_Adc_T_Grande
005B8E  884325     MOV W5, 0x864
53:                	Sum_Adc_T_Piccolo += ADC1BUF1;
005B90  801814     MOV ADC1BUF1, W4
005B92  200005     MOV #0x0, W5
005B94  BE0004     MOV.D W4, W0
005B96  07D496     RCALL ___floatunsisf
005B98  BE0300     MOV.D W0, W6
005B9A  8042F4     MOV Sum_Adc_T_Piccolo, W4
005B9C  804305     MOV 0x860, W5
005B9E  BE0104     MOV.D W4, W2
005BA0  BE0006     MOV.D W6, W0
005BA2  07D3AE     RCALL ___addsf3
005BA4  BE0200     MOV.D W0, W4
005BA6  8842F4     MOV W4, Sum_Adc_T_Piccolo
005BA8  884305     MOV W5, 0x860
54:                	Sum_Adc_T_Out += ADC1BUF2;
005BAA  801824     MOV ADC1BUF2, W4
005BAC  200005     MOV #0x0, W5
005BAE  BE0004     MOV.D W4, W0
005BB0  07D489     RCALL ___floatunsisf
005BB2  BE0300     MOV.D W0, W6
005BB4  804334     MOV Sum_Adc_T_Out, W4
005BB6  804345     MOV 0x868, W5
005BB8  BE0104     MOV.D W4, W2
005BBA  BE0006     MOV.D W6, W0
005BBC  07D3A1     RCALL ___addsf3
005BBE  BE0200     MOV.D W0, W4
005BC0  884334     MOV W4, Sum_Adc_T_Out
005BC2  884345     MOV W5, 0x868
55:                	Sum_Adc_T_Amb += ADC1BUF3;
005BC4  801834     MOV ADC1BUF3, W4
005BC6  200005     MOV #0x0, W5
005BC8  BE0004     MOV.D W4, W0
005BCA  07D47C     RCALL ___floatunsisf
005BCC  BE0300     MOV.D W0, W6
005BCE  804354     MOV Sum_Adc_T_Amb, W4
005BD0  804365     MOV 0x86C, W5
005BD2  BE0104     MOV.D W4, W2
005BD4  BE0006     MOV.D W6, W0
005BD6  07D394     RCALL ___addsf3
005BD8  BE0200     MOV.D W0, W4
005BDA  884354     MOV W4, Sum_Adc_T_Amb
005BDC  884365     MOV W5, 0x86C
56:                	Sum_Adc_P_Grande += ADC1BUF4;
005BDE  801844     MOV ADC1BUF4, W4
005BE0  200005     MOV #0x0, W5
005BE2  BE0004     MOV.D W4, W0
005BE4  07D46F     RCALL ___floatunsisf
005BE6  BE0300     MOV.D W0, W6
005BE8  804374     MOV Sum_Adc_P_Grande, W4
005BEA  804385     MOV 0x870, W5
005BEC  BE0104     MOV.D W4, W2
005BEE  BE0006     MOV.D W6, W0
005BF0  07D387     RCALL ___addsf3
005BF2  BE0200     MOV.D W0, W4
005BF4  884374     MOV W4, Sum_Adc_P_Grande
005BF6  884385     MOV W5, 0x870
57:                	Sum_Adc_P_Piccolo += ADC1BUF5;
005BF8  801854     MOV ADC1BUF5, W4
005BFA  200005     MOV #0x0, W5
005BFC  BE0004     MOV.D W4, W0
005BFE  07D462     RCALL ___floatunsisf
005C00  BE0300     MOV.D W0, W6
005C02  804394     MOV Sum_Adc_P_Piccolo, W4
005C04  8043A5     MOV 0x874, W5
005C06  BE0104     MOV.D W4, W2
005C08  BE0006     MOV.D W6, W0
005C0A  07D37A     RCALL ___addsf3
005C0C  BE0200     MOV.D W0, W4
005C0E  884394     MOV W4, Sum_Adc_P_Piccolo
005C10  8843A5     MOV W5, 0x874
58:                
59:                    
60:                	Adc_I_Fan = ADC1BUF6;
005C12  801864     MOV ADC1BUF6, W4
005C14  8842E4     MOV W4, Adc_I_Fan
61:                	
62:                	N_Campioni +=1;						// incremento il cnt dei campioni
005C16  208764     MOV #0x876, W4
005C18  784214     MOV.B [W4], W4
005C1A  E84204     INC.B W4, W4
005C1C  784304     MOV.B W4, W6
005C1E  208765     MOV #0x876, W5
005C20  784A86     MOV.B W6, [W5]
63:                
64:                	if(N_Campioni > Campioni_Acquisizione)		// se ho oltrepassato la soglia dei campioni
005C22  208764     MOV #0x876, W4
005C24  784214     MOV.B [W4], W4
005C26  524FE6     SUB.B W4, #0x6, [W15]
005C28  340052     BRA LE, 0x5CCE
65:                	{	N_Campioni = Campioni_Acquisizione;		// riscalo il numero dei campioni
005C2A  B3C064     MOV.B #0x6, W4
005C2C  784304     MOV.B W4, W6
005C2E  208765     MOV #0x876, W5
005C30  784A86     MOV.B W6, [W5]
66:                		Sum_Adc_T_Grande -= Adc_T_Grande;		// sottraggo il campione medio dalla somma cumulativa
005C32  804318     MOV Sum_Adc_T_Grande, W8
005C34  804329     MOV 0x864, W9
005C36  804294     MOV Adc_T_Grande, W4
005C38  DEA2CF     ASR W4, #15, W5
005C3A  BE0004     MOV.D W4, W0
005C3C  07D440     RCALL ___floatsisf
005C3E  BE0200     MOV.D W0, W4
005C40  BE0104     MOV.D W4, W2
005C42  BE0008     MOV.D W8, W0
005C44  07D35C     RCALL ___subsf3
005C46  BE0200     MOV.D W0, W4
005C48  884314     MOV W4, Sum_Adc_T_Grande
005C4A  884325     MOV W5, 0x864
67:                		Sum_Adc_T_Piccolo -= Adc_T_Piccolo;
005C4C  8042F8     MOV Sum_Adc_T_Piccolo, W8
005C4E  804309     MOV 0x860, W9
005C50  804284     MOV Adc_T_Piccolo, W4
005C52  DEA2CF     ASR W4, #15, W5
005C54  BE0004     MOV.D W4, W0
005C56  07D433     RCALL ___floatsisf
005C58  BE0200     MOV.D W0, W4
005C5A  BE0104     MOV.D W4, W2
005C5C  BE0008     MOV.D W8, W0
005C5E  07D34F     RCALL ___subsf3
005C60  BE0200     MOV.D W0, W4
005C62  8842F4     MOV W4, Sum_Adc_T_Piccolo
005C64  884305     MOV W5, 0x860
68:                		Sum_Adc_T_Out -= Adc_T_Out;
005C66  804338     MOV Sum_Adc_T_Out, W8
005C68  804349     MOV 0x868, W9
005C6A  8042A4     MOV Adc_T_Out, W4
005C6C  DEA2CF     ASR W4, #15, W5
005C6E  BE0004     MOV.D W4, W0
005C70  07D426     RCALL ___floatsisf
005C72  BE0200     MOV.D W0, W4
005C74  BE0104     MOV.D W4, W2
005C76  BE0008     MOV.D W8, W0
005C78  07D342     RCALL ___subsf3
005C7A  BE0200     MOV.D W0, W4
005C7C  884334     MOV W4, Sum_Adc_T_Out
005C7E  884345     MOV W5, 0x868
69:                		Sum_Adc_T_Amb -= Adc_T_Amb;
005C80  804358     MOV Sum_Adc_T_Amb, W8
005C82  804369     MOV 0x86C, W9
005C84  8042B4     MOV Adc_T_Amb, W4
005C86  DEA2CF     ASR W4, #15, W5
005C88  BE0004     MOV.D W4, W0
005C8A  07D419     RCALL ___floatsisf
005C8C  BE0200     MOV.D W0, W4
005C8E  BE0104     MOV.D W4, W2
005C90  BE0008     MOV.D W8, W0
005C92  07D335     RCALL ___subsf3
005C94  BE0200     MOV.D W0, W4
005C96  884354     MOV W4, Sum_Adc_T_Amb
005C98  884365     MOV W5, 0x86C
70:                		Sum_Adc_P_Grande -= Adc_P_Grande;
005C9A  804378     MOV Sum_Adc_P_Grande, W8
005C9C  804389     MOV 0x870, W9
005C9E  8042C4     MOV Adc_P_Grande, W4
005CA0  DEA2CF     ASR W4, #15, W5
005CA2  BE0004     MOV.D W4, W0
005CA4  07D40C     RCALL ___floatsisf
005CA6  BE0200     MOV.D W0, W4
005CA8  BE0104     MOV.D W4, W2
005CAA  BE0008     MOV.D W8, W0
005CAC  07D328     RCALL ___subsf3
005CAE  BE0200     MOV.D W0, W4
005CB0  884374     MOV W4, Sum_Adc_P_Grande
005CB2  884385     MOV W5, 0x870
71:                		Sum_Adc_P_Piccolo -= Adc_P_Piccolo;
005CB4  804398     MOV Sum_Adc_P_Piccolo, W8
005CB6  8043A9     MOV 0x874, W9
005CB8  8042D4     MOV Adc_P_Piccolo, W4
005CBA  DEA2CF     ASR W4, #15, W5
005CBC  BE0004     MOV.D W4, W0
005CBE  07D3FF     RCALL ___floatsisf
005CC0  BE0200     MOV.D W0, W4
005CC2  BE0104     MOV.D W4, W2
005CC4  BE0008     MOV.D W8, W0
005CC6  07D31B     RCALL ___subsf3
005CC8  BE0200     MOV.D W0, W4
005CCA  884394     MOV W4, Sum_Adc_P_Piccolo
005CCC  8843A5     MOV W5, 0x874
72:                	}
73:                
74:                	if(N_Campioni != 0)
005CCE  208764     MOV #0x876, W4
005CD0  784214     MOV.B [W4], W4
005CD2  524FE0     SUB.B W4, #0x0, [W15]
005CD4  32006C     BRA Z, 0x5DAE
75:                	{	Adc_T_Grande = Sum_Adc_T_Grande /N_Campioni;
005CD6  804318     MOV Sum_Adc_T_Grande, W8
005CD8  804329     MOV 0x864, W9
005CDA  208764     MOV #0x876, W4
005CDC  784214     MOV.B [W4], W4
005CDE  FB0204     SE W4, W4
005CE0  DEA2CF     ASR W4, #15, W5
005CE2  BE0004     MOV.D W4, W0
005CE4  07D3EC     RCALL ___floatsisf
005CE6  BE0200     MOV.D W0, W4
005CE8  BE0104     MOV.D W4, W2
005CEA  BE0008     MOV.D W8, W0
005CEC  07D366     RCALL ___divsf3
005CEE  BE0200     MOV.D W0, W4
005CF0  BE0004     MOV.D W4, W0
005CF2  07D3A9     RCALL ___fixsfsi
005CF4  BE0200     MOV.D W0, W4
005CF6  780204     MOV W4, W4
005CF8  884294     MOV W4, Adc_T_Grande
76:                		Adc_T_Piccolo = Sum_Adc_T_Piccolo/N_Campioni;
005CFA  8042F8     MOV Sum_Adc_T_Piccolo, W8
005CFC  804309     MOV 0x860, W9
005CFE  208764     MOV #0x876, W4
005D00  784214     MOV.B [W4], W4
005D02  FB0204     SE W4, W4
005D04  DEA2CF     ASR W4, #15, W5
005D06  BE0004     MOV.D W4, W0
005D08  07D3DA     RCALL ___floatsisf
005D0A  BE0200     MOV.D W0, W4
005D0C  BE0104     MOV.D W4, W2
005D0E  BE0008     MOV.D W8, W0
005D10  07D354     RCALL ___divsf3
005D12  BE0200     MOV.D W0, W4
005D14  BE0004     MOV.D W4, W0
005D16  07D397     RCALL ___fixsfsi
005D18  BE0200     MOV.D W0, W4
005D1A  780204     MOV W4, W4
005D1C  884284     MOV W4, Adc_T_Piccolo
77:                		Adc_T_Out = Sum_Adc_T_Out/N_Campioni;
005D1E  804338     MOV Sum_Adc_T_Out, W8
005D20  804349     MOV 0x868, W9
005D22  208764     MOV #0x876, W4
005D24  784214     MOV.B [W4], W4
005D26  FB0204     SE W4, W4
005D28  DEA2CF     ASR W4, #15, W5
005D2A  BE0004     MOV.D W4, W0
005D2C  07D3C8     RCALL ___floatsisf
005D2E  BE0200     MOV.D W0, W4
005D30  BE0104     MOV.D W4, W2
005D32  BE0008     MOV.D W8, W0
005D34  07D342     RCALL ___divsf3
005D36  BE0200     MOV.D W0, W4
005D38  BE0004     MOV.D W4, W0
005D3A  07D385     RCALL ___fixsfsi
005D3C  BE0200     MOV.D W0, W4
005D3E  780204     MOV W4, W4
005D40  8842A4     MOV W4, Adc_T_Out
78:                		Adc_T_Amb = Sum_Adc_T_Amb/N_Campioni;
005D42  804358     MOV Sum_Adc_T_Amb, W8
005D44  804369     MOV 0x86C, W9
005D46  208764     MOV #0x876, W4
005D48  784214     MOV.B [W4], W4
005D4A  FB0204     SE W4, W4
005D4C  DEA2CF     ASR W4, #15, W5
005D4E  BE0004     MOV.D W4, W0
005D50  07D3B6     RCALL ___floatsisf
005D52  BE0200     MOV.D W0, W4
005D54  BE0104     MOV.D W4, W2
005D56  BE0008     MOV.D W8, W0
005D58  07D330     RCALL ___divsf3
005D5A  BE0200     MOV.D W0, W4
005D5C  BE0004     MOV.D W4, W0
005D5E  07D373     RCALL ___fixsfsi
005D60  BE0200     MOV.D W0, W4
005D62  780204     MOV W4, W4
005D64  8842B4     MOV W4, Adc_T_Amb
79:                		Adc_P_Grande = Sum_Adc_P_Grande/N_Campioni;    
005D66  804378     MOV Sum_Adc_P_Grande, W8
005D68  804389     MOV 0x870, W9
005D6A  208764     MOV #0x876, W4
005D6C  784214     MOV.B [W4], W4
005D6E  FB0204     SE W4, W4
005D70  DEA2CF     ASR W4, #15, W5
005D72  BE0004     MOV.D W4, W0
005D74  07D3A4     RCALL ___floatsisf
005D76  BE0200     MOV.D W0, W4
005D78  BE0104     MOV.D W4, W2
005D7A  BE0008     MOV.D W8, W0
005D7C  07D31E     RCALL ___divsf3
005D7E  BE0200     MOV.D W0, W4
005D80  BE0004     MOV.D W4, W0
005D82  07D361     RCALL ___fixsfsi
005D84  BE0200     MOV.D W0, W4
005D86  780204     MOV W4, W4
005D88  8842C4     MOV W4, Adc_P_Grande
80:                		Adc_P_Piccolo = Sum_Adc_P_Piccolo/N_Campioni; 
005D8A  804398     MOV Sum_Adc_P_Piccolo, W8
005D8C  8043A9     MOV 0x874, W9
005D8E  208764     MOV #0x876, W4
005D90  784214     MOV.B [W4], W4
005D92  FB0204     SE W4, W4
005D94  DEA2CF     ASR W4, #15, W5
005D96  BE0004     MOV.D W4, W0
005D98  07D392     RCALL ___floatsisf
005D9A  BE0200     MOV.D W0, W4
005D9C  BE0104     MOV.D W4, W2
005D9E  BE0008     MOV.D W8, W0
005DA0  07D30C     RCALL ___divsf3
005DA2  BE0200     MOV.D W0, W4
005DA4  BE0004     MOV.D W4, W0
005DA6  07D34F     RCALL ___fixsfsi
005DA8  BE0200     MOV.D W0, W4
005DAA  780204     MOV W4, W4
005DAC  8842D4     MOV W4, Adc_P_Piccolo
81:                	}		
82:                	AD1CON1bits.DONE = 0;
005DAE  A90320     BCLR AD1CON1, #0
83:                };
005DB0  BE044F     MOV.D [--W15], W8
005DB2  FA8000     ULNK
005DB4  060000     RETURN
84:                
85:                int AD_ReadSingle(char Chanel)
86:                {
005DB6  FA0004     LNK #0x4
005DB8  984720     MOV.B W0, [W14+2]
87:                	int Temp = 0;
005DBA  EB0200     CLR W4
005DBC  780F04     MOV W4, [W14]
88:                
89:                	AD1CON2bits.CSCNA = 0;		// Scan/input 0=> use the chanel selectet by CH0SA
005DBE  A94323     BCLR 0x323, #2
90:                								//            1=> Scan input selected in AD1CSSL reg
91:                	AD1CHSbits.CH0SA = Chanel;	// selected input for mux A
005DC0  90422E     MOV.B [W14+2], W4
005DC2  62427F     AND.B W4, #0x1F, W4
005DC4  FB8204     ZE W4, W4
005DC6  62027F     AND W4, #0x1F, W4
005DC8  801946     MOV AD1CHS, W6
005DCA  2FFE05     MOV #0xFFE0, W5
005DCC  630285     AND W6, W5, W5
005DCE  720205     IOR W4, W5, W4
005DD0  881944     MOV W4, AD1CHS
92:                	AD1CON2bits.SMPI = 0;		// Interrupt request. Ogni quante conversione avviene l'interrupt (0-16)
005DD2  801914     MOV AD1CON2, W4
005DD4  A12004     BCLR W4, #2
005DD6  A13004     BCLR W4, #3
005DD8  A14004     BCLR W4, #4
005DDA  A15004     BCLR W4, #5
005DDC  881914     MOV W4, AD1CON2
93:                
94:                	IFS0bits.AD1IF = 0;			// ripulisco il flag di interrupot dell'ADC
005DDE  A9A085     BCLR 0x85, #5
95:                	AD1CON1bits.ASAM = 1;		// auto start sampling
005DE0  A84320     BSET AD1CON1, #2
96:                
97:                	// then go to conversion
98:                	while (!IFS0bits.AD1IF){};	// Conversdione finita?
005DE2  000000     NOP
005DE4  800425     MOV IFS0, W5
005DE6  220004     MOV #0x2000, W4
005DE8  628204     AND W5, W4, W4
005DEA  520FE0     SUB W4, #0x0, [W15]
005DEC  32FFFB     BRA Z, 0x5DE4
99:                	AD1CON1bits.ASAM = 0;		// Si, stoppo campinonamente e conversione
005DEE  A94320     BCLR AD1CON1, #2
100:               	Temp = ADC1BUF0;
005DF0  801804     MOV ADC1BUF0, W4
005DF2  780F04     MOV W4, [W14]
101:               
102:               	return Temp;				// restituisco la conversione
005DF4  78021E     MOV [W14], W4
103:               };
005DF6  780004     MOV W4, W0
005DF8  FA8000     ULNK
005DFA  060000     RETURN
104:               
105:               int Temp_Read(volatile int AD_Value, volatile int* AD_T, volatile int* Kt)
106:               /*
107:               	Ritorno la temperatura in centesimi di grado centigrado (signed int -32768 +32767):
108:               	AD_Value è il valore in bit della lettura
109:               	AD_T è un array contenente i valori notevoli delle conversioni (@ -20, -10, ecc..)
110:               	Kt è un array contenente i coefficenti per la conversione delle temperature
111:               	ex: -10,00	=> -1000
112:               		-20,00	=> -2000
113:               		+15,52	=> +1552
114:               */
115:               {
005DFC  FA0006     LNK #0x6
005DFE  780F00     MOV W0, [W14]
005E00  980711     MOV W1, [W14+2]
005E02  980722     MOV W2, [W14+4]
116:               	if(AD_Value < AD_T[1])								// < -20°C
005E04  90021E     MOV [W14+2], W4
005E06  E88204     INC2 W4, W4
005E08  780294     MOV [W4], W5
005E0A  78021E     MOV [W14], W4
005E0C  528F84     SUB W5, W4, [W15]
005E0E  34000B     BRA LE, 0x5E26
117:               		return ((AD_Value-AD_T[0]) *Kt[0]) TempOffSet_1;	
005E10  78029E     MOV [W14], W5
005E12  90021E     MOV [W14+2], W4
005E14  780214     MOV [W4], W4
005E16  528284     SUB W5, W4, W5
005E18  90022E     MOV [W14+4], W4
005E1A  780214     MOV [W4], W4
005E1C  B9AA04     MUL.SS W5, W4, W4
005E1E  780284     MOV W4, W5
005E20  2F4484     MOV #0xF448, W4
005E22  428204     ADD W5, W4, W4
005E24  3700B3     BRA 0x5F8C
118:               
119:               	if(AD_Value < AD_T[2])								// < -10°C
005E26  90021E     MOV [W14+2], W4
005E28  420264     ADD W4, #0x4, W4
005E2A  780294     MOV [W4], W5
005E2C  78021E     MOV [W14], W4
005E2E  528F84     SUB W5, W4, [W15]
005E30  34000D     BRA LE, 0x5E4C
120:               		return ((AD_Value-AD_T[1]) *Kt[1]) TempOffSet_2;
005E32  78029E     MOV [W14], W5
005E34  90021E     MOV [W14+2], W4
005E36  E88204     INC2 W4, W4
005E38  780214     MOV [W4], W4
005E3A  528284     SUB W5, W4, W5
005E3C  90022E     MOV [W14+4], W4
005E3E  E88204     INC2 W4, W4
005E40  780214     MOV [W4], W4
005E42  B9AA04     MUL.SS W5, W4, W4
005E44  780284     MOV W4, W5
005E46  2F8304     MOV #0xF830, W4
005E48  428204     ADD W5, W4, W4
005E4A  3700A0     BRA 0x5F8C
121:               
122:               	if(AD_Value < AD_T[3])								// < 0°C
005E4C  90021E     MOV [W14+2], W4
005E4E  420266     ADD W4, #0x6, W4
005E50  780294     MOV [W4], W5
005E52  78021E     MOV [W14], W4
005E54  528F84     SUB W5, W4, [W15]
005E56  34000C     BRA LE, 0x5E70
123:               		return ((AD_Value-AD_T[2]) *Kt[2]) TempOffSet_3;
005E58  78029E     MOV [W14], W5
005E5A  90021E     MOV [W14+2], W4
005E5C  420264     ADD W4, #0x4, W4
005E5E  780214     MOV [W4], W4
005E60  528284     SUB W5, W4, W5
005E62  90022E     MOV [W14+4], W4
005E64  420264     ADD W4, #0x4, W4
005E66  780214     MOV [W4], W4
005E68  B9AA04     MUL.SS W5, W4, W4
005E6A  780204     MOV W4, W4
005E6C  B13E84     SUB #0x3E8, W4
005E6E  37008E     BRA 0x5F8C
124:               
125:               	if(AD_Value < AD_T[4])								// < 10°C
005E70  90021E     MOV [W14+2], W4
005E72  420268     ADD W4, #0x8, W4
005E74  780294     MOV [W4], W5
005E76  78021E     MOV [W14], W4
005E78  528F84     SUB W5, W4, [W15]
005E7A  34000B     BRA LE, 0x5E92
126:               		return ((AD_Value-AD_T[3]) *Kt[3]) TempOffSet_4;
005E7C  78029E     MOV [W14], W5
005E7E  90021E     MOV [W14+2], W4
005E80  420266     ADD W4, #0x6, W4
005E82  780214     MOV [W4], W4
005E84  528284     SUB W5, W4, W5
005E86  90022E     MOV [W14+4], W4
005E88  420266     ADD W4, #0x6, W4
005E8A  780214     MOV [W4], W4
005E8C  B9AA04     MUL.SS W5, W4, W4
005E8E  780204     MOV W4, W4
005E90  37007D     BRA 0x5F8C
127:               
128:               	if(AD_Value < AD_T[5])								// < 20°C
005E92  90021E     MOV [W14+2], W4
005E94  42026A     ADD W4, #0xA, W4
005E96  780294     MOV [W4], W5
005E98  78021E     MOV [W14], W4
005E9A  528F84     SUB W5, W4, [W15]
005E9C  34000C     BRA LE, 0x5EB6
129:               		return ((AD_Value-AD_T[4]) *Kt[4]) TempOffSet_5;
005E9E  78029E     MOV [W14], W5
005EA0  90021E     MOV [W14+2], W4
005EA2  420268     ADD W4, #0x8, W4
005EA4  780214     MOV [W4], W4
005EA6  528284     SUB W5, W4, W5
005EA8  90022E     MOV [W14+4], W4
005EAA  420268     ADD W4, #0x8, W4
005EAC  780214     MOV [W4], W4
005EAE  B9AA04     MUL.SS W5, W4, W4
005EB0  780204     MOV W4, W4
005EB2  B03E84     ADD #0x3E8, W4
005EB4  37006B     BRA 0x5F8C
130:               
131:               	if(AD_Value < AD_T[6])								// < 25°C
005EB6  90021E     MOV [W14+2], W4
005EB8  42026C     ADD W4, #0xC, W4
005EBA  780294     MOV [W4], W5
005EBC  78021E     MOV [W14], W4
005EBE  528F84     SUB W5, W4, [W15]
005EC0  34000D     BRA LE, 0x5EDC
132:               		return ((AD_Value-AD_T[5]) *Kt[5]) TempOffSet_6;
005EC2  78029E     MOV [W14], W5
005EC4  90021E     MOV [W14+2], W4
005EC6  42026A     ADD W4, #0xA, W4
005EC8  780214     MOV [W4], W4
005ECA  528284     SUB W5, W4, W5
005ECC  90022E     MOV [W14+4], W4
005ECE  42026A     ADD W4, #0xA, W4
005ED0  780214     MOV [W4], W4
005ED2  B9AA04     MUL.SS W5, W4, W4
005ED4  780284     MOV W4, W5
005ED6  207D04     MOV #0x7D0, W4
005ED8  428204     ADD W5, W4, W4
005EDA  370058     BRA 0x5F8C
133:               
134:               	if(AD_Value < AD_T[7])								// < 30°C
005EDC  90021E     MOV [W14+2], W4
005EDE  42026E     ADD W4, #0xE, W4
005EE0  780294     MOV [W4], W5
005EE2  78021E     MOV [W14], W4
005EE4  528F84     SUB W5, W4, [W15]
005EE6  34000D     BRA LE, 0x5F02
135:               		return ((AD_Value-AD_T[6]) *Kt[6]) TempOffSet_7;
005EE8  78029E     MOV [W14], W5
005EEA  90021E     MOV [W14+2], W4
005EEC  42026C     ADD W4, #0xC, W4
005EEE  780214     MOV [W4], W4
005EF0  528284     SUB W5, W4, W5
005EF2  90022E     MOV [W14+4], W4
005EF4  42026C     ADD W4, #0xC, W4
005EF6  780214     MOV [W4], W4
005EF8  B9AA04     MUL.SS W5, W4, W4
005EFA  780284     MOV W4, W5
005EFC  209C44     MOV #0x9C4, W4
005EFE  428204     ADD W5, W4, W4
005F00  370045     BRA 0x5F8C
136:               
137:               	if(AD_Value < AD_T[8])								// < 40°C
005F02  90021E     MOV [W14+2], W4
005F04  420270     ADD W4, #0x10, W4
005F06  780294     MOV [W4], W5
005F08  78021E     MOV [W14], W4
005F0A  528F84     SUB W5, W4, [W15]
005F0C  34000D     BRA LE, 0x5F28
138:               		return ((AD_Value-AD_T[7]) *Kt[7]) TempOffSet_8;
005F0E  78029E     MOV [W14], W5
005F10  90021E     MOV [W14+2], W4
005F12  42026E     ADD W4, #0xE, W4
005F14  780214     MOV [W4], W4
005F16  528284     SUB W5, W4, W5
005F18  90022E     MOV [W14+4], W4
005F1A  42026E     ADD W4, #0xE, W4
005F1C  780214     MOV [W4], W4
005F1E  B9AA04     MUL.SS W5, W4, W4
005F20  780284     MOV W4, W5
005F22  20BB84     MOV #0xBB8, W4
005F24  428204     ADD W5, W4, W4
005F26  370032     BRA 0x5F8C
139:               
140:               	if(AD_Value < AD_T[9])								// < 50°C
005F28  90021E     MOV [W14+2], W4
005F2A  420272     ADD W4, #0x12, W4
005F2C  780294     MOV [W4], W5
005F2E  78021E     MOV [W14], W4
005F30  528F84     SUB W5, W4, [W15]
005F32  34000D     BRA LE, 0x5F4E
141:               		return ((AD_Value-AD_T[8]) *Kt[8]) TempOffSet_9;
005F34  78029E     MOV [W14], W5
005F36  90021E     MOV [W14+2], W4
005F38  420270     ADD W4, #0x10, W4
005F3A  780214     MOV [W4], W4
005F3C  528284     SUB W5, W4, W5
005F3E  90022E     MOV [W14+4], W4
005F40  420270     ADD W4, #0x10, W4
005F42  780214     MOV [W4], W4
005F44  B9AA04     MUL.SS W5, W4, W4
005F46  780284     MOV W4, W5
005F48  20FA04     MOV #0xFA0, W4
005F4A  428204     ADD W5, W4, W4
005F4C  37001F     BRA 0x5F8C
142:               
143:               	if(AD_Value < AD_T[10])								// < 60 °C
005F4E  90021E     MOV [W14+2], W4
005F50  420274     ADD W4, #0x14, W4
005F52  780294     MOV [W4], W5
005F54  78021E     MOV [W14], W4
005F56  528F84     SUB W5, W4, [W15]
005F58  34000D     BRA LE, 0x5F74
144:               		return ((AD_Value-AD_T[9]) *Kt[9]) TempOffSet_10;
005F5A  78029E     MOV [W14], W5
005F5C  90021E     MOV [W14+2], W4
005F5E  420272     ADD W4, #0x12, W4
005F60  780214     MOV [W4], W4
005F62  528284     SUB W5, W4, W5
005F64  90022E     MOV [W14+4], W4
005F66  420272     ADD W4, #0x12, W4
005F68  780214     MOV [W4], W4
005F6A  B9AA04     MUL.SS W5, W4, W4
005F6C  780284     MOV W4, W5
005F6E  213884     MOV #0x1388, W4
005F70  428204     ADD W5, W4, W4
005F72  37000C     BRA 0x5F8C
145:               
146:               	return ((AD_Value-AD_T[10]) *Kt[10]) TempOffSet_11;
005F74  78029E     MOV [W14], W5
005F76  90021E     MOV [W14+2], W4
005F78  420274     ADD W4, #0x14, W4
005F7A  780214     MOV [W4], W4
005F7C  528284     SUB W5, W4, W5
005F7E  90022E     MOV [W14+4], W4
005F80  420274     ADD W4, #0x14, W4
005F82  780214     MOV [W4], W4
005F84  B9AA04     MUL.SS W5, W4, W4
005F86  780284     MOV W4, W5
005F88  217704     MOV #0x1770, W4
005F8A  428204     ADD W5, W4, W4
147:               }
005F8C  780004     MOV W4, W0
005F8E  FA8000     ULNK
005F90  060000     RETURN
148:               
149:               int T_Amb_Read(volatile int AD_Value, volatile int* AD_T, volatile int* Kt)
150:               /*
151:               	Ritorno la temperatura in centesimi di grado centigrado (signed int -32768 +32767):
152:               	AD_Value è il valore in bit della lettura
153:               	AD_T è un array contenente i valori notevoli delle conversioni (@ 10, 13, ecc..)
154:               	Kt è un array contenente i coefficenti per la conversione delle temperature
155:               	ex: 10,00	=> 1000
156:               		20,00	=> 2000
157:               		25,52	=> 2552
158:               */
159:               {
005F92  FA0006     LNK #0x6
005F94  780F00     MOV W0, [W14]
005F96  980711     MOV W1, [W14+2]
005F98  980722     MOV W2, [W14+4]
160:               	if(AD_Value < AD_T[1])								// < 13°C
005F9A  90021E     MOV [W14+2], W4
005F9C  E88204     INC2 W4, W4
005F9E  780294     MOV [W4], W5
005FA0  78021E     MOV [W14], W4
005FA2  528F84     SUB W5, W4, [W15]
005FA4  34000A     BRA LE, 0x5FBA
161:               		return ((AD_Value-AD_T[0]) *Kt[0]) TempA_OffSet_1;	
005FA6  78029E     MOV [W14], W5
005FA8  90021E     MOV [W14+2], W4
005FAA  780214     MOV [W4], W4
005FAC  528284     SUB W5, W4, W5
005FAE  90022E     MOV [W14+4], W4
005FB0  780214     MOV [W4], W4
005FB2  B9AA04     MUL.SS W5, W4, W4
005FB4  780204     MOV W4, W4
005FB6  B03E84     ADD #0x3E8, W4
005FB8  3700B7     BRA 0x6128
162:               
163:               	if(AD_Value < AD_T[2])								// < 16°C
005FBA  90021E     MOV [W14+2], W4
005FBC  420264     ADD W4, #0x4, W4
005FBE  780294     MOV [W4], W5
005FC0  78021E     MOV [W14], W4
005FC2  528F84     SUB W5, W4, [W15]
005FC4  34000D     BRA LE, 0x5FE0
164:               		return ((AD_Value-AD_T[1]) *Kt[1]) TempA_OffSet_2;
005FC6  78029E     MOV [W14], W5
005FC8  90021E     MOV [W14+2], W4
005FCA  E88204     INC2 W4, W4
005FCC  780214     MOV [W4], W4
005FCE  528284     SUB W5, W4, W5
005FD0  90022E     MOV [W14+4], W4
005FD2  E88204     INC2 W4, W4
005FD4  780214     MOV [W4], W4
005FD6  B9AA04     MUL.SS W5, W4, W4
005FD8  780284     MOV W4, W5
005FDA  205144     MOV #0x514, W4
005FDC  428204     ADD W5, W4, W4
005FDE  3700A4     BRA 0x6128
165:               
166:               	if(AD_Value < AD_T[3])								// < 19°C
005FE0  90021E     MOV [W14+2], W4
005FE2  420266     ADD W4, #0x6, W4
005FE4  780294     MOV [W4], W5
005FE6  78021E     MOV [W14], W4
005FE8  528F84     SUB W5, W4, [W15]
005FEA  34000D     BRA LE, 0x6006
167:               		return ((AD_Value-AD_T[2]) *Kt[2]) TempA_OffSet_3;
005FEC  78029E     MOV [W14], W5
005FEE  90021E     MOV [W14+2], W4
005FF0  420264     ADD W4, #0x4, W4
005FF2  780214     MOV [W4], W4
005FF4  528284     SUB W5, W4, W5
005FF6  90022E     MOV [W14+4], W4
005FF8  420264     ADD W4, #0x4, W4
005FFA  780214     MOV [W4], W4
005FFC  B9AA04     MUL.SS W5, W4, W4
005FFE  780284     MOV W4, W5
006000  206404     MOV #0x640, W4
006002  428204     ADD W5, W4, W4
006004  370091     BRA 0x6128
168:               
169:               	if(AD_Value < AD_T[4])								// < 21°C
006006  90021E     MOV [W14+2], W4
006008  420268     ADD W4, #0x8, W4
00600A  780294     MOV [W4], W5
00600C  78021E     MOV [W14], W4
00600E  528F84     SUB W5, W4, [W15]
006010  34000D     BRA LE, 0x602C
170:               		return ((AD_Value-AD_T[3]) *Kt[3]) TempA_OffSet_4;
006012  78029E     MOV [W14], W5
006014  90021E     MOV [W14+2], W4
006016  420266     ADD W4, #0x6, W4
006018  780214     MOV [W4], W4
00601A  528284     SUB W5, W4, W5
00601C  90022E     MOV [W14+4], W4
00601E  420266     ADD W4, #0x6, W4
006020  780214     MOV [W4], W4
006022  B9AA04     MUL.SS W5, W4, W4
006024  780284     MOV W4, W5
006026  2076C4     MOV #0x76C, W4
006028  428204     ADD W5, W4, W4
00602A  37007E     BRA 0x6128
171:               
172:               	if(AD_Value < AD_T[5])								// < 24°C
00602C  90021E     MOV [W14+2], W4
00602E  42026A     ADD W4, #0xA, W4
006030  780294     MOV [W4], W5
006032  78021E     MOV [W14], W4
006034  528F84     SUB W5, W4, [W15]
006036  34000D     BRA LE, 0x6052
173:               		return ((AD_Value-AD_T[4]) *Kt[4]) TempA_OffSet_5;
006038  78029E     MOV [W14], W5
00603A  90021E     MOV [W14+2], W4
00603C  420268     ADD W4, #0x8, W4
00603E  780214     MOV [W4], W4
006040  528284     SUB W5, W4, W5
006042  90022E     MOV [W14+4], W4
006044  420268     ADD W4, #0x8, W4
006046  780214     MOV [W4], W4
006048  B9AA04     MUL.SS W5, W4, W4
00604A  780284     MOV W4, W5
00604C  208344     MOV #0x834, W4
00604E  428204     ADD W5, W4, W4
006050  37006B     BRA 0x6128
174:               
175:               	if(AD_Value < AD_T[6])								// < 27°C
006052  90021E     MOV [W14+2], W4
006054  42026C     ADD W4, #0xC, W4
006056  780294     MOV [W4], W5
006058  78021E     MOV [W14], W4
00605A  528F84     SUB W5, W4, [W15]
00605C  34000D     BRA LE, 0x6078
176:               		return ((AD_Value-AD_T[5]) *Kt[5]) TempA_OffSet_6;
00605E  78029E     MOV [W14], W5
006060  90021E     MOV [W14+2], W4
006062  42026A     ADD W4, #0xA, W4
006064  780214     MOV [W4], W4
006066  528284     SUB W5, W4, W5
006068  90022E     MOV [W14+4], W4
00606A  42026A     ADD W4, #0xA, W4
00606C  780214     MOV [W4], W4
00606E  B9AA04     MUL.SS W5, W4, W4
006070  780284     MOV W4, W5
006072  209604     MOV #0x960, W4
006074  428204     ADD W5, W4, W4
006076  370058     BRA 0x6128
177:               
178:               	if(AD_Value < AD_T[7])								// < 30°C
006078  90021E     MOV [W14+2], W4
00607A  42026E     ADD W4, #0xE, W4
00607C  780294     MOV [W4], W5
00607E  78021E     MOV [W14], W4
006080  528F84     SUB W5, W4, [W15]
006082  34000D     BRA LE, 0x609E
179:               		return ((AD_Value-AD_T[6]) *Kt[6]) TempA_OffSet_7;
006084  78029E     MOV [W14], W5
006086  90021E     MOV [W14+2], W4
006088  42026C     ADD W4, #0xC, W4
00608A  780214     MOV [W4], W4
00608C  528284     SUB W5, W4, W5
00608E  90022E     MOV [W14+4], W4
006090  42026C     ADD W4, #0xC, W4
006092  780214     MOV [W4], W4
006094  B9AA04     MUL.SS W5, W4, W4
006096  780284     MOV W4, W5
006098  20A8C4     MOV #0xA8C, W4
00609A  428204     ADD W5, W4, W4
00609C  370045     BRA 0x6128
180:               
181:               	if(AD_Value < AD_T[8])								// < 33°C
00609E  90021E     MOV [W14+2], W4
0060A0  420270     ADD W4, #0x10, W4
0060A2  780294     MOV [W4], W5
0060A4  78021E     MOV [W14], W4
0060A6  528F84     SUB W5, W4, [W15]
0060A8  34000D     BRA LE, 0x60C4
182:               		return ((AD_Value-AD_T[7]) *Kt[7]) TempA_OffSet_8;
0060AA  78029E     MOV [W14], W5
0060AC  90021E     MOV [W14+2], W4
0060AE  42026E     ADD W4, #0xE, W4
0060B0  780214     MOV [W4], W4
0060B2  528284     SUB W5, W4, W5
0060B4  90022E     MOV [W14+4], W4
0060B6  42026E     ADD W4, #0xE, W4
0060B8  780214     MOV [W4], W4
0060BA  B9AA04     MUL.SS W5, W4, W4
0060BC  780284     MOV W4, W5
0060BE  20BB84     MOV #0xBB8, W4
0060C0  428204     ADD W5, W4, W4
0060C2  370032     BRA 0x6128
183:               
184:               	if(AD_Value < AD_T[9])								// < 36°C
0060C4  90021E     MOV [W14+2], W4
0060C6  420272     ADD W4, #0x12, W4
0060C8  780294     MOV [W4], W5
0060CA  78021E     MOV [W14], W4
0060CC  528F84     SUB W5, W4, [W15]
0060CE  34000D     BRA LE, 0x60EA
185:               		return ((AD_Value-AD_T[8]) *Kt[8]) TempA_OffSet_9;
0060D0  78029E     MOV [W14], W5
0060D2  90021E     MOV [W14+2], W4
0060D4  420270     ADD W4, #0x10, W4
0060D6  780214     MOV [W4], W4
0060D8  528284     SUB W5, W4, W5
0060DA  90022E     MOV [W14+4], W4
0060DC  420270     ADD W4, #0x10, W4
0060DE  780214     MOV [W4], W4
0060E0  B9AA04     MUL.SS W5, W4, W4
0060E2  780284     MOV W4, W5
0060E4  20CE44     MOV #0xCE4, W4
0060E6  428204     ADD W5, W4, W4
0060E8  37001F     BRA 0x6128
186:               
187:               	if(AD_Value < AD_T[10])								// < 40 °C
0060EA  90021E     MOV [W14+2], W4
0060EC  420274     ADD W4, #0x14, W4
0060EE  780294     MOV [W4], W5
0060F0  78021E     MOV [W14], W4
0060F2  528F84     SUB W5, W4, [W15]
0060F4  34000D     BRA LE, 0x6110
188:               		return ((AD_Value-AD_T[9]) *Kt[9]) TempA_OffSet_10;
0060F6  78029E     MOV [W14], W5
0060F8  90021E     MOV [W14+2], W4
0060FA  420272     ADD W4, #0x12, W4
0060FC  780214     MOV [W4], W4
0060FE  528284     SUB W5, W4, W5
006100  90022E     MOV [W14+4], W4
006102  420272     ADD W4, #0x12, W4
006104  780214     MOV [W4], W4
006106  B9AA04     MUL.SS W5, W4, W4
006108  780284     MOV W4, W5
00610A  20E104     MOV #0xE10, W4
00610C  428204     ADD W5, W4, W4
00610E  37000C     BRA 0x6128
189:               
190:               	return ((AD_Value-AD_T[10]) *Kt[10]) TempA_OffSet_11;
006110  78029E     MOV [W14], W5
006112  90021E     MOV [W14+2], W4
006114  420274     ADD W4, #0x14, W4
006116  780214     MOV [W4], W4
006118  528284     SUB W5, W4, W5
00611A  90022E     MOV [W14+4], W4
00611C  420274     ADD W4, #0x14, W4
00611E  780214     MOV [W4], W4
006120  B9AA04     MUL.SS W5, W4, W4
006122  780284     MOV W4, W5
006124  20F3C4     MOV #0xF3C, W4
006126  428204     ADD W5, W4, W4
191:               }
006128  780004     MOV W4, W0
00612A  FA8000     ULNK
00612C  060000     RETURN
192:               
193:               
194:               unsigned int Pressure_Read_45(int AD_Value)
195:               {
00612E  FA0002     LNK #0x2
006130  780F00     MOV W0, [W14]
196:               	// la sonda di pressione 0-45bar ha un segnale d'uscita utile da 0.5 a 4.5.
197:               	//	Bar		Vout	Bit
198:               	//	0		0.5v	102
199:               	//	45		4.5v	921
200:               	// da cui si ricava il fattore K di conversione lineare 55mBar/bit (originale 54.945, errore con il nuovo 45.045, inferiore ad 1 bit)
201:               	//	K ==> 55mBar/bit
202:               	if(AD_Value > 102)
006132  200664     MOV #0x66, W4
006134  78029E     MOV [W14], W5
006136  528F84     SUB W5, W4, [W15]
006138  340007     BRA LE, 0x6148
203:               		return ((AD_Value -102)*55);
00613A  78029E     MOV [W14], W5
00613C  200374     MOV #0x37, W4
00613E  B9AA04     MUL.SS W5, W4, W4
006140  780284     MOV W4, W5
006142  2EA164     MOV #0xEA16, W4
006144  428204     ADD W5, W4, W4
006146  370001     BRA 0x614A
204:               	else
205:               		return 0;
006148  EB0200     CLR W4
206:               }
00614A  780004     MOV W4, W0
00614C  FA8000     ULNK
00614E  060000     RETURN
207:               
208:               unsigned int Pressure_Read_34(int AD_Value)
209:               {
006150  FA0002     LNK #0x2
006152  780F00     MOV W0, [W14]
210:               	// la sonda di pressione 0-45bar ha un segnale d'uscita utile da 0.5 a 4.5.
211:               	//	Bar		Vout	Bit
212:               	//	0		0.5v	102
213:               	//	34		4.5v	921
214:               	// da cui si ricava il fattore K di conversione lineare 41mBar/bit (originale 41.514, errore con il nuovo 45.045, inferiore ad 1 bit)
215:               	//	K ==> 55mBar/bit
216:               	if(AD_Value > 102)
006154  200664     MOV #0x66, W4
006156  78029E     MOV [W14], W5
006158  528F84     SUB W5, W4, [W15]
00615A  340007     BRA LE, 0x616A
217:               		return ((AD_Value -102)*42);
00615C  78029E     MOV [W14], W5
00615E  2002A4     MOV #0x2A, W4
006160  B9AA04     MUL.SS W5, W4, W4
006162  780284     MOV W4, W5
006164  2EF444     MOV #0xEF44, W4
006166  428204     ADD W5, W4, W4
006168  370001     BRA 0x616C
218:               	else
219:               		return 0;
00616A  EB0200     CLR W4
220:               }
00616C  780004     MOV W4, W0
00616E  FA8000     ULNK
006170  060000     RETURN
221:               
222:               //----------------------------------------------------------------------------------
223:               // Steinhart-Hart
224:               // La formula di linearizzazione è: 
225:               // Temperatura (in Kelvin) = 1 / [ a + (b * lnR) + (c * (lnR³)) ] - dComp 
226:               // Temperatura (in Celsius) = 1 / [ a + (b * lnR) + (c * (lnR³)) ] - dComp - 273.15
227:               //
228:               // I parametri A,B,C sono stati calcolati con il "Thermistor calculator" a questo link:
229:               // http://www.thinksrs.com/downloads/programs/Therm%20Calc/NTCCalibrator/NTCcalculator.htm
230:               // I valori usati per il calcolo sono stati prelevati dal datasheet del produttore
231:               // del sensore PTC "AMWEI COP5X25LPTC1000F1500" considerando il range utilizzato -30..70°C
232:               // "AMWEI Nickel Plating Copper Tube Linear PTC Thermistor Temperature Sensor Probe COP5X25LPTC1000F1500 Data Sheet.pdf"
233:               // che è conosciuta sul mercato con la sigla "KTY81-110"
234:               // Per i valori di Gain e Offset riferirsi al DOC "Curva PTC KTY81-110.xls"
235:               // Valore R @ 100°C ->	1696 Ohm (MAX)
236:               // Valore R @ 70°C ->	1392 Ohm (MAX)
237:               // Valore R @ 20°C -> 	961 Ohm (MIDDLE)
238:               // Valore R @ -30°C -> 	624 Ohm (MIN)
239:               //----------------------------------------------------------------------------------
240:               	double R1 = 4700.0; 							// resistenza in serie alla PTC
241:               	double Vref = 5.0;							// Vref di alimentazione PTC
242:               	double VoMAX = 2.5;							// Tensione di uscita MAX OP
243:               	double ADres = 1023.0;						// Risoluzione A/D 10bit
244:               
245:               	double Gain;
246:               	double Gain1 = 4.0931935; //4.113547;						// Range -30 +70°C (-38 +72)
247:               	double Gain2 = 14.0; //13.974521;					// Range +10 +42°C (+10 +41.5)
248:               	double Offset;
249:               	double Offset1 = 0.586025-0.04; //0.546712; // MAX=1.15781 -> Delta = 0.611098 -> G=4.0909968				// Offset per range -30 +70°C
250:               	double Offset2 = 0.793054+0.001; //0.792301; // MAX=0.971198 -> Delta = 0.178897 -> G=13.974521				// Offset per range +10 +42°C
251:               	double Vout;
252:               	double Vptc;
253:               	double Rth;
254:               	double logR;
255:               	double logR3;
256:               	double kelvin;
257:               	double celsius;
258:               	double dComp;
259:               	double A;
260:               	double B;
261:               	double C;
262:               									// Coefficienti per modello Steinhart-Hart x range -30 .. +70 °C
263:               	double A1 = 24.66335875e-3;	 	// x range -30 .. +70 °C	R:624 -> -30°C
264:               	double B1 = -39.04130450e-4;		// x range -30 .. +70 °C	R:961 -> 20°C
265:               	double C1 = 171.6693777e-7;		// x range -30 .. +70 °C	R:1392 -> 70°C
266:               
267:               									// Coefficienti per modello Steinhart-Hart x range 10 .. +42 °C	
268:               									// Nota: Usato range 0..50°C x calcolo parametri
269:               	double A2 = 24.01859610e-3;	 	// x range 10 .. +42 °C		R:815 -> 0°C	
270:               	double B2 = -37.71246222e-4;	// x range 10 .. +42 °C		R:1000 -> 25°C	
271:               	double C2 = 163.4093844e-7;		// x range 10 .. +42 °C		R:1209 -> 50°C	
272:               
273:               	double K = 3.75; 				// dissipation factor (AMWEY -> 2.5..5 mW/C)
274:               
275:               int Steinhart(int AD_Value, int Range)
276:               {
006172  FA0004     LNK #0x4
006174  BE9F88     MOV.D W8, [W15++]
006176  780F00     MOV W0, [W14]
006178  980711     MOV W1, [W14+2]
277:               
278:               
279:               	switch(Range)
00617A  90021E     MOV [W14+2], W4
00617C  520FE1     SUB W4, #0x1, [W15]
00617E  320003     BRA Z, 0x6186
006180  520FE2     SUB W4, #0x2, [W15]
006182  320016     BRA Z, 0x61B0
006184  37002A     BRA 0x61DA
280:               	{
281:               		case 1:
282:               				Gain = Gain1;
006186  8077A4     MOV Gain1, W4
006188  8077B5     MOV 0xEF6, W5
00618A  887904     MOV W4, Gain
00618C  887915     MOV W5, 0xF22
283:               				Offset = Offset1;
00618E  8077E4     MOV Offset1, W4
006190  8077F5     MOV 0xEFE, W5
006192  887924     MOV W4, Offset
006194  887935     MOV W5, 0xF26
284:               				A = A1;
006196  807824     MOV A1, W4
006198  807835     MOV 0xF06, W5
00619A  887A44     MOV W4, A
00619C  887A55     MOV W5, 0xF4A
285:               				B = B1;
00619E  807844     MOV B1, W4
0061A0  807855     MOV 0xF0A, W5
0061A2  887A64     MOV W4, B
0061A4  887A75     MOV W5, 0xF4E
286:               				C = C1;
0061A6  807864     MOV C1, W4
0061A8  807875     MOV 0xF0E, W5
0061AA  887A84     MOV W4, C
0061AC  887A95     MOV W5, 0xF52
287:               				break;
0061AE  370015     BRA 0x61DA
288:               		case 2:
289:               				Gain = Gain2;
0061B0  8077C4     MOV Gain2, W4
0061B2  8077D5     MOV 0xEFA, W5
0061B4  887904     MOV W4, Gain
0061B6  887915     MOV W5, 0xF22
290:               				Offset = Offset2;
0061B8  807804     MOV Offset2, W4
0061BA  807815     MOV 0xF02, W5
0061BC  887924     MOV W4, Offset
0061BE  887935     MOV W5, 0xF26
291:               				A = A2;
0061C0  807884     MOV A2, W4
0061C2  807895     MOV 0xF12, W5
0061C4  887A44     MOV W4, A
0061C6  887A55     MOV W5, 0xF4A
292:               				B = B2;
0061C8  8078A4     MOV B2, W4
0061CA  8078B5     MOV 0xF16, W5
0061CC  887A64     MOV W4, B
0061CE  887A75     MOV W5, 0xF4E
293:               				C = C2;				
0061D0  8078C4     MOV C2, W4
0061D2  8078D5     MOV 0xF1A, W5
0061D4  887A84     MOV W4, C
0061D6  887A95     MOV W5, 0xF52
294:               				break;
0061D8  000000     NOP
295:               	}
296:               
297:               	Vout =  (double)(AD_Value) / ADres * VoMAX;
0061DA  78021E     MOV [W14], W4
0061DC  DEA2CF     ASR W4, #15, W5
0061DE  BE0004     MOV.D W4, W0
0061E0  07D16E     RCALL ___floatsisf
0061E2  BE0300     MOV.D W0, W6
0061E4  807784     MOV ADres, W4
0061E6  807795     MOV 0xEF2, W5
0061E8  BE0104     MOV.D W4, W2
0061EA  BE0006     MOV.D W6, W0
0061EC  07D0E6     RCALL ___divsf3
0061EE  BE0200     MOV.D W0, W4
0061F0  BE0304     MOV.D W4, W6
0061F2  807764     MOV VoMAX, W4
0061F4  807775     MOV 0xEEE, W5
0061F6  BE0104     MOV.D W4, W2
0061F8  BE0006     MOV.D W6, W0
0061FA  07D210     RCALL ___mulsf3
0061FC  BE0200     MOV.D W0, W4
0061FE  887944     MOV W4, Vout
006200  887955     MOV W5, 0xF2A
298:               	Vptc = (Vout / Gain) + Offset;
006202  807946     MOV Vout, W6
006204  807957     MOV 0xF2A, W7
006206  807904     MOV Gain, W4
006208  807915     MOV 0xF22, W5
00620A  BE0104     MOV.D W4, W2
00620C  BE0006     MOV.D W6, W0
00620E  07D0D5     RCALL ___divsf3
006210  BE0200     MOV.D W0, W4
006212  BE0304     MOV.D W4, W6
006214  807924     MOV Offset, W4
006216  807935     MOV 0xF26, W5
006218  BE0104     MOV.D W4, W2
00621A  BE0006     MOV.D W6, W0
00621C  07D071     RCALL ___addsf3
00621E  BE0200     MOV.D W0, W4
006220  887964     MOV W4, Vptc
006222  887975     MOV W5, 0xF2E
299:               	Rth = (R1 * Vptc ) / (Vref - Vptc); //Vptc / (Vref - Vptc / R1);    //(R1 * Vptc ) / (Vin - Vptc);
006224  807726     MOV R1, W6
006226  807737     MOV 0xEE6, W7
006228  807964     MOV Vptc, W4
00622A  807975     MOV 0xF2E, W5
00622C  BE0104     MOV.D W4, W2
00622E  BE0006     MOV.D W6, W0
006230  07D1F5     RCALL ___mulsf3
006232  BE0200     MOV.D W0, W4
006234  BE0404     MOV.D W4, W8
006236  807746     MOV Vref, W6
006238  807757     MOV 0xEEA, W7
00623A  807964     MOV Vptc, W4
00623C  807975     MOV 0xF2E, W5
00623E  BE0104     MOV.D W4, W2
006240  BE0006     MOV.D W6, W0
006242  07D05D     RCALL ___subsf3
006244  BE0200     MOV.D W0, W4
006246  BE0104     MOV.D W4, W2
006248  BE0008     MOV.D W8, W0
00624A  07D0B7     RCALL ___divsf3
00624C  BE0200     MOV.D W0, W4
00624E  887984     MOV W4, Rth
006250  887995     MOV W5, 0xF32
300:               	logR  = log(Rth);
006252  807984     MOV Rth, W4
006254  807995     MOV 0xF32, W5
006256  BE0004     MOV.D W4, W0
006258  07D18A     RCALL _logf
00625A  BE0200     MOV.D W0, W4
00625C  8879A4     MOV W4, logR
00625E  8879B5     MOV W5, 0xF36
301:               	logR3 = logR * logR * logR;
006260  8079A6     MOV logR, W6
006262  8079B7     MOV 0xF36, W7
006264  8079A4     MOV logR, W4
006266  8079B5     MOV 0xF36, W5
006268  BE0104     MOV.D W4, W2
00626A  BE0006     MOV.D W6, W0
00626C  07D1D7     RCALL ___mulsf3
00626E  BE0200     MOV.D W0, W4
006270  BE0304     MOV.D W4, W6
006272  8079A4     MOV logR, W4
006274  8079B5     MOV 0xF36, W5
006276  BE0104     MOV.D W4, W2
006278  BE0006     MOV.D W6, W0
00627A  07D1D0     RCALL ___mulsf3
00627C  BE0200     MOV.D W0, W4
00627E  8879C4     MOV W4, logR3
006280  8879D5     MOV W5, 0xF3A
302:               
303:               	dComp = (Vptc*Vptc)/(K * Rth);				// Compensazione dissipazione
006282  807966     MOV Vptc, W6
006284  807977     MOV 0xF2E, W7
006286  807964     MOV Vptc, W4
006288  807975     MOV 0xF2E, W5
00628A  BE0104     MOV.D W4, W2
00628C  BE0006     MOV.D W6, W0
00628E  07D1C6     RCALL ___mulsf3
006290  BE0200     MOV.D W0, W4
006292  BE0404     MOV.D W4, W8
006294  8078E6     MOV K, W6
006296  8078F7     MOV 0xF1E, W7
006298  807984     MOV Rth, W4
00629A  807995     MOV 0xF32, W5
00629C  BE0104     MOV.D W4, W2
00629E  BE0006     MOV.D W6, W0
0062A0  07D1BD     RCALL ___mulsf3
0062A2  BE0200     MOV.D W0, W4
0062A4  BE0104     MOV.D W4, W2
0062A6  BE0008     MOV.D W8, W0
0062A8  07D088     RCALL ___divsf3
0062AA  BE0200     MOV.D W0, W4
0062AC  887A24     MOV W4, dComp
0062AE  887A35     MOV W5, 0xF46
304:               	kelvin = (1.0 / (A + B * logR + C * logR3 )) - dComp;
0062B0  807A66     MOV B, W6
0062B2  807A77     MOV 0xF4E, W7
0062B4  8079A4     MOV logR, W4
0062B6  8079B5     MOV 0xF36, W5
0062B8  BE0104     MOV.D W4, W2
0062BA  BE0006     MOV.D W6, W0
0062BC  07D1AF     RCALL ___mulsf3
0062BE  BE0200     MOV.D W0, W4
0062C0  BE0304     MOV.D W4, W6
0062C2  807A44     MOV A, W4
0062C4  807A55     MOV 0xF4A, W5
0062C6  BE0104     MOV.D W4, W2
0062C8  BE0006     MOV.D W6, W0
0062CA  07D01A     RCALL ___addsf3
0062CC  BE0200     MOV.D W0, W4
0062CE  BE0404     MOV.D W4, W8
0062D0  807A86     MOV C, W6
0062D2  807A97     MOV 0xF52, W7
0062D4  8079C4     MOV logR3, W4
0062D6  8079D5     MOV 0xF3A, W5
0062D8  BE0104     MOV.D W4, W2
0062DA  BE0006     MOV.D W6, W0
0062DC  07D19F     RCALL ___mulsf3
0062DE  BE0200     MOV.D W0, W4
0062E0  BE0104     MOV.D W4, W2
0062E2  BE0008     MOV.D W8, W0
0062E4  07D00D     RCALL ___addsf3
0062E6  BE0200     MOV.D W0, W4
0062E8  BE0104     MOV.D W4, W2
0062EA  200000     MOV #0x0, W0
0062EC  23F801     MOV #0x3F80, W1
0062EE  07D065     RCALL ___divsf3
0062F0  BE0200     MOV.D W0, W4
0062F2  BE0304     MOV.D W4, W6
0062F4  807A24     MOV dComp, W4
0062F6  807A35     MOV 0xF46, W5
0062F8  BE0104     MOV.D W4, W2
0062FA  BE0006     MOV.D W6, W0
0062FC  07D000     RCALL ___subsf3
0062FE  BE0200     MOV.D W0, W4
006300  8879E4     MOV W4, kelvin
006302  8879F5     MOV W5, 0xF3E
305:               	celsius = kelvin - 273.15;
006304  8079E4     MOV kelvin, W4
006306  8079F5     MOV 0xF3E, W5
006308  293332     MOV #0x9333, W2
00630A  243883     MOV #0x4388, W3
00630C  BE0004     MOV.D W4, W0
00630E  07CFF7     RCALL ___subsf3
006310  BE0200     MOV.D W0, W4
006312  887A04     MOV W4, celsius
006314  887A15     MOV W5, 0xF42
306:               
307:               	return (int)(celsius * 100);
006316  807A04     MOV celsius, W4
006318  807A15     MOV 0xF42, W5
00631A  200002     MOV #0x0, W2
00631C  242C83     MOV #0x42C8, W3
00631E  BE0004     MOV.D W4, W0
006320  07D17D     RCALL ___mulsf3
006322  BE0200     MOV.D W0, W4
006324  BE0004     MOV.D W4, W0
006326  07D08F     RCALL ___fixsfsi
006328  BE0200     MOV.D W0, W4
00632A  780204     MOV W4, W4
308:               }
00632C  780004     MOV W4, W0
00632E  BE044F     MOV.D [--W15], W8
006330  FA8000     ULNK
006332  060000     RETURN
309:               
